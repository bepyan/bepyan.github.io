<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bepyan.github.io</id>
    <title>bepyan blog</title>
    <updated>2023-03-18T08:36:42.967Z</updated>
    <generator>generate-rss</generator>
    <author>
        <name>Edward Kim</name>
        <email>bepyan@naver.com</email>
        <uri>https://bepyan.github.io</uri>
    </author>
    <link rel="alternate" href="https://bepyan.github.io"/>
    <link rel="self" href="https://bepyan.github.io/atom"/>
    <subtitle>개발하면서 탐구한 것을 소소하게 기록하는 공간입니다.</subtitle>
    <logo>https://bepyan.github.io/images/base.jpg</logo>
    <icon>https://bepyan.github.io/favicon.ico</icon>
    <rights>All rights reserved since 2022, Edward Kim</rights>
    <category term="Technologies"/>
    <entry>
        <title type="html"><![CDATA[Github Action에서 Error: Cannot find module 에러 해결]]></title>
        <id>/blog/2022/cannot-find-module-in-github-action</id>
        <link href="https://bepyan.github.io/blog/2022/cannot-find-module-in-github-action"/>
        <updated>2022-12-22T01:13:19.000Z</updated>
        <summary type="html"><![CDATA[at Function.Module._resolveFilename (node:internal/modules/cjs/loader:985:15)]]></summary>
        <content type="html"><![CDATA[
로컬에서는 문제가 없는데 github action에서만 에러가 발생될 때가 있다.

```
Error: Cannot find module './siteMap.config.ts'
Require stack:
- /home/runner/work/bepyan.github.io/bepyan.github.io/imaginaryUncacheableRequireResolveScript
    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:985:15)
```

---

## 원인

파일의 **대소문자**(case sensitive)가 문제이다!

리눅스는 case sensitive하고 윈도우와 맥은 case sensitive하지 못한다.
다른 말로 리눅스에선 `File.txt`과 `file.txt`이 다른 파일이고 윈도우와 맥에선 같은 파일이다.

git action은 리눅스 환경(`ubuntu-latest`)이기에 대소문자가 구분되어 파일을 찾을 수 없게 된다.

---

## 해결 방법

**파일명 대소문자를 알맞게 수정해주자.**

여기서 골치 아픈 것이 하나 있다.
git이 파일명의 대소문자를 구별할 수 없어 파일명 수정 후 제대로 커밋을 할 수 없다는 것이다.
이 땐 `git mv` 명령어를 활용하면 된다.

```shell
git mv as-is to-be
git mv siteMap.config.ts sitemap.config.ts
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="troubleshooting"/>
        <category label="git"/>
        <category label="github-action"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS-in-JS 라이브러리들에 대한 고찰]]></title>
        <id>/blog/2022/css-in-js</id>
        <link href="https://bepyan.github.io/blog/2022/css-in-js"/>
        <updated>2022-02-11T16:31:47.000Z</updated>
        <summary type="html"><![CDATA[다양한 CSS-in-JS 라이브러리가 있는데 이들은 어떤 차이점이 있을까? 더 나아가 어떤 상황에서 어떤 라이브러리를 사용하면 좋을까? 🍀]]></summary>
        <content type="html"><![CDATA[
## 들어가면서

#### 이 글의 목적

- 다양한 CSS-in-JS 라이브러리가 있는데 이들은 어떤 차이점이 있을까?
- 더 나아가 어떤 상황에서 어떤 라이브러리를 사용하면 좋을까?

<br />

#### CSS-in-JS가 대세인 이유

- 중복되지 않는 class 이름을 고려할 필요가 없다.
- JS 코드와 CSS가 상태 값을 공유할 수 있다.
- 컴포넌트와 스타일 코드를 쉽게 오갈 수 있다.
- 자동으로 [vendor-prefix](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix)을 붙여준다.

⇒ **개발 친화적 🌻  DX ( Developer Experience )**

<br />

2020, 2021에 들어서서 많은 CSS-in-JS 라이브러리가 등장했다.

- [https://2021.stateofcss.com/en-US/technologies/css-in-js](https://2021.stateofcss.com/en-US/technologies/css-in-js)
- [https://risingstars.js.org/2021/en#section-css-in-js](https://risingstars.js.org/2021/en#section-css-in-js)

css-in-js의 동작 방식은 크게 **runtime**, **zero-runtime** 으로 나눠진다.
runtime이 반드시 성능저하를 발생시키진 않고 프로젝트 규모와 상황에 따라 달라질 수 있음을 염두하고 살펴보도록 하자.

---

## **runtime**

**javascript runtime에서 필요한 CSS를 동적으로 만들어 적용한다.**

대표적으로 잘 알려진 [styled-component](https://styled-components.com/), [emotion](https://emotion.sh/docs/introduction) 이 있다.

아래 styled-components로 만든 예시를 살펴보자.
버튼의 상태가 바뀌면서 style 코드가 동적으로 생성되어 삽입되는 것을 볼 수 있다.

![](<https://images.velog.io/images/bepyan/post/7d5ee0a5-d698-4615-a592-15847466cacb/%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%E1%86%A8-2022-01-25-%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB-12.42.01%20(1).gif>)

- 개발모드에서는 `<style>` 태그에 style을 추가하는 방식을 사용한다.

  - 디버깅에 이점이 있다고 한다.

- 배포 모드에서는 stylesSheet을 [CSSStylesSheet.insertRule](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule) 통해 바로[CSSOM](https://dkmqflx.github.io/frontend/2020/09/14/jscssom/)에 주입한다.
  - 성능상의 이짐이 있다고 한다.

<br />

**css-loader가 필요 없다.**

- css파일을 생성하지 않기에 webpack에서 css-loader가 필요 없다.

<br />

#### 런타임 오버헤드가 발생할 수 있다.

- 런타임에서 동적으로 스타일을 생성하기에 스타일이 수시로 변경된다면...
- ex) 스크롤, 드래그 앤 드랍 관련 복잡한 에니메이션

<br />

[**styled-components 과 emotion의 차이를 알고 싶다면?**](./styled-components-vs-emotion)

---

## **zero-runtime**

런타임에 css를 생성하지않으면서 **페이지를 더 빨리 로드할 수 있다.**
JS 번들에서 styles코드를 모두 실행되어야 페이지가 로드된다.

![](https://images.velog.io/images/bepyan/post/a45cf494-a87a-4b4d-97d0-bbc857c36d0d/image.png)

runtime에서 스타일이 생성되지 않는다.

- props 변화에 따른 동적인 스타일은 css 변수를 통해 적용한다.

<br />

빌드 타임에 css를 생성해야기에 webpack 설정을 해야 한다.

- React CRA을 사용한다면 eject해서 webpack 설정해야 하는데 굉장히 번거롭다.
- runtime에서 css polyfill를 사용할 수 없어 브라우저 버전 이슈가 있을 수 있다.

<br />

**첫 load는 빠르지만, 첫 paint는 느릴 수 있다.**

![](https://images.velog.io/images/bepyan/post/2f0e8b75-f2f9-43b0-93af-671bdeef3cb3/image.png)

css styles까지 모두 로드가 되어야 첫 paint를 시작된다.
반면 runtime에서는 style를 로드하면서 첫 paint를 시작할 수 있다. ( 로딩화면 )

<br />

대표적인 라이브러리

- [linaria](https://linaria.dev/)
  - styled-component 문법 그대로 사용해서 러닝커브가 없을 것 같다.
  - [styled-components와 속도 비교](https://pustelto.com/blog/css-vs-css-in-js-perf/)
  - mini-css-extract-plugin에 의해 critical css를 판단할 수 없는 경우 linaria의 collect를 사용가능하다.
- [vanilla-extract](https://vanilla-extract.style/)
  - 사실상 typescript로 css를 작성하는 라이브러리. (`.css.ts`)
  - [css-module](https://github.com/css-modules/css-modules)와 거의 흡사하다.
  - tagged template literals를 지원하지 않는다.
  - 현재 굉장히 높은 만족도와 관심을 받고 있다.

<br />

### critical CSS

- 초기 화면에서 필요한 CSS이다.
- critical CSS 추출과 runtime CSS 생성은 trade-off 관계를 갖고 있다.
- SSR에서 중요한 쟁점이다. 사전에 CSS 추출을 할 것인가?

---

## **near-zero-runtime** (stitches)

> [**stitches**](https://stitches.dev/)
>
> - SSR 환경에서도 잘 동작이 되도록 세팅이 되었다.
> - **runtime overhead와 zero-runtime의 제약을 해결 ⇒ 빠르다** > [benchmarks](https://stitches.dev/docs/benchmarks)

<br />

런타임에서 각각의 CSS 프로퍼티가 Atomic CSS처럼 적용된다.

- 반복되는 style을 atomics class로 변환하여 class를 재사용한다.
- 불필요한 런타임에서의 props interpolations를 줄인다.

```jsx
const StitchesButton1 = styled('button', {
  color: 'red',
  fontSize: 24,
});

const StitchesButton2 = styled('button', {
  color: 'red',
  fontSize: 24,
});
```

![](https://images.velog.io/images/bepyan/post/763654d2-4d56-4ab6-9999-ab5f270611d2/image.png)

하지만 style 순서가 바뀌면 재사용할 수 없다.

```jsx
const StitchesButton2 = styled('button', {
  fontSize: 24,
  color: 'red',
});
```

[참고](https://github.com/mui-org/material-ui/issues/22342#issuecomment-679468200)

<br />

emotion과 같이 [CSSStylesSheet.insertRule](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule) 을 사용하여 [CSSOM](https://dkmqflx.github.io/frontend/2020/09/14/jscssom/)에 직접 삽입한다.

사전에 정의한 [variants](https://stitches.dev/docs/variants)에 의해서 runtime 스타일링이 진행된다.

- 공식문서가 굉장히 친절하고 친절하게 되어 있어서

최고의 개발경험 제공

- 사전에 정의한 [테마 변수](https://stitches.dev/docs/tokens), variants 자동완성 제공

그리고 한계점...

- css style extraction이 되지 않는다.
- tagged template literals를 지원하지 않는다.
  Object syntax을 사용하는 이유는 keep the bundle size to a minimum이라고 한다.

### Atomic CSS

- 필요한 수치를 입력을 해두면 필요한 CSS를 자동으로 생성을 해두는 주문형(on-demand) 패러다임
- 대표적인 라이브러리는 [tailwindcss](https://tailwindcss.com/)
- 중복된 style 코드를 atomic한 클래스로 묶음으로 style sheet 사이즈를 줄인다.
  - [Facebook에서 Atomic CSS 도입으로 style sheet사이즈를 80% 줄인 사례](https://engineering.fb.com/2020/05/08/web/facebook-redesign/)

---

## 맺으면서

### CSS-in-JS 사용에 고려할 사항

- runtime overhead가 발생할 될 서비스인가?
  - 없다면 기존 runtime CSS-in-JS를 써도 전혀 문제가 없을 것이다.
- 직접 스타일을 작성하는가? 아니면 CSS 소스를 사용하는가?
  - tagged template literals를 지원하지 않는다면 CSS 소스를 옮기기 굉장히 불편할 것이다.
  - 따라서 stitches와 vanilla-extract의 도입은 CSS 변환의 수고스러움을 감수해야 할 것이다.
- SSR인가 CSR인가?
  - SSR를 설정하기 불편한 것이 있고 Critical CSS 최적화된 것이 있다.
  - CSR는 runtime stylesheets, SSR는 static CSS에 이점을 갖는다. [참고](https://andreipfeiffer.dev/blog/2021/css-in-js-styles-output#to-conclude)

<br />

멋진 개발팀들에서는 어떻게 라이브러리를 선택하는지 살펴보면 큰 도움이 될 것이다.

- [material-ul가 emotion을 선택한 이유](https://github.com/mui-org/material-ui/issues/22342)
- [shopify가 vanilla-extract를 선택한 이유](https://github.com/Shopify/foundational-design-system-proto/discussions/44#discussioncomment-888380)

<br />

개인적으로 생각했을 땐 결국 `개발 친화적 🌻`이 제일 중요한 이슈인 것 같다.

- 개발팀에서 편하게 디자인 시스템을 구축할 수 있는가?
- 개발 리소스 비용이 크기 때문...

---

### 프론트엔드의 흐름, build-time?

현대 프론트엔드의 작업흐름이 build-time에서 최적화가 이뤄지고 있다.

- 최신 CSS-in-JS 라이브러리들이 **build-time**(zero-runtime)으로 개발되고 있다.
- **TypeScript**를 통해서 build-time 및 run-time 이전에 type 체크, code IntelliSense를 제공해준다.
- **webpack, babel**를 통해서 다양한 브라우저에서 동작하는 앱을 만든다.
- Next.js가 각광을 받으면서 CSR에서 **SSR**로 웹이 개발되어 가고 있다.
- React, Vue를 넘어서 현재 **Svelte**가 많은 사람들의 주목을 받고 있다.
  - run-time에서 Virtual DOM를 통해 비교하여 변경사항을 반영하는 것이 아닌,
    build-time에서 어느 부분이 변경될지 파악하고 DOM을 업데이트하는 효율적인 명령 코드로 변환하여 사용한다.

<br />

javascript → typescript → build-time → compiler → **c++**

![https://c.tenor.com/pl54bxCr1x8AAAAM/wow-omg.gif](https://c.tenor.com/pl54bxCr1x8AAAAM/wow-omg.gif)

대학교 1학년 때부터 세뇌받듯이 들었던 말이 `프로그래밍 언어의 근본은 C++` 이다.
~~javascript, python 같은 스크립트 언어는 감히 고개를 내밀지도 못했다.~~

뛰어난 개발자들이 프론트엔드 생태계에 들어오면서 컴파일 시점에서의 최적화가 고도화 된 것 같다.

카카오의 좋은 문화 중 하나가 `복잡할 수록 본질로 돌아가라`이다.
그렇게 복잡한 웹 프론트엔드 생태계가 근본(?)을 되찾아가고 있지 않나 생각이 들었다.

---

**참고 자료**

- [**https://so-so.dev/web/css-in-js-whats-the-defference/**](https://so-so.dev/web/css-in-js-whats-the-defference/)
- [https://www.freecodecamp.org/news/the-tradeoffs-of-css-in-js-bee5cf926fdb/](https://www.freecodecamp.org/news/the-tradeoffs-of-css-in-js-bee5cf926fdb/)
- [facebook 개발자가 말하는 기존 CSS의 문제 및 CSS-in-JS의 필요성 2014](https://speakerdeck.com/vjeux/react-css-in-js)
- [https://ideveloper2.dev/blog/2019-05-05--thinking-about-emotion-js-vs-styled-component/](https://ideveloper2.dev/blog/2019-05-05--thinking-about-emotion-js-vs-styled-component/)
- [https://velog.io/@velopert/create-your-own-design-system-with-storybook](https://velog.io/@velopert/create-your-own-design-system-with-storybook)
- [https://brunch.co.kr/@kmongdev/17](https://brunch.co.kr/@kmongdev/17)
- [https://darrengwon.tistory.com/1563](https://darrengwon.tistory.com/1563)
- [https://github.com/andreipfeiffer/css-in-js/blob/main/README.md](https://github.com/andreipfeiffer/css-in-js/blob/main/README.md#vanilla-extract)
- [https://andreipfeiffer.dev/blog/2021/css-in-js-styles-output](https://andreipfeiffer.dev/blog/2021/css-in-js-styles-output)
- [https://jbee.io/web/from-2021-to-2022/](https://jbee.io/web/from-2021-to-2022/)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="styled-components"/>
        <category label="emotion"/>
        <category label="linaria"/>
        <category label="vanilla-extract"/>
        <category label="stitches"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(ESLint) Parsing error: The keyword 'import' is reserved]]></title>
        <id>/blog/2022/eslint-parse-error-import</id>
        <link href="https://bepyan.github.io/blog/2022/eslint-parse-error-import"/>
        <updated>2022-12-27T19:56:23.000Z</updated>
        <content type="html"><![CDATA[
vscode에서 개발 중 `Parsing error: The keyword 'import' is reserved`를 마주칠 때가 있다.
`typescript` 기반으로 개발을 하는데 `javascript`으로 된 설정 파일에서 에러를 뱉는다.

---

## 원인

말그대로 eslint의 parser가 `import` 구문을 해석할 수 없기 때문에 에러가 발생한다.
ESLint는 기본적으로 [Espree](https://github.com/eslint/espree)를 사용하고 이는 `commonjs` 기반으로 구문을 해석하기에 에러가 발생된다.

---

## 해결법

1. `commonjs`가 아닌 `module` 기반으로 구문을 해석한다.

```js:.eslintrc.cjs
module.exports = {
  //...
  overrides: [
    {
      files: ['**/*.ts?(x)'],
      parser: '@typescript-eslint/parser',
      //...
    },
    {
        files: ['**/*.js?(x)'],
        parserOptions: {
            sourceType: 'module',
            ecmaVersion: 2015,
        },
    },
  ],
};
```

2. 다른 parser를 통해서 구문을 해석한다.

가장 대표적인 [`@babel/parser`](https://www.npmjs.com/package/@babel/eslint-parser)를 사용하면 된다.
참고로 [`babel-eslint`](https://www.npmjs.com/package/babel-eslint)는 deprecated 되었다.

```shell
yarn add -D @babel/parser @babel/preset-env
```

```js:.eslintrc.cjs
module.exports = {
  parser: '@babel/eslint-parser',
  parserOptions: {
    requireConfigFile: false,
    babelOptions: {
      babelrc: false,
      configFile: false,
      presets: ["@babel/preset-env"],
    },
  },
};
```

사실 parser의 default sourceType `module`여서 에러가 사라지는 것이다...
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="troubleshooting"/>
        <category label="eslint"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown Template Example]]></title>
        <id>/blog/2022/example</id>
        <link href="https://bepyan.github.io/blog/2022/example"/>
        <updated>2022-11-17T21:12:24.000Z</updated>
        <summary type="html"><![CDATA[마크다운 문법 사용 템플릿]]></summary>
        <content type="html"><![CDATA[
## h2 Heading

### h3 Heading

### **h3 Bold Heading**

#### h4 Heading

"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."

line break with '&nbsp;&nbsp;&nbsp;'  
line break with `<br />` <br />

---

## Emphasis

**This is bold text**

_This is italic text_

~~Strikethrough~~

## Blockquotes

> Blockquotes can also be nested...
>
> > ...by using additional greater-than signs right next to each other...
> >
> > > ...or with spaces between arrows.

## Lists

Unordered

- Create a list by starting a line with `-` or `*`
- Sub-lists are made by indenting 2 spaces:
  - Marker character change forces new list start:
    - Ac tristique libero volutpat at
    * Facilisis in pretium nisl aliquet
- Very easy!

Ordered

1. Lorem ipsum dolor sit amet
2. Consectetur adipiscing elit
3. Integer molestie lorem at massa

4. You can use sequential numbers...
5. ...or keep all the numbers as `1.`

Start numbering with offset:

57. foo
1. bar

## Code

Inline `code`

Block code

```
Sample text here...
```

Syntax highlighting

```js
var foo = function (bar) {
  return bar++;
};

console.log(foo(5));
```

Syntax highlighting with file name, highlight line

```ts:cores.ts {2}
export const cn = (classNames: ...any) => {
    return classNames.filter(Boolean).join(' ');
}
```

## Tables

| Option | Description                                                               |
| ------ | ------------------------------------------------------------------------- |
| data   | path to data files to supply the data that will be passed into templates. |
| engine | engine to be used for processing templates. Handlebars is the default.    |
| ext    | extension to be used for dest files.                                      |

Right aligned columns

| Option |                                                               Description |
| -----: | ------------------------------------------------------------------------: |
|   data | path to data files to supply the data that will be passed into templates. |
| engine |    engine to be used for processing templates. Handlebars is the default. |
|    ext |                                      extension to be used for dest files. |

## Links

[link text](https://bepyan.github.io/)

[**bold link text**](https://bepyan.github.io/)

[`code link text`](https://bepyan.github.io/)

Autoconverted link https://github.com/bepyan

## Images

![Minion](https://octodex.github.com/images/minion.png)

HTML `<Img />` tag

<img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" width={300} />
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="markdown"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js에 구글 애드센스 적용하기]]></title>
        <id>/blog/2022/google-adsense</id>
        <link href="https://bepyan.github.io/blog/2022/google-adsense"/>
        <updated>2022-12-04T17:00:11.000Z</updated>
        <content type="html"><![CDATA[
## 수익성 이해하기

수익은 월별 페이지 조회수 50,000부터 시작합니다.
따라서 그 이하의 조회수는 수익이 발생되지 않겠지요 🥲

[**Google 애드센스 계산기**](https://www.google.com/adsense/start/#calculator)를 통해서 연수익을 예상할 수 있습니다.
아시아 기준 인터넷 관련 콘텐츠에서 월별 50,000 조회수이면 1년에 6,700달러(870만원).. 즉, 월 7만원을 기대할 수 있습니다.
흠.. 과연 월 50,000 조회수를 받을 수 있지 모르겠네요..

## 구글 애드센스 시작하기

https://www.google.com/intl/ko_kr/adsense/start/

관련 정보를 기입해주고 `Next.js`에서 스크립트 파일을 삽입하면 됩니다.

```tsx:_app.tsx
import Script from 'next/script';

<Script
    async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2820184336962070"
    crossOrigin="anonymous"
/>
```

`자동광고` 설정을 통해서 별도의 설정없이 광고를 추가할 수 있습니다.
구글에서 사이트를 분석하여 알맞는 위치에 추가해주게 됩니다.

별도로 광고배너를 붙이는 방법은 추후에 알아보도록 합시다.

### 개인정보 보호 대비하기

지금까지는 특별히 대응해야할 점은 안보이는 것 같습니다.

- GDPR
  - 유럽 경제 지역(EEA) 및 영국 사용자에게 공개하고 이에 대한 동의를 얻어야 합니다.
- CCPA
  - 캘리포니아 소비자 개인정보 보호법, 미국 주 개인 정보 보호법을 준수하도록 지원하는 기능입니다.

## 참고

- https://ko.wix.com/blog/post/what-is-google-adsense
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="google adsense"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[styled-components 과 emotion, 도대체 차이가 뭔가?]]></title>
        <id>/blog/2022/styled-components-vs-emotion</id>
        <link href="https://bepyan.github.io/blog/2022/styled-components-vs-emotion"/>
        <updated>2022-02-10T16:30:09.000Z</updated>
        <summary type="html"><![CDATA[styled-components vs emotion 💥 도대체 차이가 뭘까??]]></summary>
        <content type="html"><![CDATA[
React에서는 보통 CSS-in-JS을 통해 스타일 작업을 진행한다.
그중에서 styled-components, emotion이 가장 유명하고 많이 사용된다.

하지만 도대체 차이가 뭘까?

<br />
<br />
<br />

### 제공하는 기능 비교

---

| library           | Attaching Props | Media Queries | Global Styles | Nested Selectors | Server Side Rendering | Theming Support | Composition |
| ----------------- | --------------- | ------------- | ------------- | ---------------- | --------------------- | --------------- | ----------- |
| styled-components | Yes             | Yes           | Yes           | Yes              | Yes                   | Yes             | Yes         |
| emotion           | Yes             | Yes           | Yes           | Yes              | Yes                   | Yes             | Yes         |

- 전반적인 스타일 기능은 똑같다.
- 둘다 sass문법을 사용하기에 스타일 문법에도 차이가 없다.
- [참고](https://github.com/jsjoeio/styled-components-vs-emotion)

<br />
<br />
<br />
<br />

### 사용 트랜드

---

![](https://images.velog.io/images/bepyan/post/3d77564b-92a7-46c3-843c-325af34ef765/image.png)

![](https://images.velog.io/images/bepyan/post/ce8b2326-f3a4-4834-935f-affb3e194a2b/image.png)

- styled-componets가 더 많이 사용되고 있으나 npm 다운로드 횟수를 보면 emotion이 더 많다.
- 근래 emotion의 만족도가 떨어지고 있다.
- [https://2021.stateofcss.com/en-US/technologies/css-in-js/](https://2021.stateofcss.com/en-US/technologies/css-in-js/)
- [https://www.npmtrends.com/@emotion/core-vs-styled-components](https://www.npmtrends.com/@emotion/core-vs-styled-components)

<br />
<br />
<br />
<br />

### 용량? 성능?

---

블로그, 사이트들을 참고하면 대게 emotion이 styled-components보다 조금 가볍고 빠르다고 한다.

먼저 https://bundlephobia.com/ 를 참고해서 최신 라이브러리 번들 사이즈를 살펴보자.

![](https://images.velog.io/images/bepyan/post/a702e482-5850-48af-aea8-dd37522a4bd2/image.png)

![](https://images.velog.io/images/bepyan/post/2cbaf6aa-3e4c-4fc9-8495-91eb3ebfc807/image.png)

![](https://images.velog.io/images/bepyan/post/7b926716-1280-4530-a272-bda929c9c518/image.png)

보통 emotion을 사용한다면 위 두가지 라이브러리를 모두 사용한다.
emotion 패키지 차이는 [여기](https://emotion.sh/docs/package-summary) 참고.

눈대중으로 보면 라이브러리 용량이 비슷해보인다. (1~2 kb 차이)
다만 `@emotion/react`만 사용한다면 용량이 1.5배 정도 차이가 난다.

<br />
<br />

그렇다면 속도 차이는 어떨까?

다양한 자료를 참고해보면 emotion이 근소하게 더 빠르다.
[참고 1](https://stitches.dev/docs/benchmarks), [참고 2](https://dev.to/meetdave3/styled-components-vs-emotion-js-a-performance-perspective-4eia), [참고 3](https://github.com/A-gambit/CSS-IN-JS-Benchmarks/blob/master/RESULT.md)

하지만 [2020 styled-component v5](https://styled-components.com/releases#v5.0.0) ?
[여기](https://medium.com/styled-components/announcing-styled-components-v5-beast-mode-389747abd987) 참고에 따르면 styled-components가 조금 더 빠르다고 한다.

**결론. 성능상 둘은 유의미하게 차이가 나지 않는다.**
emotion의 퍼포먼스가 전반적으로 더 좋게 나오고 있고 라이브러리 버전에 따라서 차이가 발생할 수 있다.

<br />
<br />
<br />
<br />

### emotion의 차별점

---

[**css props**](https://emotion.sh/docs/css-prop) 기능

- 인라인 스타일을 작성하지만 클래스가 되는 매직 ✨

```html
<div style={{color: "red"}}/>
```

기존 style 속성은 HTML 인라인 스타일로 주입이 된다.
스타일 우선순위를 다루기 어렵고 스타일 재활용도 힘들다.

```html
<div css={{color: "red"}} /> {/* 혹은 */}
<div css="{css`color:" red`} />
```

emotion jsx에서 제공해주는 css 속성을 활용하면 이를 클래스로 변환해준다.
기존 인라인으로 사용할 수 없었던 media query, pseudo selector, nested selector 등을 사용할 수 있다.

<br />
- [css props를 결합](https://velog.io/@velopert/create-your-own-design-system-with-storybook#%EB%B2%84%ED%8A%BC%EC%9D%98-theme-%EB%A7%8C%EB%93%A4%EA%B8%B0)하여 복잡한 스타일링을 진행할 수 있다.
  ```js
  <div css={[style, themes[theme], sizes[size]]} />
    
  const themes = {
    primary: css`
      color: red;
    `,  
    secondary: css`
      color: blue;
    `
  }
  const sizes = {
    small: css`
      fontSize: 0.75rem;
    `,
    medium: css`
      fontSize: 1rem;
    `
  }
  ```
  위와 같이 css 변수를 조립하여 컴포넌트 스타일링을 진행할 수 있다.
  ```ts
  type ThemeType = keyof typeof themes;
  type SizeType = keyof typeof size;
  ```
  typescript로 자동 타입지정까지 할 수 있는 이점이 있다.
  
  css override는 덤

<br />
<br />

**SSR**

- SSR에서 [별도의 설정 없이](https://emotion.sh/docs/ssr#gatsby-focus-wrapper) 동작이 된다.
- 반면 styled-components 같은 경우 [ServerStyleSheet](https://styled-components.com/docs/advanced#streaming-rendering)을 설정 해야 한다.

<br />
<br />

개인적으로 생각하는 단점

- 파일마다 `/** @jsx jsx */` 라는 [JSX Pragma](https://emotion.sh/docs/css-prop#jsx-pragma)를 작성해야하는데 이를 설정하기 귀찮다.
- 이는 React의 jsx와 똑같은 원리이다.
  `import React from "react"`을 해줘야 컴파일이 된다.
  ![](https://images.velog.io/images/bepyan/post/4214bfb7-8caa-4086-a4c3-48e98aaf408f/image.png)
  emotion의 jsx로 변환되어야 emotion의 css props 문법을 사용할 수 있다.
  `<img src="avatar.png" />` → `jsx('img', { src: 'avatar.png' })`
  <br />
react처럼 webpack단에서 이를 자동으로 주입시킬 수 있지만 역시 설정하기 귀찮다...
개인적으론 storybook 웹팩 설정에서 꽤나 골머리 아팠다...

<br />
<br />
<br />
<br />

### 결론

---

- 유의미한 성능차이가 있는 것이 아니다. 라이브러리 버전에 따라 달라질 수 있다.

- 개발팀에서 더 익숙한 것을 사용하면 될 것 같다.

- emotion의 css props로 css를 더 활용도 높게 조립할 수 있다. 하지만 안쓰면 그만이다.

- SSR에서는 emotion 세팅시 더 간편하다.

<br />
<br />

참고

https://ideveloper2.dev/blog/2019-05-05--thinking-about-emotion-js-vs-styled-component/
https://github.com/andreipfeiffer/css-in-js/blob/main/README.md#styled-components
https://brunch.co.kr/@kmongdev/17
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="styled-components"/>
        <category label="emotion"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프론트엔드 개발자 도구함]]></title>
        <id>/blog/2023/2023-frontend-library</id>
        <link href="https://bepyan.github.io/blog/2023/2023-frontend-library"/>
        <updated>2023-01-30T14:08:18.000Z</updated>
        <summary type="html"><![CDATA[직접 개발말고, 좋은 라이브러리를 씁시다!]]></summary>
        <content type="html"><![CDATA[
세상에는 좋은 라이브러리가 정말 많다!
100% 무료인 라이브러리들을 정리해봤다.
전부 써본 것은 아니고 필요할 때 써보면 좋겠다 싶은 것들만 정리했습니다.

---

## UI Design System

[**`material-ui`**](https://github.com/mui/material-ui) `react` &nbsp; [**`vuetify`**](https://github.com/vuetifyjs/vuetify) `vue`
Google의 디자인 시스템.
[Material Design 3](https://m3.material.io/develop/web)가 절찬 개발되고 있음.

[**`ant-design`**](https://github.com/ant-design/ant-design) `react`
Alibaba의 디자인 시스템.
큰 기업에서 그저 믿고 쓸 수 있는 안정적인 라이브러리.

[**`baseweb`**](https://github.com/uber/baseweb) `react`
Uber의 디자인 시스템.
깔끔한 흑백 테마 UI, 여기에 확장성이 곁들인.

[**`carbon`**](https://github.com/carbon-design-system/carbon) `react` `angular` `vue` `svelte` `vanillajs`
IBM의 디자인 시스템.
날카로운 UI가 무척 매력적임. ( [storyboook](https://react.carbondesignsystem.com/?path=/story/getting-started-welcome--welcome) )

[**`chakra-ui`**](https://github.com/chakra-ui/chakra-ui) `react`
`Box` 컴포넌트 기반으로 레이아웃을 쉽게 구축할 수 있는 것이 특징.
테마 커스터마이징, 접근성, 다크모드도 잘 지원해주기에 래핑해서 쓰기 좋은 라이브러리.

[**`mantine-ui`**](https://github.com/mantinedev/ui.mantine.dev) `react`
인지도는 조금 떨어지지만 개인적으로 깔끔하다고 생각이 듦.

[**`daisyui`**](https://github.com/saadeghi/daisyui) `tailwindcss`
tailwind를 래핑해주는 라이브라리라 모든 프레임워크에 사용할 수 있음.
클래스명이 간결하고 [theme](https://daisyui.com/docs/themes/)을 쉽게 구축할 수 있는 것이 특징.

[**`framework7`**](https://github.com/framework7io/framework7) `vanillajs` `react` `vue` `svelte`
aOS, iOS와 똑같이 생긴 UI kit을 제공.

[**`vant`**](https://github.com/youzan/vant) `vue`
모바일 웹을 타겟으로 하는 라이브러리.

---

### 참고용 (코드 복붙)

[**`hyperui`**](https://github.com/markmead/hyperui) `tailwindcss`
무척 무척 깔끔하고 완성도가 높음.
컴포넌트를 넘어서서 marketing 등 큰 단위의 레이아웃 예시도 있음.

[**`shadcn/ui`**](https://github.com/shadcn/ui) `next.js` `radix-ui` `tailwindcss` ✨
최근 뜨겁게 개발 중... 🔥
예시를 넘어서서 `Next.js` 시스템을 어떻게 구축해갈지 인사이트를 받을 수 있음.

[**`tw-elements`**](https://github.com/mdbootstrap/Tailwind-Elements/) `tailwindcss`
방대한 마크업 예제가 있음. ~~개인적으로 조금 아쉽..~~
마크업을 어떻게 작성할지 모를 때 참고하면 좋음.

[**`tabler`**](https://github.com/tabler/tabler) `bootstrap`
~~요즘 누가 bootstrap 씀?~~

---

### 읽어볼 만한 디자인 원칙

- [LINE Global Family Service](https://designsystem.line.me/LDSG/foundation/)

---

## UI component library

[**`headlessui`**](https://github.com/tailwindlabs/headlessui) `react` `vue` `tailwindcss` ✨
메뉴, 팝업, 모달 등 직접 구현하기 귀찮은 컴포넌트를 `headless`한 형태로 제공.
예시 UI 완성도가 무척 높아 그대로 따라하게 됨.

[**`radix-ui-primitives`**](https://github.com/radix-ui/primitives) `react`
복잡한 팝업, 모달을 완성도 높은 구조 `headless`한 형태로 제공.
슬랙 같은 관리툴 만들 때 무척 유용 함.

---

### Carousel

[**`swiper`**](https://github.com/nolimits4web/swiper) `vanillajs` `react` `vue` `svelte`
모바일 전용.

[**`glide`**](https://github.com/glidejs/glide) `vanillajs`
가벼움.

---

### Image Viewer

[**`lightgallery`**](https://github.com/sachinchoolur/lightGallery) `vanillajs` `react` `vue` `angluar` (상업적 용도는 유료)
내가 원하는 모든 기능이 있는 완성형 이미지 뷰어.

[**`medium-zoom`**](https://github.com/francoischalifour/medium-zoom) `vanillajs`
단순하게 이미지 확대해주는데 부드럽고 깔끔함.

---

### Drag and Drop

[**`react-beautiful-dnd`**](https://github.com/atlassian/react-beautiful-dnd) `react` (추가 개발 중단 됨)

---

### Toast

[**`react-hot-toast`**](https://github.com/timolins/react-hot-toast) `react` 무척 가볍고 깔끔함. 커스터마이징하기 쉬움. ✨

---

### Chart

[**`Chart.js`**](https://github.com/chartjs/Chart.js) `html canvas`

---

### Canvas

[**`fabric.js`**](https://github.com/fabricjs/fabric.js) `vanillajs`
[**`konva`**](https://github.com/konvajs/konva) `vanillajs`

---

### 기타

[**`tiptap`**](https://github.com/ueberdosis/tiptap) 텍스트 에디터 `v2.0 beta`
[**`kbar`**](https://github.com/timc1/kbar) `react` command palette (cmd+k) (아직 마이너버전)
[**`cobe`**](https://github.com/shuding/cobe) `vanillajs` 아주 이쁜 지구의

---

## Icons

[**`heroicons`**](https://github.com/tailwindlabs/heroicons) `tailwindcss`기반의 환경에서 쓰기 좋음. `outline` `solid` 둘다 있음.
[**`lucide`**](https://github.com/lucide-icons/lucide) 아주 다양한 환경에서 쓰기 좋음. `outline`만 있음. [`Feather Icons`](https://github.com/feathericons/feather) 기반.
[**`simple-icons`**](https://github.com/simple-icons/simple-icons) 브랜드 아이콘 창고. 없는 브랜드가 없음.

추가적으로 아이콘 검색하기 좋은 사이트.
**https://icones.netlify.app/**
**https://icons8.com/icons/color**

---

## Transition

[**`framer-motion`**](https://github.com/framer/motion) `react` ✨

[**`react-srping`**](https://github.com/pmndrs/react-spring) `react`

[**`gsap`**](https://github.com/greensock/GSAP) `vanillajs`

[**`easings.net`**](https://easings.net/) 다양한 `transition` 속성 예시.

---

## 프레임워크

[**`nextra`**](https://github.com/shuding/nextra) (`next.js` 공식문서 제작용)

---

## 유틸 도구

---

### 이미지 처리

[**`sharp`**](https://github.com/lovell/sharp) `node`환경에서 이미지를 효율적으로 가공.
[**`plaiceholder`**](https://github.com/joe-bell/plaiceholder) `node`환경에서 `blur`한 이미지 `placeholder`를 생성.

---

### 날짜

~~[`moment`](https://github.com/moment/moment/)~~ [**`dayjs`**](https://github.com/iamkun/dayjs/)
💪 Immutable, 🔥 Chainable, 🌐 I18n

[**`date-fns`**](https://github.com/date-fns/date-fns)
`Date`를 객체로 래핑하지 않고 `lodash` 처럼 유틸을 제공해주는 라이브러리.

---

### Code Syntax Highlighter

[**`shiki`**](https://github.com/shikijs/shiki)
[**`prism`**](https://github.com/PrismJS/prism)

---

### 기타

[**`contentlayer`**](https://github.com/contentlayerdev/contentlayer) 파일 데이터 관리 (아직 마이너버전)

---

## 개발외 도구

[**`gifox`**](https://gifox.app/) GIF 캡쳐 도구 ✨
무료버전 쓰다가 너무 좋아서 19,000원 결제함

[**`shottr`**](https://shottr.cc/) 캡쳐 도구 ✨
픽셀 체크, 색상 코드 확인, 화살표 표시 등 협업할 때 무척 도움이 됨!

[**`cleanshot`**](https://cleanshot.com/pricing) GIF + 캡쳐 도구
36,000원 유료

[**`Timer RH`**](https://apps.apple.com/us/app/timer-rh/id929960914?mt=12) 타이머. 건강을 위해서 쉬면서 코딩하자 🙏🏻
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="라이브러리"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[차세대 번들러 비교 및 분석 (feat. webpack, rollup, esbuild, vite)]]></title>
        <id>/blog/2023/bundlers</id>
        <link href="https://bepyan.github.io/blog/2023/bundlers"/>
        <updated>2023-02-21T13:19:01.000Z</updated>
        <summary type="html"><![CDATA[번들러가 왜 필요하고 어떻게 발전되고 가고 있을까?]]></summary>
        <content type="html"><![CDATA[
## 번들러 란?

간단하게 설명하자면 **여러개의 파일들을 하나의 파일로 묶어주는 도구**입니다.

프론트엔드에서 번들러의 역사가 길다면 길고 짧다고 하면 짧다고할 수 있을 것 같습니다.
지금은 너무나도 당연하게 `webpack` `vite` 같은 번들러를 사용하여 프론트엔드 개발환경을 구성하고 있는데요.
왜 그런 것일까요? 브라우저의 역사를 조금 알면 이해할 수 있을 겁니다.

### 번들러가 필요해진 이유

태초에, 브라우저는 [ES Modules](https://ui.toast.com/weekly-pick/ko_20180402)를 [지원하지 않았습니다](https://caniuse.com/es6-module).
다른 말로는 [ES6 import 문법](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import)을 사용할 수 없고, `<script>` 간 모듈을 내보낼 수 없다는 것입니다.

초기에는 몇몇 스크립트 파일만 있으면 서비스할 수 있었지만,
웹서비스가 기하급수적으로 복잡해지면서 방대해진 코드들을 관리하기 어려워졌습니다.
개발자들은 다양한 전략으로 코드를 여러 파일로 분리하였고, `window` `jQuery`와 같은 전역객체를 활용하여 통해 스크립트 파일 간 모듈을 공유했습니다.

사람들은 웹 브라우저에서 더 많은 활동을 하게 되었고 더 좋은 서비스 경험이 요구 되었습니다.
더 작은 용량의, 더 최적화된 리소스를 제공해주기,
흩어져 있는 여러 파일을 하나로 통합하고 문자를 압축시키기,
다양한 사용자 환경에서도 돌아가도록 코드를 변환하기,
안 쓰이는 소스코드 부분을 분석해서 제거하기,
...
웹사이트 전처리 요구사항이 점점 많아졌고 이를 자동화시켜줄 친구가 필요했습니다.
여기서 `grunt` `glub` 같은 도구가 하나 둘 등장하기 시작했고 마침내 `webpack`의 시대가 도래하게 되었습니다.

[2022 stateofjs 자료](https://2022.stateofjs.com/en-US/libraries/build-tools/)를 참고해보면 오늘 이 순간에도 번들러의 생태계가 빠른 속도로 변화되고 있습니다.

![230221-132853](/images/posts/bundler/230221-132853.png)

이 포스트에선 그 중 많이 알려진 `webpack` `rollup` `esbuild` `vite`에 대해 등장 순서대로 다뤄 볼 예정입니다.

---

## Webpack

![230304-140544](/images/posts/bundlers/230304-140544.png)

2012년 Tobias Koppers에 의해 webpack v1.0이 효율적으로 js파일을 통합해주는 도구로 공개되었습니다.
2016년 webpack v2.0이 릴리즈되고 ES6를 지원하여 커뮤니티의 큰 관심을 얻게 되었습니다.
2017년 webpack v3.0이 릴리즈되고 성능 개선, 기능 추가 되면서 사람들이 열광하기 시작했습니다.
2018년 webpack v4.0이 릴리즈되었는데 동시에 React, Anglular의 등장으로 SPA가 급부상하게 되면서 번들러의 역할 더욱 막중해지자 이른바 "대웹팩시대"가 도래하게 되었습니다.
현재는 2020-10-10에 릴리즈된 v5에서 지속적으로 업데이트되고 있습니다.

[**`webpack`**](https://webpack.kr/)의 정체성은 번들러의 목적인 "**통합**"에 있습니다.
'번들을 통합해서 관리할 순 없을까?'에 대한 고민이 webpack이 부상할 수밖에 없게 만들어 주었죠.

**설정이 간편하고 직관적.**
하나의 설정 파일에서 원하는 번들이 생성 될 수 있도록 컨트롤할 수 있습니다.
`entry`와 `output`을 명시하고 어떤 `plugin`과 `loader`로 파일들을 다룰 건지 명시하면 됩니다.

```js:webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: {
    home: './pages/home.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: ["babel-loader"],
      },
    ],
  },
  plugins: [new HtmlWebpackPlugin()],
};
```

<br />

**풍부한 plugins과 loaders.**
webpack은 굉장히 강력한 개발 커뮤니티가 뒷바침해주고 있습니다.
쉽게 `plugin`과 `loader`를 부착할 수 있기 때문인데요. `loader`를 통해서 파일들을 변환, 번들링, 빌드를 진행하고 `plugin`을 통해서 output 파일을 튜닝해줍니다.
필요에 따라 다양한 plugin, loader가 오픈소스로 개발되고 있어

**강력한 개발서버.**
webpack은 [Hot Module Replacement(HMR)](https://webpack.kr/guides/hot-module-replacement/)를 처음으로 제안했고 2012년부터 사용되어왔습니다.
HMR는 소스코드의 변화를 감지하여 브라우저를 직접 새로고침할 필요가 없이 변화를 바로 반영해줍니다. 개발자는 덕분에 더욱 신속하게 개발할 수가 있게 되었죠.
webpack v2, v3, v4을 거쳐서 다양한 파일(css)의 변화도 감지할 수 있게 되었고 안정화되었습니다.

**Code Splitting.**

webpack의 꽃이라고도 할 수 있는 [Code Splitting](https://webpack.kr/guides/code-splitting/)의 얘기도 빠질 수가 없습니다.

> "Code splitting is one of **the most compelling features** of webpack."

한마디로 설명하자면 **번들 로드 최적화**하는 작업입니다.
파일들을 여러 번들 파일으로 분리하여 병렬로 스크립트를 로드하여 페이지 로딩속도를 개선할 수 있습니다.
추가로 초기에 구동될 필요가 없는 코드를 분리하여 lazy loading을 통해 페이지 초기 로딩속도를 개선할 수 있습니다.

끝으로 당시 같이 거론되었던 번들링 라이브러리에 대해서 비교하면서 webpack 설명을 마치겠습니다.

### vs grunt

`grunt`는 `task runner`입니다.
minifying, 파일 통합, lint 적용 등 등록된 task를 순서대로 실행시켜 줍니다.
설정이 파편화되고 개발자가 직접 컨트롤해야하는 영역이 많습니다.
반면 `webpack`은 `module bundler`로 모듈을 통합하는 것에 초첨이 맞춰져 있습니다.

### vs glup

`glup`은 `grunt`와 흡사한 `task runner`입니다.
다만 stream-based로 파일을 접근하기에 grunt에 비해 성능이 더 우수하다고 평가를 받고 있습니다.

---

## Rollup

<img src="https://rollupjs.org/rollup-logo.svg" width="128px" />

webpack 시대 개막과 함께 2017년부터 개발이 시작된 `module bundler`입니다.
대세적으론 webpack의 열풍에 가려져 있었지만 점차 그의 매력이 인정을 받아 많은 차세대 번들러가 rollup을 벤치마킹하게 되었습니다.

[`v1.0`](https://github.com/rollup/rollup/blob/master/CHANGELOG.md#100) 2018-12-28
[`v2.0`](https://github.com/rollup/rollup/blob/master/CHANGELOG.md#200) 2020-03-06
[`v3.0`](https://github.com/rollup/rollup/blob/master/CHANGELOG.md#300) 2022-10-11

[**`Rollup`**](https://rollupjs.org/)의 정체성은 "**확장**"에 있습니다.

> "compiles small pieces of code into something larger and more complex, such as a library or application"

작은 코드조각들을 거대하고 복잡한 어플리케이션 혹은 라이브러리로 만들어 준다고 스스로 소개합니다.
같은 소스코드를 다양한 환경에 맞춰 다르게 발드하는 것을 생각하면 될 것 같습니다.
그러면서 자연스럽게 아래 여론이 형성되었습니다.

> "어플리케이션 만들 땐 webpack으로, **라이브러리 만들 땐 rollup으로!**"

rollup의 사용방식과 구성방식은 webpack과 거의 흡사합니다.
`input`과 `entry`를 설정하고 번들링에 적용할 기능을 `plugin` 형태로 끼워 넣으면 됩니다.

```js:rollup.config.js
import commonjs from '@rollup/plugin-commonjs';
import resolve from '@rollup/plugin-node-resolve';
import { terser } from 'rollup-plugin-terser';

const production = !process.env.ROLLUP_WATCH;

export default {
  input: 'src/main.js',
  output: {
    file: 'public/bundle.js',
    format: 'iife',
    sourcemap: true,
  },
  plugins: [
    resolve(),
    commonjs(),
    production && terser(),
  ],
};

```

webpack과의 차이를 비교해보면 더 정확하게 rollup의 특성을 이해할 수 있습니다.

### vs webpack

한마디로 정리하면,
webpack은 내부적으로 Commonjs를 사용하고 rollup은 typescript(ES6)를 사용합니다.
이로 인해서 아래 특성들이 있다고 볼 수 있습니다.

**rollup은 ES6 모듈 형태로 빌드할 수 있습니다.**
webpack은 CommonJS 형태로만 번들링이 가능했습니다. 물론 webpack v5부턴 ES6로 번들할 수 있습니다.
라이브러리는 ES6 번들에 생성에 대한 수요가 강합니다.
ES6 환경에서는 ES6 번들이 사용되고 CommonJS 환경에서는 CommonJS 번들이 사용되도록 해줘야 라이브러리 사용자는 더욱 최적화된 애플리케이션을 빌드해줄 수 있습니다.

**rollup은 좀 더 빠릅니다.**
webpack은 모듈들을 함수로 감싸서 평가하는 방식을 사용하지만 rollup은 모듈들을 호이스팅하여 한번에 평가하기에 성능상 이점이 있습니다.

**rollup은 더 가벼운 번들을 생성합니다**
`tree shaking`은 기본적으로 ES6 코드에서 제대로 동작합니다.
단순히 레퍼런스되지 않는 코드를 제거하는 것이 아닌 사용되는 모듈만 AST 트리에 포함시키는 방식으로 불필요한 코드를 제거하기 때문입니다.
rollup은 공식 플로그인을 통해서 CommonJS 코드를 ES6 코드로 변환할 수도 있습니다.

**rollup은 CommonJS 코드를 ES6코드에서 사용할 수 있습니다.**
기본적으로 ES6에서는 CommonJS식의 require를 지원하지 않습니다.
webpack에서도 공식적으론 ES6 혹은 CommonJS 한 형태의 코드 베이스를 사용하기를 권장합니다.

---

## ESBuild

<img src="https://esbuild.github.io/favicon.svg" width="128px" />

앞서 봐왔던 번들러는 모두 내부적으로 JavaScript을 기반으로 번들링을 합니다.
따라서 JavaScript 언어가 가질 수 밖에 없는 성능상의 한계가 있습니다.
그 한계를 뿌수고자하는 움직임이 있었으니 그 라이브러리가 바로 ESBuild 입니다.

[**`ESBuild`**](https://github.com/evanw/esbuild)는 내부적으로 [`Go`](https://go.dev/)로 작성되었고 JS 기반의 번들러보다 10배에서 100배까지 빠른 엄청난 퍼포먼스를 보여줬습니다. 빠른 이유에 대해서는 아래와 같이 소개하고 있습니다.

- 네이티브 코드 방식 사용
- 병렬처리 최적화
- 메모리 사용 최적화
- 자체 JavaScript 파서 사용
- https://esbuild.github.io/faq/

문제는 2020년도에 파격적으로 등장 했지만 아직까지도 메이저 버전이 릴리즈 되지 못했습니다. (현재 기준 v0.17.3)
사실 번들러로서 필수적인 기능들이 갖춰졌습니다.

- JavaScript, CSS, TypeScript, and JSX built-in
- Bundles ESM and CommonJS modules
- Tree shaking, minification, and source maps
- Local server, watch mode, and plugins

하지만 설정이 webpack, rollup처럼 유연하지 못하고 아직 안전성 관련 이슈가 있습니다.

- code splitting 및 CSS와 관련된 처리가 아직 미비합니다.
- esbuild는 es5 이하의 문법을 아직 100% 지원하지 않습니다.

---

## Vite

<img src="https://vitejs-kr.github.io/logo-with-shadow.png" width="128px" />

ESBuild의 단점을 보완시킨 라이브러리 [**`Vite`**](https://vitejs-kr.github.io/)(비트) 입니다.
`Vue.js`의 창시자인 [Evan You](https://evanyou.me/)가 만든 `frontend build tool` 입니다.

2021년에 등장했지만 벌써 v4가 나온 만큼 굉장히 활발하게 업데이트 되고 있는 라이브러리입니다.
[`v1 rc`](https://www.npmjs.com/package/vite/v/1.0.0-rc.13?activeTab=versions)에서 바로 v2 alpha로 넘어간 것 같습니다.
[`v2.0.0`](https://github.com/vitejs/vite/blob/v2.0.5/packages/vite/CHANGELOG.md#200-2021-02-16) 2021-02-16
[`v3.0.0`](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#300-2022-07-13) 2022-07-13
[`v4.0.0`](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#400-2022-12-09) 2022-12-09

vite를 2가지 키포인트로 설명할 수 있을 것 같습니다.

- `native ES modules` 기반의 강력한 개발서버
- `esbuild`로 파일들을 통합하고 `rollup`을 통해 번들링

전반적으로 `esbuild`로 성능을 극적을 끌어오고 `rollup`을 통해서 번들링의 유연성을 챙겼다고 볼 수 있습니다.
[공식문서 (Vite를 사용해야 하는 이유)](https://vitejs-kr.github.io/guide/why.html)에서 자신에 대해 너무 잘 설명하고 있어 꼭 한번 정독해보시길 바랍니다!

특성을 아래와 같이 요약할 수 있을 것 같습니다.

- 개발 서버 구동 시간이 거의 `0`에 가까움,
- 모든 CommonJS 및 UMD 파일을 ESM으로 불러올 수 있도록 변환함
- 별도의 설정이 없이 다양한 리소스 `import` 가능
- [CSS 빌드 최적화](https://vitejs-kr.github.io/guide/features.html#build-optimizations)
  - `Direct Import` 구문에 대해 `Preload` 하도록 함으로써, 네트워크 비용 줄임

### 주의 해야할 점

**vites는 기본적으로 ES6을 타겟으로 번들을 생성합니다.**
따라서 ES5이하로 타겟을 잡으려면 별도로 polyfill를 다뤄야 합니다.
그래도 공식적으로 [`@vitejs/plugin-legacy`](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) 플러그인을 제공 해줍니다.

**vite는 기본적으로 `<root>/index.html` 파일이 빌드를 위한 진입점입니다.**
순수한 JS 번들을 생성하기 위해서는 [`라이브러리 모드`](https://vitejs-kr.github.io/guide/build.html#library-mode)를 설정해야 합니다.
( 3.2.0 에서야 멀티 entry를 지원하게 되어 고생한 기억이 있습니다... )

---

## 참고한 문헌

http://2016.stateofjs.com/2016/buildtools/
https://2017.stateofjs.com/2017/build-tools/results
https://2018.stateofjs.com/other-tools/
https://2019.stateofjs.com/other-tools/#build_tools
https://2020.stateofjs.com/en-US/technologies/build-tools/
https://2021.stateofjs.com/en-US/libraries/build-tools/
https://2022.stateofjs.com/en-US/libraries/build-tools/

https://github.com/webpack/webpack/releases
https://github.com/rollup/rollup/blob/master/CHANGELOG.md
https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md
https://yoon-dumbo.tistory.com/entry/롤업과-웹팩의-차이점-rollup-vs-webpack
https://so-so.dev/web/tree-shaking-module-system/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="bundler"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[안드로이드에서 브라우저 디버깅하는 방법 (feat. 크롬, 삼성 브라우저)]]></title>
        <id>/blog/2023/debug-in-android-web</id>
        <link href="https://bepyan.github.io/blog/2023/debug-in-android-web"/>
        <updated>2023-01-26T13:12:37.000Z</updated>
        <content type="html"><![CDATA[
안드로이드에서 브라우저 디버깅을 해야할 때가 있다.
MAC 환경에서 어떻게 디버깅할 수 있는지 한번 정리해보자.

https://developer.android.com/studio/command-line/adb?hl=ko#wireless-android11-command-line

---

## 환경 세팅

```shell
brew install --cask android-platform-tools
```

---

### 안드로이드 개발자모드 설정

갤럭시 기준으론 아래와 같다.
`설정` > `휴대전화 정보` > `소프트웨어 정보` > `빌드 번호` 5번 클릭

https://developer.android.com/studio/debug/dev-options?hl=ko#enable

---

### USB로 장치 연결

`설정` > `USB 디버깅` 체크 > 장치와 USB 연결

아래 명령어로 제대로 연결이 되었는지 확인할 수 있다.

```shell
adb devices
```

---

### 무선으로 장치 연결

`설정` > `무성 디버깅` > `페어링 코드로 기기 페어링`

```
adb pair ipaddr:port
```

혹은 `IP 주소 및 포트`를 활용하여 직접 연결할 수 있다.

```shell
adb connect ipaddr:port
```

![230126-131551](/images/posts/debug-in-android-web/230126-131551.png)

---

## 디버깅하는 방법

PC에서 [chrome://inspect/#devices](chrome://inspect/#devices)로 들어가서 `inspect`을 실행하면 된다.
`Remote Targe`에 장치가 안 뜬다면 위 방법들 중 다른 방법을 시도해보길 바란다.

![230126-132252](/images/posts/debug-in-android-web/230126-132252.png)

삼성 브라우저, 크롬 브라우저 모두 디버깅이 가능하다.
시뮬레이터에서의 동작이 실제 디바이스 화면에서도 반영이 된다!
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="android"/>
        <category label="debug"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[내가 기본적으로 사용하는 ESLint 설정]]></title>
        <id>/blog/dev-setting/eslint</id>
        <link href="https://bepyan.github.io/blog/dev-setting/eslint"/>
        <updated>2023-02-18T14:07:14.000Z</updated>
        <content type="html"><![CDATA[
> 사심 ❤️을 넘치게 담아서 기록한 eslint 설정입니다.

사용 환경

- typescript
- tailwindcss

---

```shell
yarn add -D eslint @typescript-eslint/parser
yarn add -D eslint-plugin-unused-imports eslint-plugin-import
yarn add -D eslint-plugin-tailwindcss
touch .eslintrc.cjs
```

```js:.eslintrc.cjs
module.exports = {
  root: true,
  extends: ['plugin:tailwindcss/recommended'],
  plugins: ['unused-imports', 'import'],
  parser: '@typescript-eslint/parser',
  settings: {
    tailwindcss: {
      callees: ['cn'],
    },
  },
  rules: {
    // https://github.com/sweepline/eslint-plugin-unused-imports
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'off',
    'unused-imports/no-unused-imports': 'error',
    'unused-imports/no-unused-vars': [
      'warn',
      {
        vars: 'all',
        varsIgnorePattern: '^_',
        args: 'after-used',
        argsIgnorePattern: '^_',
      },
    ],
    // https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md
    'import/order': [
      'error',
      {
        groups: ['builtin', 'external', 'internal', ['parent', 'sibling', 'index']],
        alphabetize: {
          order: 'asc',
          caseInsensitive: true,
        },
        'newlines-between': 'always',
      },
    ],
    'import/first': 'error',
    'import/newline-after-import': 'error',
    'import/prefer-default-export': 'off',
    'import/no-useless-path-segments': ['error', { noUselessIndex: true }],
    // https://nextjs.org/docs/basic-features/eslint
    'react-hooks/exhaustive-deps': 'off',
  },
};
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="eslint"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프론트엔드 개발환경 세팅]]></title>
        <id>/blog/dev-setting</id>
        <link href="https://bepyan.github.io/blog/dev-setting"/>
        <updated>2023-01-28T12:28:43.000Z</updated>
        <summary type="html"><![CDATA[안 해본 사람은 있어도 한 번만 하는 사람은 없다.]]></summary>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="development settings"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[M1 터미널 아키텍처 설정 (arm64, x86_64)]]></title>
        <id>/blog/dev-setting/m1-muti-terminal-architecture</id>
        <link href="https://bepyan.github.io/blog/dev-setting/m1-muti-terminal-architecture"/>
        <updated>2022-04-27T16:52:28.000Z</updated>
        <content type="html"><![CDATA[
모듈을 다운 받다가 아래 에러를 마주쳤다..

```
Error: Your platform and architecture (Darwin-arm64) is unsupported.
```

Intel 프로세서 아키텍처는 x86_64 이고 Apple Silicon M1은 arm64 아키텍처를 사용한다.
해당 모듈은 arm64 아키텍처를 지원하지 않아 발생한 에러다.
~~M1,,, 또 너냐,,,~~

---

## 터미널 아키텍처 바꾸기

```shell
arch -arch x86_64 /bin/zsh
```

터미널에서 아키텍처를 바꿀 수 있다.

```shell
arch -arch arm64e /bin/zsh
```

계속 x86_64 아키텍처를 사용할 수도 없고 해당 커멘드를 매번 입력하기 버겁다...
~~아무래도 x86_64환경이 더 느리다.~~

---

## 커멘드 alias 설정

```jsx
vi ~/.zshrc
```

빠르게 터미널 환경을 변경할 수 있도록 설정

```jsx
alias za="arch -arch arm64e /bin/zsh"
alias zx="arch -arch x86_64 /bin/zsh"
```

```jsx
source ~/.zshrc
```

이제 터미널에 `za` `zx`만 입력해도 아키텍처를 바꿀 수 있다.
하지만 뭔가 불편하다.. 내 터미널은 지금 어떤 아키텍처를 사용하고 있지..?

---

## 터미널에서 현 아키텍처 표시하기

> Powerlevel10k에서 커스텀 프롬프트를 만들면 된다.

```jsx
open ~/.p10k.zsh
```

prompt_example 찾아 밑에 아래 코드를 복사 한다.

```jsx
function prompt_arch() {
  if [[ $(arch) == "i386" ]]; then
   p10k segment -t '🐢'
  fi
}

function instant_prompt_arch() {
  prompt_arch
}
```

`POWERLEVEL9K_LEFT_PROMPT_ELEMENTS`를 찾아 `arch`를 추가한다.

```jsx
typeset -g POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(
  # os_icon               # os identifier
  dir                     # current directory
  vcs                     # git status
  prompt_char             # prompt symbol
  **arch**
)
```

![](https://velog.velcdn.com/images/bepyan/post/e059e686-2f8b-45ae-a78f-12970de067d3/image.png)

뚜벅 뚜벅 귀엽다 🥰

---

**참고 자료**

- [https://xo.dev/m1-terminal-environment-setup/](https://xo.dev/m1-terminal-environment-setup/)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="infra"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[preact을 시작해보자. vite와 함께.]]></title>
        <id>/blog/dev-setting/preact</id>
        <link href="https://bepyan.github.io/blog/dev-setting/preact"/>
        <updated>2023-03-13T17:52:39.000Z</updated>
        <content type="html"><![CDATA[
## [preact](https://preactjs.com/)란?

**가볍고 빠르다.**
그 핵심은 `Preact does not implement a synthetic event system`이라고 한다.
가능한 `Virtual DOM` 추상화 수준을 낮춰서 더욱 직접적으로 `DOM`을 다루게 된다.
따라서 기존 `react`와 문법이 조금 다른 부분이 있다.

물론 `preact/compat`을 활용하면 문법적으로 `react`와 `100%` 호환이 된다.

---

## 기본 세팅

`vite`을 활용해서 쉽게 프로젝트 세팅을 할 수 있다.

```shell
yarn create vite project-name --template preact-ts
```

기본적으로 `react`와 똑같다.

```tsx:index.tsx
import './index.css';
import { render } from 'preact';

import App from './App';

render(<App />, document.getElementById('app') as HTMLElement);
```

이어서 [tailwindcss](./tailwindcss) [eslint](./eslint) 등 설정을 이어서 하면 된다.

---

## 라우팅

기본적으로 [**`preact-router`**](https://github.com/preactjs/preact-router)라는 선택지가 있지만, 이는 단순한 라우팅만 지원된다.
복잡하게 컴포넌트를 조합 해야할 경우 [`react-router`](https://github.com/remix-run/react-router)을 사용하도록 권장되어 있다.

```shell
yarn add react-router-dom
```

```ts:vite.config.ts
import preact from '@preact/preset-vite';
import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
  resolve: {
    alias: {
      react: 'preact/compat',
    },
  },
});
```

```tsx:App.tsx
import { BrowserRouter, Route, Routes, useParams } from 'react-router-dom';

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Slug />} />
        <Route path=":slug" element={<Slug />} />
      </Routes>
    </BrowserRouter>
  );
}

function Slug() {
  const { slug } = useParams();
  return <div>{slug}</div>;
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="preact"/>
        <category label="vite"/>
        <category label="typescript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[tailwindcss 완벽 세팅 (feat Next.js)]]></title>
        <id>/blog/dev-setting/tailwindcss</id>
        <link href="https://bepyan.github.io/blog/dev-setting/tailwindcss"/>
        <updated>2023-01-31T20:15:20.000Z</updated>
        <content type="html"><![CDATA[
## 기본 설정

https://tailwindcss.com/docs/guides/nextjs

```shell
yarn add -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

```js:tailwind.config.js {4}
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

```css:global.css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

## 기본 도구

**클래스명 정렬**

[`prettier-plugin-tailwindcss`](https://github.com/tailwindlabs/prettier-plugin-tailwindcss)
tailwindlabs에서 공식으로 지원하는 플러그인.

[`eslint-plugin-tailwindcss`](https://github.com/francoismassart/eslint-plugin-tailwindcss) ✨
prettier 의존성을 벗어남은 물론 몇몇 추가 기능을 제공하는 플러그인.

[`headwind`](https://marketplace.visualstudio.com/items?itemName=heybourn.headwind)
vscode 플러그인.

---

**클래스 합병**

tailwind는 뒤에 클래스명을 선언한다고 해서 덮여 씌워지지 않는다.

```shell
yarn add -D clsx tailwind-merge
```

```ts:libs/utils
import type { ClassValue } from 'clsx'
import { clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

---

## fonts

https://tailwindcss.com/docs/font-family

```diff-js:tailwind.config.js
+ const { fontFamily } = require('tailwindcss/defaultTheme')

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{ts,tsx}'],
  theme: {
    extend: {
+      fontFamily: {
+        sans: ['var(--font-spoqa)', ...fontFamily.sans],
+      },
    },
  },
  plugins: [],
}
```

```tsx:_app.tsx {6}
import type { AppProps } from 'next/app';

export default function App({ Component, pageProps }: AppProps) {
  return (
    <>
      <div className='font-sans'>
        <Component {...pageProps} />
      </div>
    </>
  )
}
```

`@next/fonts`와 함께 사용하는 방법은 [**`(Next.js) @next/fonts`**](/snippets/next.js/next-fonts) 참고

---

## 추가 설정

**vscode `global.css` 경고 제거**

![230310-013507](/images/posts/tailwindcss/230310-013507.png)

보기 싫은 `Unknown at rule @tailwindcss(unknownAtRules)` 오류를 제거하자.

```json:.vscode/settings.json
{
    "css.lint.unknownAtRules": "ignore",
}
```

---

**모바일에선 hover 스타일이 동작하지 않도록**

```diff-js:tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
+  future: {
+    hoverOnlyWhenSupported: true,
+  },
  // ...
}
```

https://github.com/tailwindlabs/tailwindcss/pull/8394
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="tailwindcss"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[레포 단위로 VSCode 설정 적용하기]]></title>
        <id>/blog/dev-setting/vscode-eslint-prettier</id>
        <link href="https://bepyan.github.io/blog/dev-setting/vscode-eslint-prettier"/>
        <updated>2023-01-26T17:23:10.000Z</updated>
        <content type="html"><![CDATA[
repository 단위로 IDE 설정을 강제하고 싶을 때가 있다.
사람마다 제각각 선호하는 설정이 있고 프로젝트 환경에 따라 설정이 달라져 프로젝트마다 이를 다르게 설정해야 한다.

`.vscode` 디랙토리에 설정을 명시하여 이를 해결할 수 있다!

---

### 옵션 설정

```json:.vscode/settings.json
{
  "editor.rulers": [120], // IDE에 줄이 보이게 함
  "editor.formatOnSave": true, // 파일 저장시 포멧팅 실행
  "editor.defaultFormatter": "esbenp.prettier-vscode", // 포멧팅 도구를 prettier로 사용
  "editor.codeActionsOnSave": { "source.fixAll.eslint": true }, // 파일 저장시 eslint auto fix 실행
  "eslint.validate": ["javascript", "javascriptreact", "typescript", "typescriptreact", "svelte"] // 사용 언어에 따라 설정
}
```

속성을 잘 모르겠다면 설정에서 톱니바퀴의 `Copy Setting as JSON`을 클릭하면 된다.

![230126-175049](/images/posts/vscode-eslint-prettier/230126-175049.png)

---

### 플러그인 설정

```json:.vscode/extensions.json
{
  "recommendations": ["svelte.svelte-vscode", "dbaeumer.vscode-eslint", "esbenp.prettier-vscode"]
}
```

플러그인이 설치가 안되어 있다면 IDE에서 이를 경고해준다.

![230126-173852](/images/posts/vscode-eslint-prettier/230126-173852.png)

---

### code snippets 설정

```json:.vscode/.code-snippets
{

  "Current DateTime": {
    "prefix": ["current_date_time", "cdt"],
    "description": "Output current DateTime YYYY-MM-DD HH:mm:ss",
    "body": "$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND"
  },
}
```

[**VSCode Variables**](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables)을 활용하여 프로젝트에 맞는 다양한 `code snippets`을 작성할 수 있다.

`.code-snippets` 앞에 적용될 파일 타입을 명시할 수 있다. `ts.code-snippets`

---

### 단축키 설정

```json:.vscode/keybindings.json
[
    {
        "key": "shift+cmd+v",
        "command": "-markdown.extension.closePreview",
        "when": "markdownPreviewFocus"
    },
    {
        "key": "shift+cmd+v",
        "command": "extension.pasteImage",
        "when": "editorTextFocus"
    }
]
```

VSCode 동작부터 Extension 실행까지 [**다양한 동작**](https://code.visualstudio.com/docs/getstarted/keybindings)을 지원하니 필요에 따라 적용하면 좋을 것 같다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="vscode"/>
        <category label="eslint"/>
        <category label="prettier"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Drag 이벤트 뽀개기]]></title>
        <id>/blog/dnd-master/1-drag-event</id>
        <link href="https://bepyan.github.io/blog/dnd-master/1-drag-event"/>
        <updated>2022-10-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 element를 커서로 움직이게 하자!!!]]></summary>
        <content type="html"><![CDATA[
drag관련해서 좋은 라이브러리들이 있지만 순수하게 구현해보고 싶다.
아래의 스펙으로 구현을 시작해보자 🏄🏻‍♂️

- `NextJS` `React`
- `Typescript`
- `tailwindcss`

---

## TL;DR

> `mousedown`에서 `mousemove` `mouseup` 이벤트를 등록한다.
> `mousemove`에서 `event.pageX`와 `mousedown`의 `event.pageX` 차이를 활용해 엘리먼트를 이동시킨다.
> `mouseup`에서 `mousemove` 이벤트를 해제시킨다.

---

## 사전 지식 — DOM 이해

마우스의 움직임 바탕으로 element의 위치를 이동시켜야 한다.
따라서 마우스 관련 이벤트를 잘 이해해야 한다.

`mousedown` — 마우스 클릭 이벤트
`mousemove` — 마우스 이동 이벤트
`mouseup` — 마우스 클릭 해제 이벤트
[https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)

위 DOM 이벤트를 활용하여 마우스의 정보를 받아 올 수 있을 것 같다.
그렇다면 **MouseEvent**는 어떤 속성을 가지고 있을까?
비슷 비슷하게 보이는 친구들이 많은데 차이를 비교해보자.

| Properties     |                                                                                                    |
| -------------- | -------------------------------------------------------------------------------------------------- |
| **x, clientX** | in local (DOM content) coordinates.<br />event가 발생되는 element 기준으로 위치를 산정한다.        |
| **pageX**      | relative to the whole document.<br />page document을 기준으로 위치를 산정한다.                     |
| **screenX**    | in global (screen) coordinates.<br />더 나아가 듀얼 모니터의 주 모니터를 기준으로 위치를 산정한다. |

무엇을 사용하던 크게 문제될 것이 없어보여 screenX을 사용해보자.

---

## 기본 원리 — Drag 이벤트 등록

그렇다면 DOM 이벤트를 활용하여 마우스의 움직임을 추적해보자!
주요 로직은 아래와 같다.

1. 클릭시(`onMouseDown`) document에 `mousemove` `mouseup` 이벤트를 등록한다.
2. 클릭된 상태에서 마우스를 움직일시 `mousemove`에 등록 된 함수가 계속 호출된다.
3. `mouseup` 이벤트에서 `mousemove` 이벤트를 제거한다.

```jsx
<div
  onMouseDown={() => {
    // 2️⃣
    const mouseMoveHandler = (e: MouseEvent) => {
      console.log(`mouse move x:${e.screenX} y:${e.screenY}`);
    };

    // 3️⃣
    const mouseUpHandler = (e: MouseEvent) => {
      console.warn(`>>>> mouse up x:${e.screenX} y:${e.screenY}`);
      document.removeEventListener('mousemove', mouseMoveHandler);
    };

    // 1️⃣
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler, { once: true });
    // mouseup 이벤트는 한번만 실행되면 되기에 { once: true } 옵션을 추가해준다.
  }}
/>
```

![](https://velog.velcdn.com/images/bepyan/post/40730059-40c1-4a9c-8fc9-c9abfd59c82d/image.gif)

---

## 기본 응용 — Drag 위치 이동

마우스의 움직임을 추적하였으니,
이제 이를 활용하여 element를 drag해서 위치를 움직여보자!

1. element의 `position` 상태를 정의한다.
2. 클릭(`mousedown`) 이벤트 발생시의 커서 위치를 기준으로,
   이동(`mousemove`) 이벤트에서 **상대적으로 이동한 거리(deltaX, deltaY)**를 계산한다.
3. `position` 상태를 변경하여 element를 움직이게 한다.

```tsx
// 1️⃣
const [{ x, y }, setPosition] = useState({
  x: 0,
  y: 0,
});

return (
  <div>
    <div
      style={{ transform: `translateX(${x}px) translateY(${y}px)` }}
      onMouseDown={(clickEvent: React.MouseEvent<Element, MouseEvent>) => {
        const mouseMoveHandler = (moveEvent: MouseEvent) => {
          // 2️⃣
          const deltaX = moveEvent.screenX - clickEvent.screenX;
          const deltaY = moveEvent.screenY - clickEvent.screenY;

          // 3️⃣
          setPosition({
            x: x + deltaX,
            y: y + deltaY,
          });
        };

        const mouseUpHandler = () => {
          document.removeEventListener('mousemove', mouseMoveHandler);
        };

        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler, { once: true });
      }}
    />
  </div>
);
```

![](https://velog.velcdn.com/images/bepyan/post/5c38729e-f30e-406f-92e6-de16918f87c0/image.gif)

(TIP)
에니메니션 인터랙션을 고려할 경우,
실제 drag할 element(`Box`)를 div로 씌워서 이벤트, style를 등록 것이 좋다.

`transition: transform` 경우 원치않게 에니메이션 효과가 적용될 수 있다.

```jsx
<div
	style={...}
	onMouseDown={...}
>
	<Box />
</div>
```

---

## 심화 응용 — **Drag Boundary**

drag할 때 특정 영역(boundary)을 벗어나지 않길 원할 수 있다.
위 2번 과정, `mousemove`이벤트에서 **특정 범위를 벗어나지 않도록 제한**하면 된다.

![](https://velog.velcdn.com/images/bepyan/post/ac92e9bf-fce7-48b5-8a83-acc04b183878/image.png)

#### 1. boundary, box element의 크기를 얻는다.

[getBoundingClientRect](<(https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect)>)을 활용하여 element의 정보를 얻을 수 있다.

```tsx
const boundary = boundaryRef.current.getBoundingClientRect();
const box = boxRef.current.getBoundingClientRect();
// x, y, width, height
```

#### 2. drag할 수 있는 경계(minx, maxx, miny, maxy)를 계산한다.

element를 놓는 기준에 따라 boundary가 달라지는데 상황에 맞게 잘 계산하면 된다.

<br />
<br />

drag element이 **중앙 정렬**되었다고 생각해보자.
기본 box의 위치는 `x:0, y:0`(중앙) 이다.

따라서 element의 제한 범위를 계산해보면

![](https://velog.velcdn.com/images/bepyan/post/26ef16ac-fa25-4c96-b2f7-da4bf5759f0c/image.png)![](https://velog.velcdn.com/images/bepyan/post/332fa024-b6ec-46fe-9b0e-40527d11e101/image.png)

좌측 끝 = `-boundary.width/2` + `box.width/2` + `margin`
우측 끝 = `boundary.width/2` - `box.width/2` - `margin`

먼저, 범위를 얻는 유틸함수를 만들면 코드가 더 깔끔해질 것 같다.

```tsx
const inrange = (v: number, min: number, max: number) => {
  if (v < min) return min;
  if (v > max) return max;
  return v;
};
```

코드에 적용하면 아래와 같다.

```tsx
const BOUNDARY_MARGIN = 12;
const deltaX = moveEvent.screenX - clickEvent.screenX;
const deltaY = moveEvent.screenY - clickEvent.screenY;

setPosition({
  x: inrange(
    x + deltaX,
    Math.floor(-boundary.width / 2 + box.width / 2 + BOUNDARY_MARGIN),
    Math.floor(boundary.width / 2 - box.width / 2 - BOUNDARY_MARGIN),
  ),
  y: inrange(
    y + deltaY,
    Math.floor(-boundary.height / 2 + box.height / 2 + BOUNDARY_MARGIN),
    Math.floor(boundary.height / 2 - box.height / 2 - BOUNDARY_MARGIN),
  ),
});
```

<br />
<br />

이제 drag element가 **absolute**하다고 생각해보자.
기본 box의 위치는 boundary의 좌상단(`x:0, y:0`) 이다.

따라서 element의 제한 범위를 계산해보면
![](https://velog.velcdn.com/images/bepyan/post/1d9d532f-5d0d-45a4-93fc-b2eb12b6ada7/image.png)![](https://velog.velcdn.com/images/bepyan/post/173cb287-673d-478f-a24a-1a3eadf8b8ee/image.png)

좌측 끝 = `margin`
우측 끝 = `boundary.width` - `box.width` - `margin`

코드에 적용하면 아래와 같다.
~~코드가 더 깔끔한 느낌은 기분탓인가..~~

```tsx
const BOUNDARY_MARGIN = 12;
const deltaX = moveEvent.screenX - clickEvent.screenX;
const deltaY = moveEvent.screenY - clickEvent.screenY;

setPosition({
  x: inrange(
    x + deltaX,
    BOUNDARY_MARGIN,
    boundary.width - box.width - BOUNDARY_MARGIN
  ),
  y: inrange(
    y + deltaY,
    BOUNDARY_MARGIN
    boundary.height - box.height - BOUNDARY_MARGIN,
  ),
});
```

![](https://velog.velcdn.com/images/bepyan/post/65b91811-a409-4877-90aa-f589b5768ee8/image.gif)

뭔가 그럴듯한 결과물이 나왔다 ✨✨

---

## 응용 마무리 — 유틸 함수로 만들기

관련된 기능을 유틸 함수로 추출하면 쉽게 element를 적용시킬 수 있을 거 같다.

```tsx
export default function registMouseDownDrag(
  onDragChange: (deltaX: number, deltaY: number) => void,
  stopPropagation?: boolean,
) {
  return {
    onMouseDown: (clickEvent: React.MouseEvent<Element, MouseEvent>) => {
      if (stopPropagation) clickEvent.stopPropagation();

      const mouseMoveHandler = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.screenX - clickEvent.screenX;
        const deltaY = moveEvent.screenY - clickEvent.screenY;
        onDragChange(deltaX, deltaY);
      };

      const mouseUpHandler = () => {
        document.removeEventListener('mousemove', mouseMoveHandler);
      };

      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler, { once: true });
    },
  };
}
```

`stopPropagation` 경우 click이벤트가 전파되지 않기 위함이다.
부모 div의 click이벤트가 실행되면 곤란한 경우가 있다...

`onDragChange`를 콜벡으로 받아서 쉽게 커스터마이징을 할 수 있을 것 같다.
코드에 응용해보자.

```tsx
const [{ x, y }, setPosition] = useState({
  x: 0,
  y: 0,
});
```

```tsx
<div
  style={{ left: x, top: y }}
  {...registMouseDownDrag((deltaX, deltaY) => {
    setConfig({
      x: x + deltaX,
      y: y + deltaY,
    });
  })}
  >
```

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/

style 정보, 전체 코드는 아래 깃허브에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Drag Touch 뽀개기]]></title>
        <id>/blog/dnd-master/2-drag-touch-event</id>
        <link href="https://bepyan.github.io/blog/dnd-master/2-drag-touch-event"/>
        <updated>2022-10-02T15:00:30.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 element를 터치로 움직이게 하자!!!]]></summary>
        <content type="html"><![CDATA[
[이전 포스트](./1-drag-event)에서 만든 유틸함수에 큰 문제점이 있다.
바로 **모바일 기기**에서 동작하지 않다는 것이다.

<p align="center">
  <img
    src="https://media.tenor.com/e5eV8VVfUXQAAAAM/throw-phone-sue%C3%B1itosgifs.gif"
    width="300px"
  />
</p>

~~힘들게 개발한 것이 모바일에서 동작하지 않다니 ㅠ퓨ㅜㅠ~~

---

## TL;DR

> 모바일 기기에서는 `MouseEvent` 대신 `TouchEvent`를 사용한다.
> `window.matchMedia('(hover: none) and (pointer: coarse)').matches`를 통해 모바일 기기인지 여부를 파악한다.
> 기기에 따라 `mousedown` 혹은 `touchdown` 이벤트를 등록해준다.

---

## 사전 지식 — Touch Event

모바일 기기에서는 MouseEvent 대신 [**TouchEvent**](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)가 발생된다.
따라서 MouseEvent로 등록되었던 이벤트가 실행되지 않았던 것이다.
다행히 TouchEvent에서도 우리가 원하는 동작을 바로 찾을 수 있다.

`mousedown` — `touchdown`
`mousemove` — `touchmove`
`mouseup` — `touchend`

TouchEvent의 속성 중
`touches` — 모든 접촉점의 터치 리스트
`targetTouches` — 현재 이벤트 타겟에서 시작된 터치 리스트
`changedTouches` — 이전 이벤트에 할당된 모든 접촉점의 터치 리스트

터치 스크린 특성상 여러 터치 이벤트가 동시 실행될 수 있어서 터치 리스트를 반환하는 것 같다.
일반적으로 첫 Touch 이벤트를 사용하면 될 것이다.

![](https://velog.velcdn.com/images/bepyan/post/8bdbb9ea-c3c1-4182-8e51-979db4cfe9d9/image.png)

정확히 차이에 대해 와닿진 않지만
움직일 때는 `touches[0]`, 손을 땠을 때는 `changedTouches[0]`를 사용하도록 하자.

---

## 기본 원리 — touch 이벤트 등록

이전 mouse 등록 절차와 같으니 자세한 설명을 생략하겠다.

```tsx
<Boundary
  onTouchStart={(touchEvent) => {
    const touchMoveHandler = (moveEvent: TouchEvent) => {
      setPosition({
        x: moveEvent.touches[0].pageX - touchEvent.touches[0].pageX,
        y: moveEvent.touches[0].pageY - touchEvent.touches[0].pageY,
      });
    };
    const touchEndHandler = () => {
      document.removeEventListener('touchmove', touchMoveHandler);
    };

    document.addEventListener('touchmove', touchMoveHandler);
    document.addEventListener('touchend', touchEndHandler, { once: true });
  }}
/>
```

`onMouseStart`, `onTouchStart` 둘다 등록하긴 너무나 귀찮다...
MouseEvent, TouchEvent을 동시 등록할 수 있는 유틸을 만들어 보자.
그럼 브라우저 환경에 따라 MouseEvent를 등록할지 TouchEvent를 등록할지 판별할 수 있어야 한다.

---

## 심화 적용 — pc와 mobile를 구분

일반적으로 디바이스 크기로 pc와 mobile을 구분하지만
pc에서 작은 화면으로 볼 수도 있고 13인치 iPad를 사용할 수도 있다.

이를 해결해주는 아주 잘 정리된 [블로그](https://paperblock.tistory.com/164)가 있다.
hover, pointer 쿼리를 이용하면 모바일 기기를 구분할 수 있다.

![](https://velog.velcdn.com/images/bepyan/post/09db8960-6c92-41df-bd83-397df86f5686/image.png)

출처 https://paperblock.tistory.com/164

<br />

그렇다면 이 CSS Media Queries를 어떻게 사용할 수 있을까?

바로 window api, [**matchMedia**](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)를 사용하는 것이다.
아래 코드로 **“현재 화면이 미디어쿼리의 범위에 들어가는지”** 확인할 수 있다.

```tsx
window.matchMedia('(max-width: 600px)').matches; // boolean
```

여러 쿼리를 같이 확인하고 싶으면 `and` 를 붙이면 된다.

```tsx
window.matchMedia('(hover: none) and (pointer: coarse)').matches;
```

NextJS에서는 기본적으로 SSR하기 때문에 window가 `undefined`할 수 있다.
따라서 아래와 같이 코드를 작성해주면 **사용자의 화면이 터치 스크린인지** 확인할 수 있다.

```jsx
export const isTouchScreen =
  typeof window !== 'undefined' && window.matchMedia('(hover: none) and (pointer: coarse)').matches;
```

---

## 심화 응용 — 최종 코드

`utils/registDragEvent.ts`
아직 부족한 부분이 많지만 상황에 맞춰 잘 수정하면 될 것이다.

```tsx
const isTouchScreen =
  typeof window !== 'undefined' && window.matchMedia('(hover: none) and (pointer: coarse)').matches;

export default function registDragEvent({
  onDragChange,
  onDragEnd,
  stopPropagation,
}: {
  onDragChange?: (deltaX: number, deltaY: number) => void;
  onDragEnd?: (deltaX: number, deltaY: number) => void;
  stopPropagation?: boolean;
}) {
  if (isTouchScreen) {
    return {
      onTouchStart: (touchEvent: React.TouchEvent<HTMLDivElement>) => {
        if (stopPropagation) touchEvent.stopPropagation();

        const touchMoveHandler = (moveEvent: TouchEvent) => {
          if (moveEvent.cancelable) moveEvent.preventDefault();

          const deltaX = moveEvent.touches[0].pageX - touchEvent.touches[0].pageX;
          const deltaY = moveEvent.touches[0].pageY - touchEvent.touches[0].pageY;
          onDragChange?.(deltaX, deltaY);
        };

        const touchEndHandler = (moveEvent: TouchEvent) => {
          const deltaX = moveEvent.changedTouches[0].pageX - touchEvent.changedTouches[0].pageX;
          const deltaY = moveEvent.changedTouches[0].pageY - touchEvent.changedTouches[0].pageY;
          onDragEnd?.(deltaX, deltaY);
          document.removeEventListener('touchmove', touchMoveHandler);
        };

        document.addEventListener('touchmove', touchMoveHandler, { passive: false });
        document.addEventListener('touchend', touchEndHandler, { once: true });
      },
    };
  }

  return {
    onMouseDown: (clickEvent: React.MouseEvent<Element, MouseEvent>) => {
      if (stopPropagation) clickEvent.stopPropagation();

      const mouseMoveHandler = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.pageX - clickEvent.pageX;
        const deltaY = moveEvent.pageY - clickEvent.pageY;
        onDragChange?.(deltaX, deltaY);
      };

      const mouseUpHandler = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.pageX - clickEvent.pageX;
        const deltaY = moveEvent.pageY - clickEvent.pageY;
        onDragEnd?.(deltaX, deltaY);
        document.removeEventListener('mousemove', mouseMoveHandler);
      };

      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler, { once: true });
    },
  };
}
```

<br />

<p align="center">
  <img
    src="https://velog.velcdn.com/images/bepyan/post/cefaa0e8-c43c-4013-8005-00530b63e5bd/image.png"
    width="300px"
  />
</p>

---

22.10.10 추가

모바일 기기에서 touch를 통해서 scroll를 내리게 된다.
따라서 drag하면서 scroll이 되는 버그가 발생하게 된다...

이를 해결해주기 위해

```ts
const touchMoveHandler = (moveEvent: TouchEvent) => {
  if (moveEvent.cancelable) moveEvent.preventDefault();
};

document.addEventListener('touchmove', touchMoveHandler, { passive: false });
```

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/

style 정보, 전체 코드는 아래 깃허브에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Drag Resize 뽀개기]]></title>
        <id>/blog/dnd-master/3-drag-resize</id>
        <link href="https://bepyan.github.io/blog/dnd-master/3-drag-resize"/>
        <updated>2022-10-03T15:01:48.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 element 크기를 drag해서 조정하자!!!]]></summary>
        <content type="html"><![CDATA[
[이전 포스트](./2-drag-touch-event)에서 연구한 drag 이벤트를 활용하여 Resize 기능을 구현해보자.

## TL;DR

> [**getBoundingClientRect**](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect)를 활용하여 엘리먼트의 크기 정보를 얻는다.
> Drag 거리에 맞춰 엘리먼트 크기를 조정해준다.

---

## 복습 — Drag 이벤트 등록

DOM 이벤트를 활용하여 마우스의 움직임을 추적한다.

1. 클릭시(`onMouseDown`) `document`에 `mousemove` `mouseup` 이벤트를 등록한다.
2. element의 클릭 이벤트가 부모로 전파되지 않길 원할 경우 `stopPropagation`을 호출한다.
3. 클릭된 상태에서 마우스를 움직일시 `mousemove`에 등록 된 함수가 계속 호출된다.
4. 클릭(`mousedown`) 이벤트 발생시의 마우스 위치를 기준으로,
   이동(`mousemove`) 이벤트에서 상대적으로 이동한 거리(**deltaX**, **deltaY**)를 계산하고
   콜벡으로 받은 `onDragChange`에게 전달해준다.
5. `mouseup` 이벤트에서 `mousemove` 이벤트를 제거한다.

```tsx
export default function registMouseDownDrag(
  onDragChange: (deltaX: number, deltaY: number) => void,
  stopPropagation?: boolean,
) {
  return {
    onMouseDown: (clickEvent: React.MouseEvent<Element, MouseEvent>) => {
      // 2️⃣
      if (stopPropagation) clickEvent.stopPropagation();

      // 3️⃣
      const mouseMoveHandler = (moveEvent: MouseEvent) => {
        // 4️⃣
        const deltaX = moveEvent.screenX - clickEvent.screenX;
        const deltaY = moveEvent.screenY - clickEvent.screenY;
        onDragChange(deltaX, deltaY);
      };

      // 5️⃣
      const mouseUpHandler = () => {
        document.removeEventListener('mousemove', mouseMoveHandler);
      };

      // 1️⃣
      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler, { once: true });
    },
  };
}
```

---

## 기본 응용 — Drag로 Resize하기

마우스의 움직임 바탕으로 element의 size를 조정해보자.

1. element의 `config`(위치, 크기) 상태를 정의한다.
2. element의 `config`을 초기화 한다.
   덤으로 boundary를 기준으로 중앙정렬을 해주자.
3. element의 우하단에 resize를 동작시키는 영역을 정의한다. ([tailwind](https://tailwindcss.com/)를 사용했다.)
4. config 상태를 변경하여 element의 크기를 변화시킨다.

```tsx
// 1️⃣
const [{ x, y, w, h }, setConfig] = useState({
  x: 0,
  y: 0,
  w: 0,
  h: 0,
});

const boundaryRef = useRef<HTMLDivElement>(null);
// 2️⃣
useEffect(() => {
  const boundary = boundaryRef.current?.getBoundingClientRect();

  if (boundary) {
    const DEFAULT_W = 240;
    const DEFAULT_H = 120;
    setConfig({
      x: Math.floor(boundary.width / 2 - DEFAULT_W / 2),
      y: Math.floor(boundary.height / 2 - DEFAULT_H / 2),
      w: DEFAULT_W,
      h: DEFAULT_H,
    });
  }
}, []);

return (
  <Boundary ref={boundaryRef}>
    <div style={{ width: w, height: h, left: x, top: y }} className="relative">
      <Box />
      <div
        // 3️⃣
        className="absolute -bottom-0.5 left-3 right-3 h-2 cursor-s-resize"
        {...registMouseDownDrag((deltaX, deltaY) => {
          // 4️⃣
          setConfig({
            x,
            y,
            w: w + deltaX,
            h: h + deltaY,
          });
        })}
      />
    </div>
  </Boundary>
);
```

![](https://velog.velcdn.com/images/bepyan/post/7e2b0964-cffa-4800-b2b5-7ccdb3b60b4d/image.gif)

---

## 추가 응용 — Boundary 적용

element가 **움직일 수 있는 범위**를 계산해보자.
![](https://velog.velcdn.com/images/bepyan/post/8c05b6c0-75e7-419d-9b68-ddc84cf4ff7f/image.png)

좌측 끝 = `BOUNDARY_MARGIN`
우측 끝 = `boundary.width` - `w` - `BOUNDARY_MARGIN`

<br />

자, 이제 element가 **확장할 수 있는 범위**를 계산해보자.
![](https://velog.velcdn.com/images/bepyan/post/089b4342-25bf-4e4f-926b-441a987bbfa9/image.png)

최소 width = `MIN_W`
최대 width = `boundary.width` - `x` - `BOUNDARY_MARGIN`

<br />

그림을 그려보니 생각보다 간단하지 않는가?!
이제 아래 주요 로직을 따라 코드를 작성해보도록 하자.

1. position drag 이벤트를 등록해준다.
2. `resize`의 클릭 이벤트가 부모로 전파되지 않도록 `stopPropagation` 해준다.
3. `resize`되는 범위를 잘 설정해준다.

```tsx
const inrange = (v: number, min: number, max: number) => {
  if (v < min) return min;
  if (v > max) return max;
  return v;
};

const BOUNDARY_MARGIN = 12;
const MIN_W = 80;
const MIN_H = 80;
```

```tsx
<Boundary ref={boundaryRef}>
  <div
    style={{ width: w, height: h, left: x, top: y }}
    className="relative"
    // 1️⃣
    {...registMouseDownDrag((deltaX, deltaY) => {
      if (!boundaryRef.current) return;

      const boundary = boundaryRef.current.getBoundingClientRect();
      setConfig({
        x: inrange(x + deltaX, BOUNDARY_MARGIN, boundary.width - w - BOUNDARY_MARGIN),
        y: inrange(y + deltaY, BOUNDARY_MARGIN, boundary.height - h - BOUNDARY_MARGIN),
        w,
        h,
      });
    }
  >
    <Box />
    <div
      className="absolute -bottom-0.5 left-3 right-3 h-2 cursor-s-resize"
	  style={{ backgroundColor: '#12121250' }}
      {...registMouseDownDrag((deltaX, deltaY) => {
        if (!boundaryRef.current) return;

        // 3️⃣
        const boundary = boundaryRef.current.getBoundingClientRect();
        setConfig({
          x,
          y,
          w: inrange(w + deltaX, MIN_W, boundary.width - x - BOUNDARY_MARGIN),
          h: inrange(h + deltaY, MIN_H, boundary.height - y - BOUNDARY_MARGIN),
        });
      // 2️⃣
      }, true)}
      />
  </div>
</Boundary>
```

![](https://velog.velcdn.com/images/bepyan/post/6c7c265f-5902-4602-8716-f4608794d847/image.gif)

오호, 이 정도면 좀 쓸만할 것 같다 💪🏾

---

## 심화 응용 — 여러 방향의 Resize

우리가 많이 접한 편집툴은 좌상단, 우상단, 좌하단, 우하단 4가지 방향으로 Resize할 수 있다.
다른 방향으로 진행하기 위해서 무엇을 고려해야하는지 살펴보자.

**좌상단**인 경우, 우하단 동작 방식과 좀 다르다.
`x`가 줄어드는 만큼 `w`가 증가해야지 위치가 고정된 상태에서 element 크기가 달라진다.
그렇다면 이들의 범위를 계산해보도록 하자.

![](https://velog.velcdn.com/images/bepyan/post/5420046d-0f19-4920-a573-21ddf35edf6b/image.png)

`maxX` = `x` + `w` - `MIN_W`
`maxWidth` = `x` + `w` - `BOUNDARY_MARGIN`

<br />

이를 코드에 적용하면 아래와 같다.
여기서 `deltaX`가 줄어 들 때 `width`가 증가한다는 점을 놓치지 말자.
`width = w - deltaX`

```tsx
{/* 좌상단 */}
<div
  className="absolute -top-1 -left-1 h-4 w-4 cursor-nw-resize"
  style={{ '#12121250' }}
  {...registMouseDownDrag((deltaX, deltaY) => {
    setConfig({
      x: inrange(x + deltaX, BOUNDARY_MARGIN, x + w - MIN_W),
      y: inrange(y + deltaY, BOUNDARY_MARGIN, y + h - MIN_H),
      w: inrange(w - deltaX, MIN_W, x + w - BOUNDARY_MARGIN),
      h: inrange(h - deltaY, MIN_H, y + h - BOUNDARY_MARGIN),
    });
  }, true)}
/>
```

다른 방향에서의 원리도 이와 비슷하다.
적절히 응용해보도록 하자.

```tsx
{
  /* 우상단 */
}
<div
  className="absolute -top-1 -right-1 h-4 w-4 cursor-ne-resize"
  style={{ backgroundColor: '#12121250' }}
  {...registMouseDownDrag((deltaX, deltaY) => {
    if (!boundaryRef.current) return;

    const boundary = boundaryRef.current.getBoundingClientRect();

    setConfig({
      x,
      y: inrange(y + deltaY, BOUNDARY_MARGIN, y + h - MIN_H),
      w: inrange(w + deltaX, MIN_W, boundary.width - x - BOUNDARY_MARGIN),
      h: inrange(h - deltaY, MIN_H, y + h - BOUNDARY_MARGIN),
    });
  }, true)}
/>;

{
  /* 좌하단 */
}
<div
  className="absolute -bottom-1 -left-1 h-4 w-4 cursor-ne-resize"
  style={{ backgroundColor: '#12121250' }}
  {...registMouseDownDrag((deltaX, deltaY) => {
    if (!boundaryRef.current) return;

    const boundary = boundaryRef.current.getBoundingClientRect();

    setConfig({
      x: inrange(x + deltaX, BOUNDARY_MARGIN, x + w - MIN_W),
      y,
      w: inrange(w - deltaX, MIN_W, x + w - BOUNDARY_MARGIN),
      h: inrange(h + deltaY, MIN_H, boundary.height - y - BOUNDARY_MARGIN),
    });
  }, true)}
/>;
```

![](https://velog.velcdn.com/images/bepyan/post/85f36f99-622d-432a-85ff-7c0443d80dfa/image.gif)

상하좌우 방향은 그저 하드코딩을 이어가면 된다.
그럼 다음 기능 개발로 넘어가보자 🏄🏻‍♂️

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/resize

style 정보, 전체 코드는 아래 깃허브에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/blob/main/src/components/DragSizeExample.tsx
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Drag Carousel 뽀개기]]></title>
        <id>/blog/dnd-master/4-drag-carousel</id>
        <link href="https://bepyan.github.io/blog/dnd-master/4-drag-carousel"/>
        <updated>2022-10-08T15:02:55.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 터치로 캐러셀을 만들어 보자!!!]]></summary>
        <content type="html"><![CDATA[
## TL;DR

> 캐러셀을 **일정 거리이상** drag시키면 화면을 넘긴다.

---

## 기본 원리 — Carousel 동작

여러 방식으로 Carousel를 구현할 수 있지만 아래와 같은 형태로 간편하게 마크업을 짜자.
css는 편의상 [**tailwindcss**](https://tailwindcss.com/)를 같이 사용했다.

```tsx
const imageList = [...];

const SLIDER_WIDTH = 400;
const SLIDER_HEIGHT = 400;

export default function CarouselExample() {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [transX, setTransX] = useState(0);

  return (
    <>
      {/* Viewer */}
      <div
        className="overflow-hidden"
        style={{
          width: SLIDER_WIDTH,
          height: SLIDER_HEIGHT,
        }}
      >
        {/* Slider */}
        <div
          className="flex"
          style={{
            transform: `translateX(${-currentIndex * SLIDER_WIDTH + transX}px)`,
          }}
        >
          {/* Slide */}
          {imageList.map((url, i) => (
            <div key={i} className="flex-shrink-0">
              <img src={url} alt="img" width={SLIDER_WIDTH} draggable={false} />
            </div>
          ))}
        </div>
      </div>
    </>
  );
}
```

마크업을 그림으로 정리하자면 아래와 같다

![](https://velog.velcdn.com/images/bepyan/post/9c60a2a9-a65b-444b-bd66-0504dcf3fc14/image.png)

`Viewer`는 **액자**와 같은 역할을 수행하고
실질적으로 `Slider`가 좌우로 `transform`하여 캐러셀 움직임을 구현한다.

따라서 사전에 `Slide`의 크기를 알고 있어야 한다.
동적으로 크기를 맞출려면 `ref`로 `element.getBoundingClientRect`을 호출하면 된다.

---

## 기본 응용 — Carousel Drag

캐러셀을 **일정 거리이상 drag**하면 화면을 넘긴다.
~~참 쉽죠잉?~~

![](https://velog.velcdn.com/images/bepyan/post/d73cc634-2819-4264-ae72-704a0252f24d/image.gif)

1. [이전 글](https://velog.io/@bepyan/Drag-Touch-뽀개기#심화-응용--최종-코드)을 참고하여 드래그 이벤트를 등록한다.
2. drag된 거리에 만큼 `transX`를 이동시킨다.
   한번의 drag로 한 슬라이드 이상으로 이동할 수 없도록 하자.
3. 손을 땠을 때 일정 거리이상 움직이면 `currentIndex`를 변경해준다.
4. drag된 `transX`를 초기화 해준다.

```tsx
const inrange = (v: number, min: number, max: number) => {
  if (v < min) return min;
  if (v > max) return max;
  return v;
};
```

```jsx
<div
  className="flex"
  style={{
    transform: `translateX(${-currentIndex * SLIDER_WIDTH + transX}px)`,
    // 🏄🏻‍♂️  drag를 초기화할 때 부드럽게 이동시켜 주자. 꼼수입니다...
    transition: `transform ${transX ? 0 : 300}ms ease-in-out 0s`,
  }}
  // 1️⃣
  {...registDragEvent({
    onDragChange: (deltaX) => {
      // 2️⃣
      setTransX(inrange(deltaX, -SLIDER_WIDTH, SLIDER_WIDTH));
    },
    onDragEnd: (deltaX) => {
      const maxIndex = imageList.length - 1;

      // 3️⃣
      if (deltaX < -100) setCurrentIndex(inrange(currentIndex + 1, 0, maxIndex));
      if (deltaX > 100) setCurrentIndex(inrange(currentIndex - 1, 0, maxIndex));

      // 4️⃣
      setTransX(0);
    },
  })}
>
  //...
</div>
```

---

## 심화 응용 — Infinite Carousel

단골로 사용되는 기능 중에 하나이다.
무한으로 돌아가는 트릭은 생각보다 간단하다.

> 첫 슬라이드 좌측으로 이동시 마지막 슬라이드로,
> 마지막 슬라이드 우측으로 이동시 첫 슬라이드로 이동하면 캐러셀이 무한으로 돌아갈 것이다.

자, 구현 해보자!

기존 `[0, 1, 2, 3]` 번 슬라이드를 `[3, 0, 1, 2, 3, 0]`로 만든다.
그리고 `index`를 `1`부터 시작하는 것을 잊지 말자.

```tsx
const slideList = [imageList.at(-1), ...imageList, imageList.at(0)];
const [currentIndex, setCurrentIndex] = useState(1);
```

<br />

자연스럽게 **무한루프** 되기 위해선 `currentIndex`가 아래와 같이 동작해야 한다.

```
1 → 0  (에니메니션 없이) → 4
```

`dragEnd`시 `currentIndex`를 변동하게 될 것이다.
[**onTransitionEnd**](https://developer.mozilla.org/en-US/docs/Web/API/Element/transitionend_event)을 활용하여 `transition`이 종료될시 `animate`를 끄고 `currentIndex`를 변동해준다.

```tsx
const [animate, setAnimate] = useState(false);

<div
  style={{
    transform: `translateX(${-currentIndex * SLIDER_WIDTH + transX}px)`,
    transition: `transform ${animate ? 300 : 0}ms ease-in-out 0s`,
  }}
  {...({
  	onDragEnd: (deltaX) => {
      //...

      setAnimate(true);
      setTransX(0);
    }
  })}
  onTransitionEnd={() => {
	setAnimate(false);

    if (currentIndex === 0) {
      setCurrentIndex(slideList.length - 2);
    } else if (currentIndex === slideList.length - 1) {
      setCurrentIndex(1);
    }
  }}
>
  {...}
</div>
```

![](https://velog.velcdn.com/images/bepyan/post/7c638d6a-838a-4f70-9c1d-4517e9e0770b/image.gif)

---

## 최종 코드

```tsx
const imageList = [
  'https://blog.kakaocdn.net/dn/dpxiAT/btqUBv6Fvpn/E8xUMncq7AVuDeOim0LrMk/img.jpg',
  'https://blog.kakaocdn.net/dn/BGT7X/btqUzvTqi5h/flp39GdJH0GU6mo7cTbbhk/img.jpg',
  'https://blog.kakaocdn.net/dn/bWnmfv/btqUBwqZvwA/3CiXGt3SR0TXoOveRJxV91/img.jpg',
  'https://blog.kakaocdn.net/dn/XsLCO/btqUL8PQLwp/NZWCU2jAYKkKSXwcohBKTK/img.jpg',
  'https://blog.kakaocdn.net/dn/bG3iVL/btqUvCZPaRL/ofIjkNWJP1mj2bOG9fie51/img.jpg',
];

const SLIDER_WIDTH = 400;
const SLIDER_HEIGHT = 400;

export default function CarouselInfiniteExample() {
  const slideList = [imageList.at(-1), ...imageList, imageList.at(0)];

  const [currentIndex, setCurrentIndex] = useState(1);
  const [transX, setTransX] = useState(0);
  const [animate, setAnimate] = useState(false);

  return (
    <>
      <div
        className="overflow-hidden"
        style={{
          width: SLIDER_WIDTH,
          height: SLIDER_HEIGHT,
        }}
      >
        <div
          className="flex"
          style={{
            transform: `translateX(${-currentIndex * SLIDER_WIDTH + transX}px)`,
            transition: `transform ${animate ? 300 : 0}ms ease-in-out 0s`,
          }}
          {...registDragEvent({
            onDragChange: (deltaX) => {
              setTransX(inrange(deltaX, -SLIDER_WIDTH + 10, SLIDER_WIDTH - 10));
            },
            onDragEnd: (deltaX) => {
              const maxIndex = slideList.length - 1;

              if (deltaX < -100) setCurrentIndex(inrange(currentIndex + 1, 0, maxIndex));
              if (deltaX > 100) setCurrentIndex(inrange(currentIndex - 1, 0, maxIndex));

              setAnimate(true);
              setTransX(0);
            },
          })}
          onTransitionEnd={() => {
            setAnimate(false);

            if (currentIndex === 0) {
              setCurrentIndex(slideList.length - 2);
            } else if (currentIndex === slideList.length - 1) {
              setCurrentIndex(1);
            }
          }}
        >
          {slideList.map((url, i) => (
            <div key={i} className="flex-shrink-0">
              <img src={url} alt="img" width={SLIDER_WIDTH} draggable={false} />
            </div>
          ))}
        </div>
      </div>
    </>
  );
}
```

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/carousel

style 정보, 전체 코드는 아래 깃허브에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DND 이벤트 뽀개기]]></title>
        <id>/blog/dnd-master/5-drag-and-drop</id>
        <link href="https://bepyan.github.io/blog/dnd-master/5-drag-and-drop"/>
        <updated>2022-10-10T15:03:21.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 Drag and Drop 이벤트를 구현해보자!!!]]></summary>
        <content type="html"><![CDATA[
드디어, 대망의 DND 이벤트를 구현해보도록 하자!

칸반보드, 목차 편집 기능이 실용적이지만
재미삼아서 먼저 퍼즐 맞추기 게임 느낌의 이벤트를 먼저 만들어 보자.
https://www.happyclicks.net/drag-drop-games/games_numbers.php

~~어쩌다보니 글이 좀 깁니다...~~

## TL;DR

> [**cloneNode**](https://developer.mozilla.org/ko/docs/Web/API/Node/cloneNode)를 통해 타겟을 복사하여 drag시킨다.
> [**document.elementFromPoint(x, y)**](https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint)을 활용하여 특정 영역의 element 정보를 얻는다.
> 획득한 element의 정보 바탕으로 `onDrop` 이벤트를 구현한다.

---

## EVENT — 이벤트 등록

DOM API를 직접적으로 다뤄야하다 보니
이를 별도의 스크립트에서 vanilla로 코드를 작성하는 것이 편할 것 같다.

먼저,
NextJS에서는 CSR에서 스크립트가 실행되도록 훅을 만들어 준다.

`DNDMatchExample.tsx`

```tsx
const [ready, setReady] = useState(false);

useEffect(() => {
  if(!ready) {
    setReady(true);
    return;
  }

  // 이벤트를 등록한다.
  const cleanup = registDND(...);

  // 이벤트를 해제해준다.
  return () => cleanup();
}, [ready]);

if (!ready) return <></>;
```

<br />

스크립트는 `DNDMatchExample.drag.ts` 파일로 작성했다.
모바일에서도 동작이 가능하도록 설정했다.
관련 로직은 [**이전 포스트**](https://velog.io/@bepyan/Drag-Touch-뽀개기)를 참고하면 될 것 같다.

```tsx
export const registDND = (...) => {

  // 모바일 기기에서의 Touch 이벤트
  const isTouchScreen =
    typeof window !== 'undefined' &&
    window.matchMedia('(hover: none) and (pointer: coarse)').matches;

  const startEventName = isTouchScreen ? 'touchstart' : 'mousedown';
  const moveEventName = isTouchScreen ? 'touchmove' : 'mousemove';
  const endEventName = isTouchScreen ? 'touchend' : 'mouseup';

  // 마우스 움직임 변화를 측정하는 유틸
  const getDelta = (startEvent: MouseEvent | TouchEvent, moveEvent: MouseEvent | TouchEvent) => {
    if (isTouchScreen) {
      const se = startEvent as TouchEvent;
      const me = moveEvent as TouchEvent;

      return {
        deltaX: me.touches[0].pageX - se.touches[0].pageX,
        deltaY: me.touches[0].pageY - se.touches[0].pageY,
      };
    }

    const se = startEvent as MouseEvent;
    const me = moveEvent as MouseEvent;

    return {
      deltaX: me.pageX - se.pageX,
      deltaY: me.pageY - se.pageY,
    };
  };

  // DND 등록 이벤트
  const startHandler = (startEvent: MouseEvent | TouchEvent) => {
    const item = startEvent.target as HTMLElement;

    // Drag 대상이 아니면 이벤트를 종료해준다.
    if (!item.classList.contains('dnd-drag-item')) {
      return;
    }

    // Drag 시작 이벤트 관련 동작
    // {...}

    // Drag 움직임 이벤트 관련 동작
    const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
      // {...}
    };

    // Drag 종료(Drop) 이벤트 관련 동작
    const endHandler = () => {
      // {...}

      document.removeEventListener(moveEventName, moveHandler);
    };

    document.addEventListener(moveEventName, moveHandler);
    document.addEventListener(endEventName, endHandler, { once: true });
  }


  // document에 DND 이벤트를 등록해준다.
  document.addEventListener(startEventName, startHandler);
  return () => document.removeEventListener(startEventName, startHandler);
};
```

jsx에서처럼 이벤트를 등록할 수 없기에
이전과는 다르게 [이벤트 위임](https://ko.javascript.info/event-delegation)를 활용하여 document에 등록해줬다.

이제 로직을 하나 하나 구현을 해보자.

---

## DRAG — Ghost 만들기

> 핵심은 기존 엘리먼트을 그대로 두고 `clone`한 `ghost`를 움직이게 한다.

```tsx
const startHandler = (startEvent: MouseEvent | TouchEvent) => {
  const item = clickEvent.currentTarget as HTMLElement;
  if (
    !item.classList.contains('dnd-drag-item') ||
    item.classList.contains('ghost') ||
    item.classList.contains('placeholder')
  ) {
    return;
  }

  const itemRect = item.getBoundingClientRect();

  // --- Ghost 만들기
  const ghostItem = item.cloneNode(true) as HTMLElement;
  ghostItem.classList.add('ghost');
  ghostItem.style.position = 'fixed';
  ghostItem.style.top = `${itemRect.top}px`;
  ghostItem.style.left = `${itemRect.left}px`;
  ghostItem.style.pointerEvents = 'none';
  ghostItem.style.textShadow = '0 30px 60px rgba(0, 0, 0, .3)';
  ghostItem.style.transform = 'scale(1.05)';
  ghostItem.style.transition = 'transform 200ms ease';

  item.style.opacity = '0.5';
  item.style.cursor = 'grabbing';

  document.body.style.cursor = 'grabbing';
  document.body.appendChild(ghostItem);
  // --- Ghost 만들기 END


  const mouseMoveHandler = (moveEvent: MouseEvent) => {
    // --- Ghost Drag
    const deltaX = moveEvent.pageX - clickEvent.pageX;
    const deltaY = moveEvent.pageY - clickEvent.pageY;

    ghostItem.style.top = `${itemRect.top + deltaY}px`;
    ghostItem.style.left = `${itemRect.left + deltaX}px`;
    // --- Ghost Drag END
  };


  const mouseUpHandler = (moveEvent: MouseEvent) => {
    // --- Ghost 제자리 복귀
    ghostItem.style.transition = 'all 200ms ease';
    ghostItem.style.left = `${itemRect.left}px`;
    ghostItem.style.top = `${itemRect.top}px`;
    ghostItem.style.transform = 'none';

    ghostItem.addEventListener(
      'transitionend',
      () => {
        item.removeAttribute('style');
        document.body.removeAttribute('style');
        ghostItem.remove();
      },
      { once: true },
    );
    // --- Ghost 제자리 복귀 END

    // ...
  };
}}
```

#### 체크 포인트

- `ghost`가 마우스(포인터) 이벤트에 관여되지 않도록 [pointer-event](https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events) `none`으로 설정해줬다.
- 기존 엘리먼트에는 `placeholder` 클래스를 둬서 드레그되고 있음을 인지시킨다.
- 별도의 css 없이 스타일을 모두 인라인으로 작성했다.

![](https://velog.velcdn.com/images/bepyan/post/19de45cf-494e-4592-9575-c3cafd96604a/image.gif)

---

## DROP — 영역 확인

> 핵심은 `docuemnt.elementFromPoint`을 활용해서 특정 위치에 어떤 엘리먼트가 있는지 확인 한다.
> ghost가 항상 잡히기에 `pointer-event: none;`으로 설정하여 회피해준다.

[**elementFromPoint**](https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint) - returns the topmost Element at the specified coordinates (relative to the viewport).

```tsx
//...
const dropAreaList = document.querySelectorAll<HTMLElement>('.dnd-drop-area');
//...

const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
  // ...

  //--- Drop 영역 확인
  const ghostItemRect = ghostItem.getBoundingClientRect();
  const ghostCenterX = ghostItemRect.left + ghostItemRect.width / 2;
  const ghostCenterY = ghostItemRect.top + ghostItemRect.height / 2;

  const dropItem = document
    .elementFromPoint(ghostCenterX, ghostCenterY)
    ?.closest<HTMLElement>('.dnd-drop-area');

  dropAreaList.forEach((area) => {
    area.classList.remove('active');
    area.removeAttribute('style');
  });

  if (dropItem) {
    dropItem.classList.add('active');
    dropItem.style.filter = 'drop-shadow(16px 16px 16px gray)';
  }
  //--- Drop 영역 확인 END
};
```

#### 체크 포인트

- 커서의 위치가 아닌, **ghost의 중심 좌표**를 기준으로 `drop` 영역 위인지 여부를 파악했다.
- drop 영역 위일 경우 `active` 클래스명을 추가했다. 이를 아래 onDrop 이벤트에서 활용한다.

![](https://velog.velcdn.com/images/bepyan/post/ec48197a-2774-4b84-9473-1537853c3246/image.gif)

---

## DROP — onDrop

> `active` 영역이 있을 경우 `onDrop` 로직을 수행한다.

```tsx
export const registDND = (
  onDrop: (props: { source: string; destination: string; isCorrect: boolean }) => void,
) => {
  //...

  const endHandler = () => {
    const dropItem = document.querySelector<HTMLElement>('.dnd-drop-area.active');
    const isCorrect = item.innerText === dropItem?.innerText;

    if (isCorrect) {
      // 해당 영역으로 이동
      const dropItemRect = dropItem.getBoundingClientRect();
      ghostItem.style.left = `${dropItemRect.left}px`;
      ghostItem.style.top = `${dropItemRect.top}px`;
    } else {
      // 제자리 복귀
      ghostItem.style.left = `${itemRect.left}px`;
      ghostItem.style.top = `${itemRect.top}px`;
    }

    ghostItem.style.transition = 'all 200ms ease';
    ghostItem.style.transform = 'none';
    ghostItem.addEventListener(
      'transitionend',
      () => {
        item.classList.remove('placeholder');
        item.removeAttribute('style');
        document.body.removeAttribute('style');

        if (dropItem) {
          // 영역 스타일 초기화
          dropItem.classList.remove('active');
          dropItem.removeAttribute('style');

          //
          if (isCorrect) {
            item.classList.add('opacity-50');
            dropItem.classList.remove('text-white');
            dropItem.classList.add('text-stone-700');
          }
        }

        ghostItem.remove();

        // onDrop 콜벡을 수행
        onDrop({
          source: item.innerText,
          destination: dropItem?.innerText ?? '',
          isCorrect,
        });
      },
      { once: true },
    );

    document.removeEventListener(moveEventName, moveHandler);
  };

  //...
};
```

콜벡에서 위치가 맞는 겨우 상태를 수정해준다.

```tsx
useEffect(() => {
  if (!ready) {
    setReady(true);
    return;
  }

  const cleanup = registDND(({ destination, isCorrect }) => {
    if (isCorrect) {
      setCorrectWords((list) => [...list, destination]);
    }
  });
  return () => cleanup();
}, [ready]);
```

#### 체크 포인트

- 맞는 경우 DOM style을 수정하고 나서 react state를 변경해야 한다.
  아니면 상태 변경 전에 화면이 깜빡 거린다.

![](https://velog.velcdn.com/images/bepyan/post/5026ce1b-c9de-4a42-a862-69178a845a96/image.gif)

이렇게 DND 기능 구현이 완료 👏🏻
게임 컨셉의 DND이기 때문에 추가적인 에니메이션을 구현해보자.

---

## (번외) 틀린경우 — shake

알맞지 않은 알파벳으로 이동할 경우 해당 알파벳이 흔들리도록 하자.
![](https://velog.velcdn.com/images/bepyan/post/51711783-ca6a-48cb-932e-7875b185a1a8/image.gif)

먼저 `global.css`에서 관련 에니메이션 css를 작성한다.
`50%` 지점에서 가장 크게 흔들리는 것이 포인트이다.

```css
@keyframes shake {
  10%,
  90% {
    transform: translate3d(-1px, 0, 0);
  }

  20%,
  80% {
    transform: translate3d(2px, 0, 0);
  }

  30%,
  50%,
  70% {
    transform: translate3d(-4px, 0, 0);
  }

  40%,
  60% {
    transform: translate3d(4px, 0, 0);
  }
}

.shake {
  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
}
```

엘리먼트에 `shake` 클래스를 추가하면 에니메이션이 실행되고,
`animationend`에서 다시 `shake` 클래스를 제거해준다.

```tsx
ghostItem.addEventListener(
  'transitionend',
  () => {
    //...

    if (dropItem) {
      //...

      if (!isCorrect) {
        // 틀린 경우 shake
        item.classList.add('shake');
        item.addEventListener(
          'animationend',
          () => {
            item.classList.remove('shake');
          },
          { once: true },
        );
      } else {
        item.classList.add('opacity-50');
        dropItem.classList.remove('text-white');
        dropItem.classList.add('text-stone-700');
      }
    }

    //...
  },
  { once: true },
);
```

---

## (번외) 게임 클리어 — Confettiful

게임 클리어할 경우 격하게 축하해주고 싶다.
![](https://velog.velcdn.com/images/bepyan/post/d4c98124-7a66-4fbb-9cab-7da9859fa99b/image.gif)

아래에서 관련 로직을 참고했다.
https://codepen.io/l2zeo/pen/ZEBLepW

너무 레거시한 코드 구현방식이여서 NextJS, Typescript에 맞게 리팩토링했다.
~~생각보다 코드는 간단하다.~~

`Confettiful.ts`

```ts
const confettiFrequency = 40;
const confettiColors = ['#B1B2FF', '#AAC4FF', '#2D87B0', '#D2DAFF', '#EEF1FF'];
const confettiAnimations = ['slow', 'medium', 'fast'];

const getRandomListItem = (list: any[]) => list[Math.floor(Math.random() * list.length)];

const Confettiful = function () {
  const el = document.createElement('div');
  el.style.position = 'fixed';
  el.style.pointerEvents = 'none';
  el.style.width = '100%';
  el.style.height = '100%';

  const containerEl = document.createElement('div');
  containerEl.style.position = 'absolute';
  containerEl.style.overflow = 'hidden';
  containerEl.style.top = '0';
  containerEl.style.right = '0';
  containerEl.style.bottom = '0';
  containerEl.style.left = '0';
  el.appendChild(containerEl);

  const confettiInterval = setInterval(() => {
    const confettiEl = document.createElement('div');
    confettiEl.style.position = 'absolute';
    confettiEl.style.zIndex = '1';
    confettiEl.style.top = '-10px';
    confettiEl.style.borderRadius = '0%';

    const confettiSize = Math.floor(Math.random() * 3) + 7 + 'px';
    const confettiLeft = Math.floor(Math.random() * el.offsetWidth) + 'px';
    const confettiBackground = getRandomListItem(confettiColors);
    const confettiAnimation = getRandomListItem(confettiAnimations);

    confettiEl.classList.add('confetti', `confetti--animation-${confettiAnimation}`);
    confettiEl.style.left = confettiLeft;
    confettiEl.style.width = confettiSize;
    confettiEl.style.height = confettiSize;
    confettiEl.style.backgroundColor = confettiBackground;

    setTimeout(function () {
      confettiEl.parentNode?.removeChild(confettiEl);
    }, 3000);

    containerEl.appendChild(confettiEl);
  }, 1000 / confettiFrequency);

  document.querySelector('#__next')?.prepend(el);

  return () => {
    clearInterval(confettiInterval);
    setTimeout(function () {
      el.remove();
    }, 3000);
  };
};

export default Confettiful;
```

<br />

`global.css`에도 관련 스타일을 추가해줘야 한다.

- 떨어지는 속도 종류를 `slow`, `medium`, `fast` 3가지를 정의하여 각각 `routate`되는 정도를 조정해준다.
- `keyframe`이 `100%`되었을 때 가루가 화면 밖으로 떨어지도록 `105vh` 설정해준다.

```css
/* confetti */

@keyframes confetti-slow {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(25px, 105vh, 0) rotateX(360deg) rotateY(180deg);
  }
}

@keyframes confetti-medium {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(100px, 105vh, 0) rotateX(100deg) rotateY(360deg);
  }
}

@keyframes confetti-fast {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(-50px, 105vh, 0) rotateX(10deg) rotateY(250deg);
  }
}

.confetti--animation-slow {
  animation: confetti-slow 2.25s linear 1 forwards;
}

.confetti--animation-medium {
  animation: confetti-medium 1.75s linear 1 forwards;
}

.confetti--animation-fast {
  animation: confetti-fast 1.25s linear 1 forwards;
}

/* confetti end */
```

<br />

컴포넌트가 `unmounded`될 때 Confetii를 지워주면 된다.

```tsx
let cleanConfetti: () => void | undefined;
//...

const [words, setWords] = useState<string[]>(['D', 'R', 'A', 'G']);
const [correctWords, setCorrectWords] = useState<string[]>([]);

const isClear = useMemo(() => correctWords.length === words.length, [correctWords, words]);

useEffect(() => {
  if (isClear) {
    cleanConfetti = Confettiful();
  } else {
    cleanConfetti?.();
  }

  return () => {
    cleanConfetti?.();
  };
}, [isClear]);
```

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/dnd

style 정보, 전체 코드는 아래 깃허브에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/blob/main/src/components/DragSizeExample.tsx
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[react-beautiful-dnd로 TODO 뽀개기]]></title>
        <id>/blog/dnd-master/6-react-beautiful-dnd</id>
        <link href="https://bepyan.github.io/blog/dnd-master/6-react-beautiful-dnd"/>
        <updated>2022-10-16T15:05:38.000Z</updated>
        <summary type="html"><![CDATA[라이브러리를 활용해서 React에서 Drag and Drop TODO 칸반 보드를 구현해보자!!!]]></summary>
        <content type="html"><![CDATA[
다들 한번씩은 만들어보는 TODO 리스트.
Drag and Drop으로 구현해보는 것이 FE 개발자로서의 로망 아닌가 싶다.
그렇다면 한번 뽀개보도록 하자!

우선 라이브러리를 통해서 어떻게 구현하고 어떻게 동작하는지를 알고
라이브러리 없이 한번 구현해보도록 하자.

<p align="center">
  <img
    src="https://velog.velcdn.com/images/bepyan/post/ad52f83b-69ab-409e-a53c-300f7cf0d0b6/image.png"
    alt="야 너두 할 수 있어"
    width="500px"
  />
</p>

~~야너두 할 수 있어!~~
바쁘신 분들은 바로 [**최종 코드**](https://velog.io/@bepyan/react-beautiful-dnd%EB%A1%9C-TODO-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0#%EC%B5%9C%EC%A2%85-%EC%BD%94%EB%93%9C)로 🚀

---

## react-beautiful-dnd

> create beautiful **drag and drop for lists** that anyone can use.

[**Atlassian**](https://www.atlassian.com/ko)에서 만든 React DND 라이브러리이다.
[Trello](https://trello.com/), [Jira](https://www.atlassian.com/software/jira)를 만든 회사이니 근본력은 설명 필요없이 그저 믿고 쓰면 된다!

**https://github.com/atlassian/react-beautiful-dnd**

예시도 많고 github star도 많지만 개인적으로 공식문서는 조금 진입장벽이 있었다.
친절하지만 '그래서 어떻게 해?'하는 느낌?..이었다.

우선 내가 생각한 공식문서의 핵심을 정리해보았다.

- **✨ 부드러운 에니메이션**이 탑재되어 있다! ~~That what makes you beautiful 🎶~~
- **접근성이 보장된다.** (터치스크린, 키보드, 스크린리더 호환)
- **순서가 있는 리스트**에서의 DND 스타일링, 이벤트를 커스터마이징할 수 있다.
- 특별한 DND 이벤트를 구현할 경우 [**react-dnd**](https://github.com/react-dnd/react-dnd)를 사용하는 것을 권장한다.

---

## NextJS에서 환경세팅

> 라이브러리를 구성하는데 생각보다 삽질을 많이 했다 🥲
>
> - **strictMode** 끄기
> - **requestAnimationFrame** 실행 후 컴포넌트 마운트하기

우선, 라이브러리를 설치하도록 하자.

```shell
yarn add react-beautiful-dnd
yarn add -D @types/react-beautiful-dnd
```

<br />

아직 React18과 아직 호환이 잘 안된다.
[https://github.com/atlassian/react-beautiful-dnd/issues/2399#issuecomment-1111169234](https://github.com/atlassian/react-beautiful-dnd/issues/2399#issuecomment-1111169234)
[https://github.com/atlassian/react-beautiful-dnd/issues/2350](https://github.com/atlassian/react-beautiful-dnd/issues/2350)

React18에서는 **strictMode를 꺼서** 사용하라고 권장하고 있다.
분명히 시키는 대로 했는데 `droppable-id`를 계속 인식하지 못한다는 에러가 떴었다.
~~진짜 미치는 줄 같았다.. 😡~~
`next.config.js`에서 이를 쉽게 설정할 수 있다.

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: false,
  swcMinify: true,
};

module.exports = nextConfig;
```

<br />

그리고 [**requestAnimationFrame**](https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame)이 호출된 이후에 DND 컴포넌트를 렌더링하자.
잘은 모르겠지만, 브라우저가 **부드러운 애니메이션을 렌더링할 준비**되고 앱을 실행한다고 생각하고 넘어가면 될 것 같다.
https://github.com/atlassian/react-beautiful-dnd/issues/2399#issuecomment-1175638194

```tsx
const [enabled, setEnabled] = useState(false);

useEffect(() => {
  const animation = requestAnimationFrame(() => setEnabled(true));

  return () => {
    cancelAnimationFrame(animation);
    setEnabled(false);
  };
}, []);

if (!enabled) {
  return null;
}
```

---

## 컴포넌트 이해하기

3가지 컴포넌트를 활용하여 DND가 이뤄진다.

| 컴포넌트 이름                                                                                                     | 설명                                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| [**DragDropContext**](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/drag-drop-context.md) | ContextAPI의 Provider처럼 DND의 상태를 제공해주는 녀석이라고 보면 될 것 같다.<br /> 여기서 `onDragEnd` 등 다양한 DND 이벤트를 등록 해준다. |
| [**Droppable**](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md)               | DROP할 수 있는 영역으로 명시한다.                                                                                                          |
| [**Draggable**](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/draggable.md)               | DRAG할 수 있게 컴포넌트를 감싸준다.                                                                                                        |

![](https://user-images.githubusercontent.com/2182637/53607406-c8f3a780-3c12-11e9-979c-7f3b5bd1bfbd.gif)

<br />

이름이 좀 헷갈리지만 아주 깔끔한 것 같다.
그렇다면, 스타일 없이 아주 간단한 페이지를 만들어 동작을 살펴보도록 하자. ~~코드는 깔끔하지 않다..~~

쉽게 커스텀할 수 있기 위해서인지 제공되는 API가 좀 복잡하다.
이를 잘 구분하고 본인 프로젝트에 맞게 조립해서 사용해야 한다.

```tsx
import { useEffect, useState } from 'react';
import { DragDropContext, Draggable, Droppable, DropResult } from 'react-beautiful-dnd';

export default function App() {
  // --- Mock 데이터
  const items = [...Array(4)].map((_, i) => ({ id: `${i}${i}${i}`, content: `item-${i}` }));

  // --- Draggable이 Droppable로 드래그 되었을 때 실행되는 이벤트
  const onDragEnd = ({ source, destination }: DropResult) => {
    console.log('>>> source', source);
    console.log('>>> destination', destination);
  };

  // --- requestAnimationFrame 초기화
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    const animation = requestAnimationFrame(() => setEnabled(true));

    return () => {
      cancelAnimationFrame(animation);
      setEnabled(false);
    };
  }, []);

  if (!enabled) {
    return null;
  }
  // --- requestAnimationFrame 초기화 END

  return (
    <DragDropContext onDragEnd={onDragEnd}>
      <Droppable droppableId="droppable">
        {(provided) => (
          <div ref={provided.innerRef} {...provided.droppableProps}>
            {items.map((item, index) => (
              <Draggable key={item.id} draggableId={item.id} index={index}>
                {(provided) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    {item.content}
                  </div>
                )}
              </Draggable>
            ))}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>
  );
}
```

**체크 포인트**

- 각 컴포넌트에 유닉한 id를 지정해줘야 한다.
- `key`와 `droppableId`, `draggableId`는 같아야 한다!
- `Droppable`의 `provided`와 `Draggable`의 `provided`는 다른 녀석임을 유의해야 한다.

<br />

아래 내용들은 그냥 넘어가도 무방합니다.

### Droppable 파헤치기

```tsx
<Droppable droppableId="droppable">
  {(provided, snapshot) => (
    <div ref={provided.innerRef} {...provided.droppableProps}>
      {...}
      {provided.placeholder}
    </div>
  )}
</Droppable>
```

**`droppableId`**

- 드롭 가능한 영역을 구분할 id를 표시한다. `ex) todo, doing, done`
- ID가 유닉하지만 재활용된다면 [버그](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/identifiers.md)를 일으킬 수 있다.

**`provided`**

- [참고](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md#1-provided-droppableprovided)
- `provided.innerRef`
  - 라이브러리에서 우리 컴포넌트 DOM을 조작하기 위해서 **필수**로 등록해줘야 한다.
- `provided.droppableProps`
  - It currently contains data attributes that we use for styling and lookups.
  - 그냥 우리가 전달한 `props`를 라이브러리에서 사용할 수 있는 형태로 DOM data에 등록시켜주는 것 같다.
  - ![](https://velog.velcdn.com/images/bepyan/post/3b6649d3-6396-44ea-acc0-da03b00a0dc1/image.png)
- `provided.placeholder`
  - This is used to **create space** in the `<Droppable />` as needed during a drag.
  - drop될 때 공간을 만들기 위해서 필요하다고 한다. ~~없어도 동작은 되는 것 같긴하다...~~

**`snapshot`**

- [참고](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md#2-snapshot-droppablestatesnapshot)
- `snapshot.isDraggingOver`
  - 이름 그대로, 이를 통해서 아이템을 올려놀 수 있을 때 스타일을 추가할 수 있다.
    ```tsx
      {(provided, snapshot) => (
        <div
            ref={provided.innerRef}
            {...provided.droppableProps}
            style={{ background: snapshot.isDraggingOver ? 'red' : 'blue' }}
        >
          {...}
          {provided.placeholder}
        </div>
      )}
    ```
- `draggingOverWith`
  - id of the draggable that is dragging over the Droppable.
- `draggingFromThisWith`
  - id of the draggable that is dragging from this list.
- `isUsingPlaceholder`
  - Whether or not the placeholder is actively being used. (useful with virtual lists)

<br />
<br />

### Draggable 파헤치기

```tsx
{
  items.map((item, index) => (
    <Draggable key={item.id} draggableId={item.id} index={index}>
      {(provided, snapshot) => (
        <div ref={provided.innerRef} {...provided.draggableProps} {...provided.dragHandleProps}>
          {item.content}
        </div>
      )}
    </Draggable>
  ));
}
```

**`draggableId`**

- droppableId와 같다.

**`index`**

- 리스트의 순서대로 입력해야 한다. `⛔️ [1,2,4,8]`

**`provided`**

- [참고](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/draggable.md#1-provided-draggableprovided)
- `provided.innerRef`
  - droppable와 같다.
- `provided.draggableProps`
  - contains a data attribute and **an inline style**.
  - drag 스타일을 등록해주는 역할이다. 이게 없다면 엘리먼트가 움직이지 않을 것이다.
- `provided.dragHandleProps`
  - drag handle를 등록해주는 인자인데 살펴보면 내부로직이 어떻게 구현했는지 조금 힌트를 얻을 수 있다.
  - `data-rbd-drag-handle-draggable-id`
  - `data-rbd-drag-handle-context-id`
  - `aria-labelledby`
    - screen reader가 연관된 엘리먼트를 읽을 수 있도록 해준다.
  - `tabIndex`
    - 키보드 탭으로 엘리먼트를 접근할 수 있게 해준다.
  - `draggable`
  - `onDragStart`
    - onDragStart를 통해서 이벤트를 등록해준다.

**`snapshot`**

- [참고](https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/draggable.md#2-snapshot-draggablestatesnapshot)
- `snapshot.isDragging`
  - 인라인으로 스타일을 수정시 `provided.draggableProps.style`도 넣어주는 것을 잃지 말자.
    ```tsx
    {
      (provided, snapshot) => (
        <div
          ref={provided.innerRef}
          {...provided.draggableProps}
          {...provided.dragHandleProps}
          style={{
            backgroundColor: snapshot.isDragging ? 'blue' : 'grey',
            ...provided.draggableProps.style,
          }}
        >
          {item.content}
        </div>
      );
    }
    ```
  - _Generally this is the only property you will be using_
  - 보통 이 속성만 사용하게 될 것이라고 한다.
  - 그렇다면 나머지는 공식문서를 참고하자...
- `snapshot.isDropAnimating`
- `snapshot.dropAnimation`
- `snapshot.draggingOver`
- `snapshot.combineWith`
- `snapshot.combineTargetFor`
- `snapshot.mode`

<br />
<br />

### onDragEnd 파헤치기

![](https://velog.velcdn.com/images/bepyan/post/5a1d7c78-e2a3-44cf-82f7-a6b8dae738de/image.gif)

보면 `source`, `destination`가 인자로 전달 받는다.
이상한 곳으로 드래그하면 `destination`이 `null`로 응답을 받는다.

여기서 특이한 점은 `draggableId`는 없고 `index`와 `droppableId`만 있다.
이것을 활용해 우리가 알아서 상태를 변경시켜야 한다.
`splice`를 활용하면 이를 쉽게 구현할 수 있다.

```tsx
const [items, setItems] = useState(
  [...Array(4)].map((_, i) => ({ id: `${i}${i}${i}`, content: `item-${i}` })),
);

const onDragEnd = ({ source, destination }: DropResult) => {
  if (!destination) return;

  // 깊은 복사
  const _items = JSON.parse(JSON.stringify(items)) as typeof items;
  // 기존 아이템 뽑아내기
  const [targetItem] = _items.splice(source.index, 1);
  // 기존 아이템을 새로운 위치에 삽입하기
  _items.splice(destination.index, 0, targetItem);
  // 상태 변경
  setItems(_items);
};
```

<br />
<br />

### 애니메이션 파헤치기

라이브러리에서는 어떻게 엘리먼트에 이동하는 효과를 줄까?

![](https://velog.velcdn.com/images/bepyan/post/c67b8126-a421-4c28-a321-deb1e1177cbb/image.gif)

1. 기존 drag된 엘리먼트에 `position: fixed`를 두고 절대적 위치를 지정해준다.
2. drag의 움직임에 따라서 `transition: translate(x, y)` 스타일을 수정해준다.
3. drag의 움직임에 따라 밀리게 되는 엘리먼트는 `transition: translate(0, y)`를 줘서 움직이게 한다.
4. `onDropEnd`에서 인자 바탕으로 우리가 DOM을 조작해줘야 한다.

스타일링하는 원리는 단순한데 내부적으로 위치를 계산하는 로직은 뭔가 복잡할 것 같다..

<br />

#### + 추가로 알게된 접근성 TMI

마크업 하단에 보면 helptext가 숨겨져 있는 것을 볼 수 있다.
아마 스크린리더에게 도움을 주기 위함인 것 같다.

![](https://velog.velcdn.com/images/bepyan/post/06fb0c2b-a94d-439a-af9e-d7fad3f0088f/image.png)

친절하게 어떤 DND 동작을 수행했는지 알려주며 키보드로 어떻게 동작을 시킬 수 있는지 알려준다.
그래서 덕분에 키보드로 DND를 하게 되었다!!

1. `tab`으로 원하는 엘리먼트 접근 한다.
2. `space`로 해당 엘리먼트를 잡는다.
3. 키보드를 통해서 엘리먼트를 이동시킨다.
4. 다시 `space`를 눌러 해당 엘리먼트를 놓다 준다. 만약 `esc`를 누르면 동작이 취소 된다.

![](https://velog.velcdn.com/images/bepyan/post/5d95dbc8-60c2-4766-b428-9eb7315a5a80/image.gif)

~~역시 대기업!!~~

---

## TODO 칸반 만들기

서론이 참 길었다...
이제 본격적으로 TODO 칸반을 만들어 보자!!

<br />

### 데이터 상태 정의

먼저 기존 상태를 정의해보도록 하자.

```ts
export type TItemStatus = 'todo' | 'doing';

export type TItem = {
  id: string;
  status: TItemStatus;
  title: string;
};

export type TItems = {
  [key in TItemStatus]: TItem[];
};

export default function TodoPage() {
  const [items, setItems] = useState<TItems>({
    todo: [...Array(5)].map((_, i) => ({
      id: `${i}${i}${i}`,
      title: `Title ${i + 1}000`,
      status: 'todo',
    })),
    doing: [],
  });

  return (
    <>
      <TodoLibraryExample items={items} setItems={setItems} />
    </>
  );
}
```

개발 편의상 아래와 같은 자료형을 넘겨주도록 하자.

```json
{
  "todo": [],
  "doing": []
}
```

<br />
<br />

### 마크업 정의

`todo`, `doing` 별로 `Droppable` 보드를 만들어 주고
각 보드마다 대응되는 `Draggable` 리스트를 만들어 준다.

```tsx
<DragDropContext>
  <div className="...">
    {Object.keys(items).map((key) => (
      <Droppable key={key} droppableId={key}>
        {(provided, snapshot) => (
          <div ref={provided.innerRef} {...provided.droppableProps}>
            {items[key as TItemStatus].map((item, index) => (
              <Draggable key={item.id} draggableId={item.id} index={index}>
                {(provided, snapshot) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    <h5>{item.title}</h5>
                  </div>
                )}
              </Draggable>
            ))}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    ))}
  </div>
</DragDropContext>
```

<br />
<br />

### 드래그 상태에 따라 스타일링

Drop 가능한 보드위에 Drag시 찐한 shadow를 추가해준다.

```tsx
<Droppable key={key} droppableId={key}>
  {(provided, snapshot) => (
    <div
      ref={provided.innerRef}
      {...provided.droppableProps}
      className={'기존 스타일 ' + (snapshot.isDraggingOver ? 'shadow-lg' : 'shadow')}
    >
      ...
    </div>
>
</Droppable>
```

Drag시 해당 아이템에 찐한 shadow를 추가해준다.

```tsx
<Draggable key={item.id} draggableId={item.id} index={index}>
  {(provided, snapshot) => (
    <div
      ref={provided.innerRef}
      {...provided.draggableProps}
      {...provided.dragHandleProps}
      className={
        '기존 스타일 ' +
          (snapshot.isDragging
           ? 'bg-opacity-90 shadow-2xl shadow-gray-400'
           : 'shadow')
      }
    >
      ...
    </div>
 </Draggable>
```

<br />
<br />

### 드래그 완료시 상태 변경

[**splice**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)는 배열에서 아이템 첨삭할 때 유용한 친구이다.
꼭 직접 다뤄보길 바란다.

```tsx
const onDragEnd = ({ source, destination }: DropResult) => {
  // 유효하지 않는 곳으로 drag시 이벤트를 종료한다.
  if (!destination) return;

  // 타입스크립트 호환되도록 타입을 지정해준다.
  const scourceKey = source.droppableId as TItemStatus;
  const destinationKey = destination.droppableId as TItemStatus;

  // 깊은 복사
  const _items = JSON.parse(JSON.stringify(items)) as typeof items;
  // drag를 시작한 리스트에서 drag한 아이템을 뺀다.
  const [targetItem] = _items[scourceKey].splice(source.index, 1);
  // drop되는 리스트에 알맞는 위치에 아이템을 추가해준다.
  _items[destinationKey].splice(destination.index, 0, targetItem);

  // 상태를 변경해준다.
  setItems(_items);
};

return (
  <>
    <DragDropContext onDragEnd={onDragEnd}>...</DragDropContext>
  </>
);
```

<br />
<br />

### 최종 코드

스타일은 [tailwind css](https://tailwindcss.com/)를 활용했다.

`./page/todo.tsx`

```tsx
import TodoLibraryExample from '@/components/todo/TodoLibraryExample';
import { useState } from 'react';

export type TItemStatus = 'todo' | 'doing';

export type TItem = {
  id: string;
  status: TItemStatus;
  title: string;
};

export type TItems = {
  [key in TItemStatus]: TItem[];
};

export default function TodoPage() {
  const [items, setItems] = useState<TItems>({
    todo: [...Array(5)].map((_, i) => ({
      id: `${i}${i}${i}`,
      title: `Title ${i + 1}000`,
      status: 'todo',
    })),
    doing: [],
  });

  return (
    <>
      <TodoLibraryExample items={items} setItems={setItems} />
    </>
  );
}
```

`./components/todo/TodoLibraryExample.tsx`

```tsx
import { TItems, TItemStatus } from '@/pages/todo';
import { $ } from '@/utils';
import { useEffect, useState } from 'react';
import { DragDropContext, Draggable, Droppable, DropResult } from 'react-beautiful-dnd';

export default function TodoLibraryExample({
  items,
  setItems,
}: {
  items: TItems;
  setItems: (items: TItems) => void;
}) {
  const onDragEnd = ({ source, destination }: DropResult) => {
    if (!destination) return;

    const scourceKey = source.droppableId as TItemStatus;
    const destinationKey = destination.droppableId as TItemStatus;

    const _items = JSON.parse(JSON.stringify(items)) as typeof items;
    const [targetItem] = _items[scourceKey].splice(source.index, 1);
    _items[destinationKey].splice(destination.index, 0, targetItem);
    setItems(_items);
  };

  // --- requestAnimationFrame 초기화
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    const animation = requestAnimationFrame(() => setEnabled(true));

    return () => {
      cancelAnimationFrame(animation);
      setEnabled(false);
    };
  }, []);

  if (!enabled) {
    return null;
  }
  // --- requestAnimationFrame 초기화 END

  return (
    <div className="p-4">
      <div className="mb-2">
        <h1 className="text-3xl font-bold">react-beautiful-dnd</h1>
        <span>with react library</span>
      </div>

      <div className="mt-4 flex">
        <DragDropContext onDragEnd={onDragEnd}>
          <div className="grid flex-1 select-none grid-cols-2 gap-4 rounded-lg">
            {Object.keys(items).map((key) => (
              <Droppable key={key} droppableId={key}>
                {(provided, snapshot) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.droppableProps}
                    className={$(
                      'flex flex-col gap-3 rounded-xl bg-gray-200 p-4 ring-1 ring-gray-300 transition-shadow dark:bg-[#000000]',
                      snapshot.isDraggingOver ? 'shadow-lg' : 'shadow',
                    )}
                  >
                    <span className="text-xs font-semibold">{key.toLocaleUpperCase()}</span>
                    {items[key as TItemStatus].map((item, index) => (
                      <Draggable key={item.id} draggableId={item.id} index={index}>
                        {(provided, snapshot) => (
                          <div
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                            className={$(
                              'rounded-lg bg-white p-4 transition-shadow dark:bg-[#121212]',
                              snapshot.isDragging
                                ? 'bg-opacity-90 shadow-2xl shadow-gray-400'
                                : 'shadow',
                            )}
                          >
                            <h5 className="font-semibold">{item.title}</h5>
                            <span className="text-sm text-gray-500">Make the world beatiful</span>
                          </div>
                        )}
                      </Draggable>
                    ))}
                    {provided.placeholder}
                  </div>
                )}
              </Droppable>
            ))}
          </div>
        </DragDropContext>
      </div>
    </div>
  );
}
```

~~생각보다 코드 길이는 짧다 ✨✨~~

![](https://velog.velcdn.com/images/bepyan/post/e3cdafef-e118-4b60-8142-0d22fc54df77/image.gif)

키보드로 조작한다면?

![](https://velog.velcdn.com/images/bepyan/post/18ef7b47-4d38-4480-a7b9-fbf6a617c8ff/image.gif)

다음 세션에서 이를 라이브러리 없이 구현해보자!!

---

참고 자료

- [https://stackoverflow.com/questions/60029734/react-beautiful-dnd-i-get-unable-to-find-draggable-with-id-1](https://stackoverflow.com/questions/60029734/react-beautiful-dnd-i-get-unable-to-find-draggable-with-id-1)
- [https://velog.io/@seohee0112/React-beautiful-dnd](https://velog.io/@seohee0112/React-beautiful-dnd)
- [https://codesandbox.io/s/react-drag-and-drop-react-beautiful-dnd-forked-d44ub5?file=/src/index.js](https://codesandbox.io/s/react-drag-and-drop-react-beautiful-dnd-forked-d44ub5?file=/src/index.js)

---

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/todo

전체 코드는 아래 깃허브 링크에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/blob/main/src/components/todo/TodoLibraryExample.tsx
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="react-beautiful-dnd"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[라이브러리없이 DND TODO 칸반보드 만들기]]></title>
        <id>/blog/dnd-master/7-drag-and-drop-todo</id>
        <link href="https://bepyan.github.io/blog/dnd-master/7-drag-and-drop-todo"/>
        <updated>2022-10-25T15:07:04.000Z</updated>
        <summary type="html"><![CDATA[라이브러리 없이 React에서 Drag and Drop TODO 칸반 보드를 구현해보자!!!]]></summary>
        <content type="html"><![CDATA[
대망으로 라이브러리 도움 없이 Drag and Drop이 지원되는 TODO 리스트를 만들어 보자!
[지난 포스트](./drag-evnet)에 이어서 React에 Vanilla 스크립트를 붙여서 기능을 구현해봤다.

작업 후기에 대해 먼저 나누자면,,
**왠만하면 라이브러리를 통해서 기능을 구현하자...**

React의 DOM 조작과 Vanilla의 DOM 조작이 생각보다 잘 충돌이 되어서 너무 골치가 아팠다..
~~처음부터 Vanilla로 할껄 ㅠㅠㅠ 😭~~
생각치 못한 이슈들이 계속 발생되었고 이를 깔끔하게 처리하기 너무 어려웠다.
라이브러리 제작자분들이 진짜 리스빽한다..
그래도 어느정도 만족스로운 결과물을 만들어서 겨우 마무리 짓기로 했다.

<br />

동작의 큰 흐름을 살펴보면 아래와 같이 정리가 될 것 같다.

- **마크업 선언** 및 document에 **이벤트 등록**
- **drag시**
  - drag된 element를 클론하여 `ghost`를 생성하고 기존 element에 `placeholder` 적용한다.
- **move시**
  - 커서에 따라 `ghost`가 움직이도록 한다.
  - drop이 가능한 새로운 보드에 도착시 `placeholder`를 해당 보드 끝에 이동시킨다.
  - item에 이동시 상황에 따라 `placeholder`와 `item`들의 위치를 `transform`한다.
- **drop시**
  - `ghost`를 `placeholder` 자리로 되돌아가도록하고 제거한다.
  - `source` `destination` 정보를 callback으로 전달해주고 상태를 변경시킨다.

---

## 마크업 및 이벤트 등록

모바일 기기에서도 터치 드래그가 가능하도록 세팅하고 `useEffect`에 등록한다.  
코드가 좀 길어서 과감하게 넘어가도록 하자.

**`TodoExample.tsx`**

```tsx
import { Dispatch, SetStateAction, useEffect, useState } from 'react';
import registDND from './TodoExample.drag';

export type TItemStatus = 'todo' | 'doing';

export type TItem = {
  id: string;
  status: TItemStatus;
  title: string;
  index: number;
};

export type TItems = {
  [key in TItemStatus]: TItem[];
};

export default function TodoExample() {
  const [items, setItems] = useState<TItems>({
    todo: [...Array(5)].map((_, i) => ({
      id: `${i}${i}${i}`,
      title: `Title ${i + 1}000`,
      status: 'todo',
      index: i,
    })),
    doing: [],
  });

  useEffect(() => {
    const clear = registDND(({ source, destination }) => {
      if (!destination) return;

      const scourceKey = source.droppableId as TItemStatus;
      const destinationKey = destination.droppableId as TItemStatus;

      setItems((items) => {
        const _items = JSON.parse(JSON.stringify(items)) as typeof items;
        const [targetItem] = _items[scourceKey].splice(source.index, 1);
        _items[destinationKey].splice(destination.index, 0, targetItem);
        return _items;
      });
    });
    return () => clear();
  }, [setItems]);

  return (
    <div className="p-4">
      <div className="mt-4 flex">
        <div className="todo grid flex-1 select-none grid-cols-2 gap-4 rounded-lg">
          {Object.keys(items).map((key) => (
            <div
              key={key}
              data-droppable-id={key}
              className="flex flex-col gap-3 rounded-xl bg-gray-200 p-4 ring-1 ring-gray-300 transition-shadow dark:bg-[#000000]"
            >
              <span className="text-xs font-semibold">{key.toLocaleUpperCase()}</span>
              {items[key as TItemStatus].map((item, index) => (
                <div
                  key={item.id}
                  data-index={index}
                  className="dnd-item rounded-lg bg-white p-4 transition-shadow dark:bg-[#121212]"
                >
                  <h5 className="font-semibold">{item.title}</h5>
                  <span className="text-sm text-gray-500">Make the world beatiful</span>
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

- `react-beatiful-dnd` 처럼 콜백을 넘겨주도록 했다.
  ```json
  {
    "source": {
      "droppableId": "todo",
      "index": 1
    },
    "destination": {
      "droppableId": "doing",
      "index": 0
    }
  }
  ```
  <br />

**`TodoExample.drag.ts`**

```tsx
const isTouchScreen =
  typeof window !== 'undefined' && window.matchMedia('(hover: none) and (pointer: coarse)').matches;

const startEventName = isTouchScreen ? 'touchstart' : 'mousedown';
const moveEventName = isTouchScreen ? 'touchmove' : 'mousemove';
const endEventName = isTouchScreen ? 'touchend' : 'mouseup';

const getDelta = (startEvent: MouseEvent | TouchEvent, moveEvent: MouseEvent | TouchEvent) => {
  if (isTouchScreen) {
    const se = startEvent as TouchEvent;
    const me = moveEvent as TouchEvent;

    return {
      deltaX: me.touches[0].pageX - se.touches[0].pageX,
      deltaY: me.touches[0].pageY - se.touches[0].pageY,
    };
  }

  const se = startEvent as MouseEvent;
  const me = moveEvent as MouseEvent;

  return {
    deltaX: me.pageX - se.pageX,
    deltaY: me.pageY - se.pageY,
  };
};

export type DropItem = {
  droppableId: string;
  index: number;
};

export type DropEvent = {
  source: DropItem;
  destination?: DropItem;
};

export default function registDND(onDrop: (event: DropEvent) => void) {
  const startHandler = (startEvent: MouseEvent | TouchEvent) => {
    const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
	  // Touch 이벤트에서 moveEvent와 scrollEvent가 같이 발생되는 것을 방지한다.
      if (moveEvent.cancelable) moveEvent.preventDefault();
      ...
    }
    const endHandler = () => {...}

    // scrollEvent를 막을 수 있게 `passive: false` 해준다.
    document.addEventListener(moveEventName, moveHandler, { passive: false });
    document.addEventListener(endEventName, endHandler, { once: true });
  }

  document.addEventListener(startEventName, startHandler);
  return () => document.removeEventListener(startEventName, startHandler);
}
```

---

## Drag

drag된 element를 클론하여 `ghost`를 생성하고 기존 element에 `placeholder` 적용한다.
로직은 [**DND-이벤트-뽀개기**](https://velog.io/@bepyan/DND-이벤트-뽀개기)에서와 같기 때문에 간단히 코드만 보고 넘어가도록 하자.

```tsx
const startHandler = (startEvent: MouseEvent | TouchEvent) => {
  const item = (startEvent.target as HTMLElement).closest<HTMLElement>('.dnd-item');

  if (!item || item.classList.contains('moving')) {
    return;
  }

  // 초기 item의 위치, 크기 정보를 미리 할당해놓는다.
  const itemRect = item.getBoundingClientRect();

  const ghostItem = item.cloneNode(true) as HTMLElement;
  ghostItem.classList.add('ghost');
  ghostItem.style.position = 'fixed';
  ghostItem.style.top = `${itemRect.top}px`;
  ghostItem.style.left = `${itemRect.left}px`;
  ghostItem.style.width = `${itemRect.width}px`;
  ghostItem.style.height = `${itemRect.height}px`;
  ghostItem.style.pointerEvents = 'none';

  ghostItem.style.border = '2px solid rgb(96 165 250)';
  ghostItem.style.opacity = '0.95';
  ghostItem.style.boxShadow = '0 30px 60px rgba(0, 0, 0, .2)';
  ghostItem.style.transform = 'scale(1.05)';
  ghostItem.style.transition = 'transform 200ms ease, opacity 200ms ease, boxShadow 200ms ease';

  item.classList.add('placeholder');
  // `global.css`
  //  .todo .dnd-item.placeholder {
  //    @apply border border-blue-500 opacity-50 ring-2 ring-blue-400;
  //  }
  item.style.cursor = 'grabbing';

  document.body.style.cursor = 'grabbing';
  document.body.appendChild(ghostItem);

  //...
};
```

<br />

`onDrop`에서 값을 넘겨주기 위한 변수를 정의한다.

```tsx
let destination: HTMLElement | null | undefined;
let destinationItem: HTMLElement | null | undefined;
let destinationIndex: number;
let destinationDroppableId: string;

const source = item.closest<HTMLElement>('[data-droppable-id]');
if (!source) return console.warn('Need `data-droppable-id` at dnd-item parent');
if (!item.dataset.index) return console.warn('Need `data-index` at dnd-item');
// 다른 보드로 이동시 생성하는 임시 sourceItem
let movingItem: HTMLElement;
const sourceIndex = Number(item.dataset.index);
const sourceDroppableId = source.dataset.droppableId!;
```

<br />

기타 아이템들이 살아 움직일 수 있도록 style 세팅도 해주자.

```tsx
document.querySelectorAll<HTMLElement>('.dnd-item:not(.ghost)').forEach((item) => {
  item.style.transition = 'all 200ms ease';
});
```

---

## Move

커서의 움직임에 따라 `ghost`가 움직이도록 한다.

```tsx
const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
  //...
  const { deltaX, deltaY } = getDelta(startEvent, moveEvent);
  ghostItem.style.top = `${itemRect.top + deltaY}px`;
  ghostItem.style.left = `${itemRect.left + deltaX}px`;
  //...
};
```

<br />

`ghost` 중심 위치에 어떤 엘리먼트가 있는지 확인하여 `DND`에 관련 된 값을 추출해낸다.

```tsx
const ghostItemRect = ghostItem.getBoundingClientRect();

const pointTarget = document.elementFromPoint(
  ghostItemRect.left + ghostItemRect.width / 2,
  ghostItemRect.top + ghostItemRect.height / 2,
);

const currentDestinationItem = pointTarget?.closest<HTMLElement>('.dnd-item');
const currentDestination = pointTarget?.closest<HTMLElement>('[data-droppable-id]');
const currentDestinationDroppableId = currentDestination?.dataset.droppableId;
const currentDestinationIndex = Number(currentDestinationItem?.dataset.index);

const currentSourceItem = movingItem ?? item;
const currentSourceIndex = Number(currentSourceItem.dataset.index);
const currentSource = currentSourceItem.closest<HTMLElement>('[data-droppable-id]')!;
const currentSourceDroppableId = currentSource.dataset.droppableId;
```

<br />

기존 `hover`된 보드 스타일을 제거해주고,
현재 `drop`이 가능한 보드위에 있을 경우 해당 보드에 `hover` 이벤트를 추가해준다.

```tsx
// 이후 endHandler 이벤트에서도 사용되기에 재사용할 수 있도록 메소드를 추출해준다.
const clearDroppableShadow = () => {
  document.querySelectorAll<HTMLElement>('[data-droppable-id]').forEach((element) => {
    element.style.boxShadow = 'none';
  });
};

const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
  //...
  clearDroppableShadow();
  if (currentDestination) {
    currentDestination.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
  }
  //...
};
```

<br />

같은 위치에 있을 때, 타겟 엘리먼트가 움직이고 있을 땐 이후 동작을 수행하지 않는다.

```tsx
if (
  currentDestinationItem?.isSameNode(currentSourceItem) ||
  currentDestinationItem?.classList.contains('moving')
) {
  return;
}
```

<br />

이제부터 핵심 로직이다.

### 핵심 로직 — 다른 보드로 placeholder 이동시키기

개발 편의상, `drop`이 가능한 보드로 이동시 `placeholder`를 해당 보드 끝으로 이동시키기로 했다.

![](https://velog.velcdn.com/images/bepyan/post/23a51d92-1d9d-40da-824a-dae5779f4dd6/image.gif)

위 상황과 같이 아이템 위치까지 이동하기 전에 무조건 보드 위로 진입할거라고 생각했다.
~~결국 버그를 유발하는 원인이 되었다.~~

```tsx
if (
  currentDestination &&
  currentDestinationDroppableId &&
  currentDestinationDroppableId !== currentSourceDroppableId
) {
  if (!movingItem) {
    // 💥 react element의 위치를 이동시키면 react에서 node를 추적할 수 없어 ERROR가 발생된다.
    // 이를 해결하기 위해 눈속임 들어갑니다~!
    movingItem = item.cloneNode(true) as HTMLElement;
    item.classList.remove('dnd-item');
    item.style.display = 'none';
  }

  // 보드 끝에 placeholder를 추가한다.
  currentDestination.appendChild(movingItem);

  // 보드 끝 기준으로 도착지 정보를 갱신해준다.
  destination = currentDestination;
  destinationDroppableId = currentDestinationDroppableId;
  destinationIndex = currentDestination.querySelectorAll('.dnd-item').length - 1;

  // 보드들의 index 정보들을 갱신해준다.
  currentDestination.querySelectorAll<HTMLElement>('.dnd-item').forEach((v, i) => {
    v.dataset.index = i + '';
    v.style.transform = '';
    v.classList.remove('moved');
  });
  currentSource.querySelectorAll<HTMLElement>('.dnd-item').forEach((v, i) => {
    v.dataset.index = i + '';
    v.style.transform = '';
    v.classList.remove('moved');
  });
}

// 만약 위치를 바꿀 타겟이 없다면 이후 동작을 수행하지 않는다.
if (!currentDestinationItem) {
  return;
}
```

이제 도착지 기준으로 item들의 위치를 조정해주면 된다.

---

### 핵심 로직 — item들의 위치를 조정해주기

우선 item의 높이가 고정 되었다고 생각했을 때 이동되어야할 거리를 계산해보자.

```tsx
const ITEM_MARGIN = 12;
const distance = itemRect.height + ITEM_MARGIN;
```

![](https://velog.velcdn.com/images/bepyan/post/b3fa48c4-aece-488f-9add-122a0baf59fe/image.png)

이제 `index`의 차이 바탕으로 `item`들을 이동시키면 된다.

```ts
const transX = indexDiff * distance;
currentSourceItem.style.transform = `translate3d(0, ${transX}px, 0)`;
```

`source index`과 `destination index` 사이에 있는 `item`들은 한 칸씩 이동시키면 된다.
그럼 여러가지 경우의 수에 대해서 고려해보자.
![](https://velog.velcdn.com/images/bepyan/post/ed98922d-5ca4-4796-869b-9297d28cab40/image.png)

**위에서 아래로 이동할 경우** (`index: 0` → `index: 2`)
`Title 1000`는 아래 방향으로 두 칸 이동한다. `(2 - 0) * distance`
`Title 2000` `Title 3000`은 위 방향으로 한 칸 이동한다. `1 * -distance`

**아래에서 위로 이동할 경우** (`index: 2` → `index: 0`)
`Title 3000`는 위 방향으로 두 칸 이동한다. `(0 - 2) * -distance`
`Title 1000` `Title 2000`은 아래 방향으로 한 칸 이동한다. `1 * distance`

**위에서 아래로 이동후 다시 위로 이동할 경우** (`index: 0` → `index: 2` → `index: 1`)
다시 위로 이동하는 시점에서 `index`가 꼬이기에 다르게 동작되어야 한다.

<img
  src="https://velog.velcdn.com/images/bepyan/post/2626c24b-9558-4825-83c1-574cfb54cb29/image.png"
  width="350px"
/>

다시 올라가는 경우, `index` 차이에서 `1`만큼 더 차이나면 된다.
`Title 1000`는 위 방향으로 두 칸 이동한다. `(0 - 1 - 1) * -distance`
`Title 2000` `Title 300`는 아래 방향으로 한 칸 이동한다. `1 * distance`

애니메이션을 제거하여 보면 이와 같이 동작할 것이다.

![](https://velog.velcdn.com/images/bepyan/post/6b150c0d-6c9d-4306-bf40-ea0d6e8560df/image.gif)

코드는 아래와 같이 작성했다.

```tsx
// 도착지 정보를 target item 기준으로 갱신해준다.
destinationItem = currentDestinationItem;
destination = currentDestinationItem.closest<HTMLElement>('[data-droppable-id]');
destinationDroppableId = destination?.dataset.droppableId + '';

let indexDiff = currentDestinationIndex - currentSourceIndex;
// 위에서 아래로 간다면 (ex. index 1 -> 3)
const isForward = currentSourceIndex < currentDestinationIndex;
// 움직였던 item으로 다시 움직이는지 여부
const isDestinationMoved = destinationItem.classList.contains('moved');

if (isDestinationMoved) {
  indexDiff += isForward ? -1 : 1;
}

destinationIndex = currentSourceIndex + indexDiff;

// indexDiff만큼 placeholder를 이동시킨다.
const transX = indexDiff * distance;
currentSourceItem.style.transform = `translate3d(0, ${transX}px, 0)`;

// indexDiff 사이에 있는 item들을 이동시킨다.
let target = currentDestinationItem;
while (
  target &&
  target.classList.contains('dnd-item') &&
  !target.classList.contains('placeholder')
) {
  if (isDestinationMoved) {
    target.style.transform = '';
    target.classList.remove('moved');
    target = (isForward ? target.nextElementSibling : target.previousElementSibling) as HTMLElement;
  } else {
    target.style.transform = `translate3d(0, ${isForward ? -distance : distance}px, 0)`;
    target.classList.add('moved');
    target = (isForward ? target.previousElementSibling : target.nextElementSibling) as HTMLElement;
  }
}
```

<br />

`startHandler`에서 추가해줬던 `item.style.transition = 'all 200ms ease'`에 의해서 `item`들이 `200ms`을 거쳐 밀려나는 동안 다시 target으로 트리거되지 않도록 `moving` 클래스명을 추가해주고 끝나면 다시 제거해준다.

```tsx
currentDestinationItem.classList.add('moving');
currentDestinationItem.addEventListener(
  'transitionend',
  () => {
    currentDestinationItem?.classList.remove('moving');
  },
  { once: true },
);
// 빈번하게 발생될시 transitionend이 트리거되지않을 수 있어 setTimeout으로도 수행하도록 했다.
setTimeout(() => {
  currentDestinationItem?.classList.remove('moving');
}, 200);
```

![](https://velog.velcdn.com/images/bepyan/post/f5daa7d3-a98e-46e4-b7e7-53580d5ab9b2/image.gif)

---

## Drop

클릭, 터치를 뗐을 때 `endHandler`가 수행된다.

```tsx
const endHandler = () => {
  //...
  document.removeEventListener(moveEventName, moveHandler);
};
```

`ghost`를 `placeholder` 자리로 되돌아가도록 한다.

```tsx
const sourceItem = movingItem ?? item;
// 미관상 placehoder 스타일을 바로 제거해준다.
item.classList.remove('placeholder');
movingItem?.classList.remove('placeholder');

// 초기 지정했던 doucment의 cursor를 초기화 한다.
document.body.removeAttribute('style');
// 모든 보드의 `hover` 상태를 초기화 한다.
clearDroppableShadow();

const itemRect = sourceItem.getBoundingClientRect();
ghostItem.classList.add('moving');
ghostItem.style.left = `${itemRect.left}px`;
ghostItem.style.top = `${itemRect.top}px`;
ghostItem.style.opacity = '1';
ghostItem.style.transform = 'none';
ghostItem.style.borderWidth = '0px';
ghostItem.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.15)';
ghostItem.style.transition = 'all 200ms ease';
```

<br />

`ghost`가 완전히 `placehoder`로 되돌아가게 되었을 때 `ghost`를 제거해주고,
`style` 상태를 초기화하고,
`source` `destination` 정보를 `callback`으로 전달해준다.

```tsx
ghostItem.addEventListener(
  'transitionend',
  () => {
    ghostItem.remove();

    // 💥 react rerender 이후로 실행되도록하는 꼼수
    setTimeout(() => {
      // transform 된 item들을 초기화 해준다.
      document.querySelectorAll<HTMLElement>('.dnd-item').forEach((item) => {
        item.removeAttribute('style');
        item.classList.remove('moving', 'moved');
      });

      // 꼼수를 위해 숨겨놓은 item을 되돌린다.
      item.classList.add('dnd-item');
      item.removeAttribute('style');
      movingItem?.remove();
    }, 0);

    // DND 정보를 최종적으로 callback으로 전달해준다.
    onDrop({
      source: {
        droppableId: sourceDroppableId,
        index: sourceIndex,
      },
      destination: destination
        ? {
            droppableId: destinationDroppableId,
            index: destinationIndex,
          }
        : undefined,
    });
  },
  { once: true },
);
```

<br />

이제 콜벡을 통해서 react 상태를 변경해주면 끝이다!

```tsx
registDND(({ source, destination }) => {
  if (!destination) return;

  const scourceKey = source.droppableId as TItemStatus;
  const destinationKey = destination.droppableId as TItemStatus;

  setItems((items) => {
    const _items = JSON.parse(JSON.stringify(items)) as typeof items;
    const [targetItem] = _items[scourceKey].splice(source.index, 1);
    _items[destinationKey].splice(destination.index, 0, targetItem);
    return _items;
  });
});
```

진짜 끝이다!!!!! 🏄🏻‍♂️

![](https://velog.velcdn.com/images/bepyan/post/883f3381-ce39-4469-8099-1f7566c2175b/image.gif)

> `횡방향 DND`, `동적인 item 높이`, `키보드 접근성` 등 추가되어야할 부분이 상당히 많지만,,
> 더 이상 작업할 여력이 없어 DND 시리즈를 이번 포스트로 마무리합니다.
>
> 부족함이 많았던 DND 시리즈에 관심을 주시고 긴 길을 끝까지 읽어주셔서 정말 감사합니다! (\_ \_)
> 그럼 `20000` 👋🏻

---

참고
https://www.uriports.com/blog/easy-fix-for-intervention-ignored-attempt-to-cancel-a-touchmove-event-with-cancelable-false/

실제 동작은 아래 링크에서 볼 수 있습니다.
https://dnd-playground.vercel.app/todo

전체 코드는 아래 깃허브 링크에서 살펴보면 됩니다.
https://github.com/bepyan/dnd-playground/blob/main/src/components/todo/TodoLibraryExample.tsx
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="DOM"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DND 마스터리]]></title>
        <id>/blog/dnd-master</id>
        <link href="https://bepyan.github.io/blog/dnd-master"/>
        <updated>2022-10-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Drag and Drop 이벤트를 라이브러리 없이 구현해서 활용해봅니다.]]></summary>
        <content type="html"><![CDATA[
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[기술 블로그를 만들 때 고려해야 할 점]]></title>
        <id>/blog/nextjs-blog/1-boilerplate</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/1-boilerplate"/>
        <updated>2022-11-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[블로그를 만들 때 어떤 것들을 고려해야 할까? 🤔]]></summary>
        <content type="html"><![CDATA[
블로그를 만드는데 생각보다 고려해야할 사항이 많습니다.
어떤 레이아웃을 갖어야 할지, 기능을 어디까지 제공해줘야 할지, 리소스를 어떻게 관리할지...
그 중 SEO를 잘 처리하는 것이 가장 중요한 것 같습니다. 사람들이 검색을 통해서 블로그로 유입되기 때문입니다.

---

## 블로그 제작 과정

블로그 제작 과정을 요약해보면 고려해야할 점을 자연스럽게 알게 됩니다.

### 1. 기본 레이아웃 세팅 (+ 반응형)

다양한 블로그를 탐방하면서 참고하기 좋은 레퍼런스를 기록해두면 좋습니다.
결국 모방하면서 나만의 레이아웃을 구축할 수 있게 되기 때문이죠.
저는 아래 블로그들에서 영감을 얻었습니다.

- https://yceffort.kr/pages/1
- https://blog.shiren.dev/
- https://leerob.io/
- https://ped.ro/
- https://blog.toss.im/
- ...

### 2. 디랙토리 기반으로 페이지 생성

마크다운 파일 디랙토리 기반을 블로그 페이지를 생성하게 됩니다.
따라서 디랙토리 구조 또한 사전에 잘 설계를 해야 합니다.

보통 날짜 기반으로 유닉한 디랙토리를 생성합니다.

```:/2022/11/example
posts
ㄴ 2022
   ㄴ 11
      ㄴ example.mdx
```

### 3. 마크다운 파일을 HTML 파일로 파싱

[`remark`](https://github.com/remarkjs/remark/blob/main/doc/plugins.md)과 [`rehype`](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md)를 활용해서 마크다운 파일을 파싱할 수 있습니다.
추가로 [**mdx**](https://mdxjs.com/)을 활용하여 마크다운 파일에서도 jsx 컴포넌트를 사용할 수 있습니다.

### 4. 사이트 자동 배포 구축

[**github pages**](https://pages.github.com/)에 무료로 호스팅을 할 수 있습니다.
Github Action을 통해서 commit을 push시 자동으로 배포되도록 합니다.

### 5. SEO 최적화 + 검색엔진 등록

크롤러에게 HTML 문서의 주요 정보를 제공해주면 검색엔진 등록, SNS 공유시 도움이 됩니다.
대표적으로 Open Graph을 활용하는 방법이 있습니다.

```html
<meta property="og:url" content="" />
<meta property="og:title" content="" />
<meta property="og:description" content="" />
<meta property="og:image" content="" />
```

자세한 내용은 인터넷에서 참고 바랍니다.
https://blog.ab180.co/posts/open-graph-as-a-website-preview

### 6. 추가 기능 붙이기

- 댓글
- 이미지 랜더링 최적화
- 이미지 삽입 최적화
- 이미지 확대
- TOC 배너
- 다크모드
- ...

---

## 기술 스택 선정하기

개인 블로그는 생각보다 유지보수에 많은 시간을 쏟아야 합니다.
따라서 자신에게 친숙한 도구를 사용하는게 좋습니다.

저는 여러 기능을 첨가하고 조금은 복잡한 UI를 만들 것이기 때문에 `typescript`를 사용했고,
레이아웃을 쉽게 구축하기 위해 `tailwindcss`를 사용했고,
개인적으로 친숙한 `React` 기반의 프레임워크를 사용하기로 했습니다.

---

### Gatsby vs Next.js

사실 둘러보면 대체로 Gastby로 블로그 만드는 것을 볼 수 있습니다.
[**gastby-plugin**](https://www.gatsbyjs.com/plugins)에서 마법같은 기능들을 제공해줘서 쉽게 블로그를 구축할 수 있기 때문입니다.
하지만 graphQL에 의존적이여 불필요하게 웹앱이 무겁게 돌아가고 라이브러리 버전업에 취약합니다.
gastby 버전을 올리는 순간 기존 플로그인들이 대거 충돌됩니다.

Next.js는 이에 비해 훨씬 유연하고 의존성에 덜 취약합니다.
요즘 커뮤니티도 훨씬 활성화 되어 있고 [**nextra**](https://nextra.site/) 같은 site generation 프레임워크도 있습니다.

다만 만약 **static-html**(github pages, nestify)를 생각한다면 [**Nextjs Unsupported Features**](https://nextjs.org/docs/advanced-features/static-html-export#unsupported-features)에 대해서 꼭 확인하시길 바랍니다.
vercel에 배포하는 것이 정신 건강에 의로울 수 있습니다.

---

그럼 자세히 어떻게 만드는지 살펴보도록 합시다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 글 페이지 만들기]]></title>
        <id>/blog/nextjs-blog/2-blog-list</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/2-blog-list"/>
        <updated>2022-11-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[glob를 활용하여 디랙토리 기반으로 페이지들을 생성해보자 🤔]]></summary>
        <content type="html"><![CDATA[
**glob patterns**를 활용하여 쉽게 파일을 탐색할 수 있습니다.
터미널에서 `ls src/**/*.tsx`을 입력하면 어떤 결과가 나올지 쉽게 유추하실 수 있을 것입니다.
다양한 언어에서 이를 지원하고 있으며 NodeJS 환경에서도 이를 활용할 수 있습니다.

```shell
yarn add -D glob @types/glob
```

---

## 디랙토리 파싱

`posts` 하위에 있는 모든 `mdx` 파일을 추출합니다.
`/posts/2022/10/test.mdx` 파일이 `/posts/2022/11/test` 페이지를 생성되도록 적절히 파싱합니다.

```ts:libs/post.ts {8}
import { sync } from 'glob';
import path from 'path';

const BASE_PATH = '/posts';
const POSTS_PATH = path.join(process.cwd(), BASE_PATH);

export const getAllPosts = () => {
  const postPaths: string[] = sync(`${POSTS_PATH}/**/*.mdx`);
  return postPaths.map((path) => {
    return {
      slug: path.slice(path.indexOf(BASE_PATH)).replace('.mdx', ''),
    };
  });
};
```

---

## 페이지 생성

[**NextJS Dynamic Routes**](https://nextjs.org/docs/routing/dynamic-routes#catch-all-routes)를 활용하여 쉽게 페이지를 생성할 수 있습니다.

`/posts/2022/11/test` 경로에서 `/posts/` 이후에 부분이 동적으로 변동되기에 `catch-all-routes` 패턴을 활용하면 됩니다.
`params`에 `string[]`타입의 변수가 전달받게 됩니다.

```tsx:pages/blog/[...slugs].tsx {17}
import { GetStaticPaths, GetStaticProps } from 'next';

import { getAllPosts } from '../../libs/post';

export const getStaticPaths: GetStaticPaths = () => {
  const posts = getAllPosts();

  return {
    paths: posts.map((post) => post.slug),
    fallback: 'blocking',
  };
};

export const getStaticProps: GetStaticProps = ({ params }) => {
  const { slugs } = params as { slugs: string[] };

  const slug = `/posts/${[...slugs].join('/')}`;
  const post = getAllPosts().find((post) => post.slug === slug);

  if (!post) {
    return {
      notFound: true,
    };
  }

  return {
    props: {
      slug,
    },
  };
};

export default function PostPage({ slug }: { slug: string }) {
  return <div>{slug}</div>;
}
```

잘못된 접근에는 `{ notFound: true }`를 리턴하여 404 페이지가 띄워지게 합니다.

---

## 글 목록 생성

글 목록 또한 이를 활용하여 쉽게 생성할 수 있습니다.

```tsx:pages/posts/index.tsx
import { getAllPosts } from '../../libs/post';

export const getStaticProps = () => {
  return {
    props: {
      posts: getAllPosts(),
    },
  };
};

export default function PostsPage({ posts }: { posts: { slug: string }[] }) {
  return (
    <ul>
      {posts.map((post, i) => (
        <li key={i}>{post.slug}</li>
      ))}
    </ul>
  );
}
```

---

현재는 글 경로 정보만 알 수 있는 상황입니다.
글의 제목, 생성일 등 추가정보를 어떻게 파싱할 수 있을지는 다음 글에서 살펴보도록 합시다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="glob"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 글의 추가 정보 파싱하기]]></title>
        <id>/blog/nextjs-blog/2-blog-listInfo</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/2-blog-listInfo"/>
        <updated>2022-11-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[gray-matter, reading-time 등을 활용하여 글에 대한 추가 정보를 알아내자.]]></summary>
        <content type="html"><![CDATA[
다양한 플랫폼을 참고해보면 글 리스트에서 다양한 데이터가 첨부되어 있습니다.

![230109-010815](/images/posts/2-blog-listInfo/230109-010815.png)

- 글 제목
- 글 설명
- 글 작성 시간
- 태그
- ...

---

## 사용하게 될 라이브러리 소개

```shell
yarn add dayjs
yarn add -D gray-matter reading-time
```

---

### gray-matter

https://github.com/jonschlinkert/gray-matter

텍스트 중 [`front-matter`](https://jekyllrb.com/docs/front-matter/)를 파싱해주는 도구입니다.
보통 여기에 글에 대한 추가정보를 작성해둡니다.

```yaml
---
title: 포스트 제목
---
```

사실 이후에 mdx 파일을 html 파일로 파싱할 `next-mdx-remote` 라이브러리에서 `front-matter`도 추출할 수 있습니다. 하지만 `front-matter`만 알고 싶은데 일일이 html 파일로 파싱하는 것은 너무 비효율적인 작업입니다.

---

### dayjs

https://github.com/iamkun/dayjs/

moment보다 가볍고 쉽게 날짜를 다룰 수 있습니다.
`2023년 1월 1일 일요일`, `1년 전` 같이 한글 날짜에 대한 포멧팅도 쉽게 지원이 됩니다.

```tsx:_app.tsx
import 'dayjs/locale/ko';
import dayjs from 'dayjs';

dayjs.locale('ko');

export default function App({...}) {
  // ...
}
```

---

### reading-time

https://github.com/ngryman/reading-time

`markdown` 혹은 `html`의 **읽기 추정 시간**을 계산해 줍니다.
한글은 조금 글게 측정되는 경향이 있는 것 같습니다.

---

## 글 파싱

이제 지난 글에서 작성했던 코드 기반으로 이어서 작업해봅시다.

```ts:libs/posts.ts
import { sync } from 'glob';
import path from 'path';

const BASE_PATH = '/posts';
const POSTS_PATH = path.join(process.cwd(), BASE_PATH);

const parsePost = (postPath: string) => {
  return {
    // ...
  }
}

export const getAllPosts = () => {
  const postPaths: string[] = sync(`${POSTS_PATH}/**/*.mdx`);
  return postPaths.map(parsePost);
};
```

---

### 파싱할 데이터 정의

어떤 데이터를 표시할지 미리 구상을 해둬야 합니다.
우선 아래 데이터가 파싱되도록 타입을 정의해봅니다.

```ts
type PostMatter = {
  title: string;
  description: string;
  tags: string[];
  draft?: boolean;
  date: string;
};

type Post = PostMatter & {
  slug: string;
  content: string;
  readingMinutes: number;
  wordCount: number;
};
```

---

### 데이터 파싱

`readFileSync`를 활용하여 파일을 조회하여 `gray-matter`에게 전달해주면 됩니다.

```ts:libs/post.ts
import dayjs from 'dayjs';
import fs from 'fs';
import matter from 'gray-matter';
import readingTime from 'reading-time';

//...

const parsePost = (postPath: string): Post | undefined => {
  try {
    const file = fs.readFileSync(postPath, { encoding: 'utf8' });
    const { content, data } = matter(file);
    const grayMatter = data as PostMatter;

    if (grayMatter.draft) {
      return;
    }

    return {
      ...grayMatter,
      tags: grayMatter.tags.filter(Boolean),
      date: dayjs(grayMatter.date).format('YYYY-MM-DD'),
      content,
      slug: postPath.slice(postPath.indexOf(BASE_PATH)).replace('.mdx', ''),
      readingMinutes: Math.ceil(readingTime(content).minutes),
      wordCount: content.split(/\s+/gu).length,
    };
  } catch (e) {
    console.error(e);
  }
}
```

파싱에 실패할 수 있기 때문에 `getAllPosts`에도 예외처리 해줍니다.

```ts
export const getAllPosts = () => {
  const postPaths: string[] = sync(`${POSTS_PATH}/**/*.mdx`);
  return postPaths.reduce<Post[]>((ac, postPath) => {
    const post = parsePost(postPath);
    if (!post) return ac;

    return [...ac, post];
  }, []);
};
```

---

## (번외) 글 작성 꿀팁

매번 `front-matter` 정보를 다른 글에서 복사해오긴 귀찮고 데이터 스키마가 변동될 수 있어 관리하기 어렵습니다.

vscode에 `custom snippets`을 추가해두면 도움이 될 것입니다.
아래처럼 설정하면 해당 레포에서만 단축키를 사용할 수 있게 됩니다.

```json:.vscode/mdx.code-snippets
{
  "Post Matter": {
    "prefix": ["matter", "---"],
    "description": "Output a file header with the file name and date",
    "body": [
      "---",
      "title: '$1'",
      "description: '$2'",
      "icon: ''",
      "image: ''",
      "tags:",
      "  - $3",
      "draft: false",
      "date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "---",
      "",
      "$0"
    ],
    "scope": "md,mdx"
  },
  "Current DateTime": {
    "prefix": ["current_date_time", "cdt"],
    "description": "Output current DateTime YYYY-MM-DD HH:mm:ss",
    "body": "$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND"
  },
  "Current Date": {
    "prefix": ["current_date", "cd"],
    "description": "Output current Date YYYY-MM-DD",
    "body": "$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE"
  }
}
```

![예시](https://user-images.githubusercontent.com/65283190/211207259-793fe7a0-c9b1-4bfd-b444-93eca7e9dc1e.gif)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js mdx plugin]]></title>
        <id>/blog/nextjs-blog/3-mdx-plugin</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/3-mdx-plugin"/>
        <updated>2022-11-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[`next-mdx-remote`에서 플로그인으로 이쁜 결과물을 만들자.]]></summary>
        <content type="html"><![CDATA[
## 기본 사용법

✨ [**next-mdx-remote**](https://github.com/hashicorp/next-mdx-remote)를 활용하여 markdown파일을 이쁜 HTML 코드로 변환해줍니다.  
추가로 markdown 파일에서 React 컴포넌트를 사용할 수 있는 이점이 있습니다.

```shell
yarn add next-mdx-remote
```

<br />

1. mdx 파일을 `serialize`하여 필요한 데이터를 추출하고 가공합니다.

```ts:libs/mdx.ts
import { serialize } from 'next-mdx-remote/serialize';

export const serializeMdx = (source: string) => {
  return serialize(source, {
    mdxOptions: {
      remarkPlugins: [],
      rehypePlugins: [],
      format: 'mdx',
    },
  });
};
```

- [`remark plugins`](https://github.com/remarkjs/remark/blob/main/doc/plugins.md)과 [`rehype plugins`](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md)를 활용해서 다양한 기능을 추가할 수 있습니다.

<br />

2. `getStaticProps`(빌드시점)에서 필요한 데이터를 모두 가공합니다.

```ts:[...slugs].tsx {21}
import { GetStaticPaths, GetStaticProps } from 'next';
import { serializeMdx } from '~/libs/mdx';
import { getAllPosts } from '~/libs/post';

export const getStaticPaths: GetStaticPaths = () => {
  const posts = getAllPosts();

  return {
    paths: posts.map((post) => `/blog/${post.slug}`),
    fallback: 'blocking',
  };
};

export const getStaticProps: GetStaticProps = async ({ params }) => {
  const { slugs } = params as { slugs: string[] };

  const slug = [...slugs].join('/');
  const post = getAllPosts().find((v) => v.slug === slug);
  //...

  const mdx = await serializeMdx(post.content);

  return {
    props: { mdx },
  };
};
```

<br />

3. 브라우저는 `<MDXRemote />`가 마운트되면서 데이터를 HTML로 변환합니다.

```tsx
export default function PostPage({ mdx }: { mdx: MDXRemoteSerializeResult }) {
  return (
    <div className="prose dark:prose-dark mt-4 w-full max-w-none">
      <MDXRemote {...mdx} />
    </div>
  );
}
```

---

## 기본 스타일링

### @tailwindcss/typography

https://tailwindcss.com/docs/typography-plugin

tailwind 기반으로 mdx 마크업을 스타일링하는데 기본 설정만 사용해도 충분히 이쁩니다!

```js:tailwind.config.js
module.exports = {
  theme: {
    // ...
  },
  variants: {
    typography: ['dark'],
  },
  plugins: [require('@tailwindcss/typography')],
}
```

마크다운 컴포넌트 상위에 `prose`를 꼭 씌워줘야하는 것을 잊지 않길 바랍니다!

```tsx
<div className="prose dark:prose-dark">
  <MDXRemote {...mdx} />
</div>
```

`tailwind.config.js`에서 [커스터마이징](https://tailwindcss.com/docs/typography-plugin#customizing-the-css)을 할수도 있고 `globals.css`에서도 스타일을 정의 할 수 있습니다.  
관심사에 따라 css 코드들을 분리하면 좋은 것 같습니다.

```css:globals.css
/* ... */
@import url(./code.css);
@import url(./prose.css);
/* ... */
```

```css:prose.css
.prose a {
  @apply transition-all;
}
```

---

## 필수 플러그인

변환 도구들은 모두 `server-side`에서 실행 될 것이기에 모두 `devDependency`로 설치해줍니다.

```shell
yarn add -D remark-gfm rehype-prism-plus rehype-slug rehype-autolink-headings
yarn add -D @tailwindcss/typography
```

---

### remark-gfm

https://github.com/remarkjs/remark-gfm

`GFM`(autolink literals, footnotes, strikethrough, tables, tasklists...) 문법들을 해석해주는 도구 입니다.
굉장히 기본적인 마크다운 문법을 HTML로 변환해주기에 필수로 사용해야 합니다.

---

### rehype-prism-plus

https://github.com/timlrx/rehype-prism-plus

[**prism**](https://prismjs.com/) 기반으로 코드블럭을 `syntax highlighting`해주는 도구 입니다.  
highlighting, showLineNumbers, line inserted, line deleted 등 강력크한 기능을 제공해줍니다.

```diff-js {1} showLineNumbers
function fancyAlert(arg) {
  if (arg) {
+    $.facebox({ div: '#foo' })
-    alert('#roo')
  }
}
```

하지만 코드 토큰만 해석해줄 뿐이지 스타일은 직접 씌워줘야합니다.  
prism기반의 [**다양한 테마**](https://github.com/PrismJS/prism-themes)를 적용할 수 있으니 취향 것 선택하면 됩니다.  
추가적으로 [**dracular**](https://draculatheme.com/prism) [**intellij**](https://github.com/bulenkov/Darcula) 테마를 추천드립니다.

자세한 설정은 [제 레포지토리](https://github.com/bepyan/bepyan.github.io/blob/main/src/styles/intellij-prism.css)를 참고해주시면 될 것 같습니다. ~~생각보다 복잡합니다...~~
vscode와 완벽히 똑같이 스타일링 되지 않는 점은 감안하셔야 합니다.

---

### rehype-slug, rehype-autolink-headings

[**rehype-slug**](https://github.com/rehypejs/rehype-slug)를 사용하여 headings에 id를 심어주면,  
[**rehype-autolink-headings**](https://github.com/rehypejs/rehype-autolink-headings)가 id를 통해서 anchor를 생성해줍니다.  
이를 활용하여 제목들로 바로가는 링크가 활성화되며 다양하게 응용될 수 있습니다.

참고로 이전에 많이 사용되었던 [**remark-slug**](https://github.com/remarkjs/remark-slug)는 deprecated 되었습니다.

Headings Link의 className를 아래와 같이 커스텀하게 지정할 수 있습니다.

```ts:libs/mdx.ts
import { serialize } from 'next-mdx-remote/serialize';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';

export const serializeMdx = (source: string) => {
  return serialize(source, {
    //...
    mdxOptions: {
      //...
      rehypePlugins: [
        [
          rehypeAutolinkHeadings,
          {
            properties: {
              className: ['anchor'],
            },
          },
        ],
      ],
    },
  });
};
```

기본적으로 css의 `content`를 활용해서 `anchor`를 만들 수 있습니다.

```css {11}
.prose .anchor {
  @apply invisible absolute no-underline;

  margin-left: -1em;
  padding-right: 0.5em;
  cursor: pointer;
}

.prose .anchor:after {
  @apply text-gray-300 dark:text-gray-700;
  content: '#';
}

.anchor:hover,
.prose *:hover > .anchor {
  @apply visible;
}
```

적당히 스크롤되도록 `scroll-margin-top`을 추가해주면 금상첨화입니다.

```js:tailwind.config.js
const { spacing } = require('tailwindcss/defaultTheme');

module.exports = {
  //...
  theme: {
    extend: {
      typography: (theme) => ({
        DEFAULT: {
          css: {
            //...
            'h1,h2,h3,h4': {
              'scroll-margin-top': spacing[32],
            },
          }
        }
      })
    }
  }
}
```

---

### remark-breaks

https://github.com/remarkjs/remark-breaks

기존 마크다운 문법에서는 문장 끝에 ` ` 2개 이상 입력해야 줄바꿈이 되는데 개인적으로 꽤나 불편했습니다.
해당 플러그인을 사용하면 마크다운에서 작성한대로 줄바꿈이 적용됩니다.

---

## 추천 플로그인

필요에 따라 활용도가 높은 플러그인들입니다. ~~어쩌면 필수~~

---

### remark-math, rehype-katex

```shell
yarn add -D remark-math rehype-katex
```

[remark-math](https://github.com/remarkjs/remark-math)과 [rehype-katex](https://github.com/remarkjs/remark-math/tree/main/packages/rehype-katex)를 활용하여 mdx에서 수학 수식을 사용할 수 있습니다.

---

### rehype-code-titles

https://github.com/josestg/rehype-code-title

코드블럭 제목을 생성해주는 도구입니다.

`확장자:파일명`처럼 사용하면 됩니다. &nbsp; ex. `tsx:pages/_app.tsx`

mdx에서 작성한 것이 아래와 같이 파싱됩니다.

```html
<div class="rehype-code-title">code.css</div>
<pre class="language-css">
  <code class="language-css code-highlight">
    <span class="code-line">
      <!-- ... -->
    </span>
  </code>
</pre>
```

스타일은 역시 직접 작성해줘야 합니다.

```css:code.css
.prose .rehype-code-title {
  /* ... */
  @apply rounded-t-lg border border-b-0 px-5 py-3 text-sm font-bold;
}
```

---

### remark-toc

https://github.com/remarkjs/remark-toc

`Tabel of Content`를 만들어 주는 도구 입니다.

보통 최상단에 `## TOC` 혹은 `## Table of contents`를 작성해주면 됩니다.

<br />
<br />

---

## 최종 코드

```ts:libs/mdx.ts
import { serialize } from 'next-mdx-remote/serialize';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypeCodeTitles from 'rehype-code-titles';
import rehypePrism from 'rehype-prism-plus';
import rehypeSlug from 'rehype-slug';
import remarkGfm from 'remark-gfm';
import remarkToc from 'remark-toc';

export const serializeMdx = (source: string) => {
  return serialize(source, {
    parseFrontmatter: true,
    mdxOptions: {
      remarkPlugins: [remarkToc, remarkGfm],
      rehypePlugins: [
        rehypeSlug,
        rehypeCodeTitles,
        rehypePrism,
        [
          rehypeAutolinkHeadings,
          {
            properties: {
              className: ['anchor'],
            },
          },
        ],
      ],
      format: 'mdx',
    },
  });
};
```

### 참고

https://yceffort.kr/2020/10/migrate-gatsby-from-nextjs  
https://colinhemphill.com/blog/fast-static-syntax-highlighting-for-mdx-in-nextjs

Project Level Snippets  
https://code.visualstudio.com/updates/v1_28#_project-level-snippets
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 Github Pages에 자동 배포하기]]></title>
        <id>/blog/nextjs-blog/4-deploy</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/4-deploy"/>
        <updated>2022-11-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Github Action을 활용하여 자동으로 Github Pages에 배포되도록 하자.]]></summary>
        <content type="html"><![CDATA[
## 레포 준비

`github pages`에 배포할 것익기 때문에 공식 문서 가이드에 따라 진행하면 됩니다.
https://pages.github.com/

아래 사항들을 주의하면 됩니다.

1. 기본적으로 github `username` 기반으로 도메인 하위에 생성된다. ex `bepyan.github.io`
2. 레포지토리 이름을 `username.github.io` 형태로 설정해야 기본 도메인에 반영된다.
3. 다른 형태의 레포지토리 이름은 하위 도메인에 반영이 된다. ex. `todo` => `bepyan.github.io/todo`
4. 레포지토리는 `public`으로 설정되어야 한다.

---

## Next.js Static HTML Export

경로 별로 html 파일을 생성하게 됩니다.

https://nextjs.org/docs/advanced-features/static-html-export

```json:packages.json
{
  "name": "bepyan.github.io",
  "version": "0.1.0",
  "private": true,
  "homepage": "https://bepyan.github.io/",
  "scripts": {
    "dev": "next dev",
    "build": "next build && next export",
    "serve": "npx http-server out",
  },
}
```

기본적으로 `yarn build`하면 결과물이 `out` 디랙토리에 생성됩니다.
`npx http-server out`을 통해서 결과물을 확인할 수 있습니다.

`static-html`에는 기본적으로 `next/image`를 지원하지 않습니다. 관련해서 오류가 뜰 수 있는데 [Next.js 블로그 Image Optimization](/6-image-optimization)를 참고 바랍니다.

---

## Github Action

기본적으로 main 브랜치에 commit이 되었을 때 배포되도록 설정할 수 있습니다.
아래 파일을 생성하면 끝입니다.

```yml:.github/main.yml
name: GitHub Pages Deploy

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v3

      - name: Install and Build 🔧
        run: |
          yarn install
          yarn build && touch ./out/.nojekyll

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages
          folder: out
```

동작원리는 단순합니다.

1. main branch에 push 되었을 때 jobs를 실행한다.
2. ubuntu(리눅스) 환경에서 레포지토리 코드를 pull 해온다.
3. packages를 설치 해주고 웹앱을 빌드해준다.
4. `touch ./out/.nojekyll` github pages jekyll 처리 과정에서 `_next` 관련 설정이 무시되지 않도록 설정해준다.
5. 빌드 결과물 `out` 디랙토리를 gh-pages 브랜치에 푸시하고 github pages에 배포한다.

지금은 배포 용도로만 사용하고 있지만 테스트 코드 시행, 맞춤법 검사, 썸네일 제작, 이미지 전처리 등 다양한 작업으로 확장할 수 있습니다.

---

저는 최종 배포까지 총 **2분 20초**가 소요되고 17MB의 파일들이 github pages에 배포 되었습니다.

![230108-214628](/images/posts/4-deploy/230108-214628.png)

![230108-214706](/images/posts/4-deploy/230108-214706.png)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="github action"/>
        <category label="github pages"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 sitemap 생성, 검색엔진 등록]]></title>
        <id>/blog/nextjs-blog/5-create-sitemap</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/5-create-sitemap"/>
        <updated>2022-11-15T22:24:41.000Z</updated>
        <summary type="html"><![CDATA[`next-sitemap` 라이브러리를 사용해서 쉽게 sitemap 만들고 검색엔진에 등록하자.]]></summary>
        <content type="html"><![CDATA[
검색엔진에 노출되기 위해선 봇들에게 우리 블로그에 어떤 페이지가 있는지 알려줘야 합니다.  
✨ [**next-sitemap**](https://github.com/iamvishnusankar/next-sitemap) 라이브러리를 통해서 모든 정적 페이지 정보가 담긴 `sitemap.xml`를 만들어 봅시다.

---

## sitemap 생성

```shell
yarn add -D next-sitemap
```

`next-sitemap.config.js`

```js
/** @type {import('next-sitemap').IConfig} */
module.exports = {
  siteUrl: 'https://bepyan.github.io',
  changefreq: 'daily',
  priority: 0.7,
  sitemapSize: 7000,
  generateRobotsTxt: true,
  exclude: [],
};
```

`package.json`

```json {3}
{
  "scripts": {
    "build": "next build && next-sitemap && next export",
    "postbuild": "next-export-optimize-images",
    "serve": "npx http-server out"
  }
}
```

여기서 주의할 점은 `next build` 실행 후 `next export` 전에 `next-sitemap` 실행 해줘야 한다는 것입니다.  
그래야 `public`에 생성된 파일들이 최종적으로 `out`에 export됩니다.

기본적으로 아래와 같은 파일들이 생성되는데요.  
`public/robots.text` `public/sitemap.xml` `public/sitemap-0.xml`  
이들이 push되지 않도록 해줍니다.

```:.gitignore
/build
/public/robots.txt
/public/sitemap*.xml
```

직접 sitemap을 생성하는 방법도 있는데요 [**여기**](/snippets/next.js/sitemap)를 참고해주시면 됩니다.
저는 검색엔진에서 자꾸 sitemap을 자동인식하지 못해서 직접 만드는 방법을 사용하게 되었습니다.

---

### 실행 결과 확인

`yarn build`를 실행하면 `out` 디랙토리에도 sitemap 관련 파일들이 추가된 것을 확인할 수 있습니다.

![221116-000505](/images/posts/5-create-sitemap/221116-000505.png)

github action에서도 잘 실행된 것을 확인할 수 있습니다.

![221115-231937](/images/posts/5-create-sitemap/221115-231937.png)

[**sitemap.xml**](/sitemap.xml)

```html
<url>
  <loc>https://bepyan.github.io</loc>
  <lastmod>2022-11-15T15:18:54.289Z</lastmod>
  <changefreq>daily</changefreq>
  <priority>0.7</priority>
</url>
```

---

## 검색엔진 등록

sitemap을 만든다고해서 끝이 나는 것이 아닙니다.  
크롤러, 봇이 블로그 글들을 수집하기 위해선 검색엔진에 사이트를 등록해줘야 합니다.

---

### Google Search Console

Google은 [**Google Search Console**](https://search.google.com/search-console/welcome?utm_source=about-page)에 등록하면 됩니다.

URL 접두어에 블로그 도메인 주소를 입력해줍니다.  
`https://bepyan.github.io/`

![221116-011827](/images/posts/5-create-sitemap/221116-011827.png)

편의상 HTML 태그 방법을 활용하도록 합니다.  
`_document.tsx` 파일에 `meta` 태그를 추가해주면 됩니다.

```tsx
import { Head, Html } from 'next/document';

export default function MyDocument() {
  return (
    <Html lang="ko">
      <Head>
        <meta name="google-site-verification" content="" />
        {/* ... */}
      </Head>
      {/* ... */}
    </Html>
  );
}
```

배포이후 `확인`을 클릭해 본인 사이트 인증을 합니다.  
인증이 성공된다면 사이트의 통계를 볼 수 있게 됩니다.

![221116-012421](/images/posts/5-create-sitemap/221116-012421.png)

정상으로 인식되기까지 정말 오래 걸린 것 같습니다.
~~영향력 없는 사이트를 대놓고 무시하는 느낌이 들기도 합니다..~~

![230107-173326](/images/posts/5-create-sitemap/230107-173326.png)

사이트맵이 정상 등록 되면 봇이 꾸준히 사이트 상태를 확인하게 되는데요.
페이지 색인이 생성되기까지도 오래 걸리는 것 같습니다. ~~일하자 구글..~~

![230107-173819](/images/posts/5-create-sitemap/230107-173819.png)

---

### Naver Search Advisor

Naver는 [**네이버 웹마스터**](https://searchadvisor.naver.com/console/board)로 위와 똑같이 진행하면 됩니다.

1. 사이트 도메인을 등록합니다.
2. `meta` 태그를 삽입하여 본인 사이트임을 인증합니다.
3. 요청 -> 사이트맵 제출 -> sitemap.xml 주소를 입력해줍니다.
4. 검증 -> robots.txt -> 잘 수집이 되었는지 확인합니다.
5. 설정 -> 수집 주기 설정 -> `빠르게`로 설정해줍니다.

![221116-010832](/images/posts/5-create-sitemap/221116-010832.png)

네이버도 구글과 비슷한 지표들을 정리해줍니다.

- 콘텐츠 노출/클릭
- 사이트 진단
- 수집 현황
- 콘텐츠 확산
- ...

네이버에서 개발 관련 검색을 잘 하진 않다보니 지표는 처참한 것 같습니다 ㅎㅎ
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="SEO"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 Google Analytics 연동하기]]></title>
        <id>/blog/nextjs-blog/5-google-analytics</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/5-google-analytics"/>
        <updated>2022-11-16T12:15:23.000Z</updated>
        <summary type="html"><![CDATA[블로그에 Google Analytics v4를 심어주자!]]></summary>
        <content type="html"><![CDATA[
✨ [**google analytics**](https://analytics.google.com/analytics/web/)
2020년도에 공식 릴리즈된 web-based 사용자 행동 분석 서비스입니다.  
사용자의 유입, 스크롤, 검색, 클릭 등 이벤트를 자도으로 수집해줍니다.  
참고로 firebase analytics는 app-based 분석 서비스로 iOS, AOS 앱을 개발할 때 사용하면 좋습니다.

사이트에 들어가면 어렵지 않게 이를 세팅할 수 있습니다.

관리 > 속성 만들기  
관리 > 데이터 스트림 > 스트림 추가  
관리 > 데이터 스트림 > 스트림 선택 > 태그 안내 보기 > 직접 설치

```html
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=###"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', '###');
</script>
```

마지막으로 위 예시를 Next.js에 맞게 주입시켜 주면 됩니다.

---

## Typescript 기반으로 gtag 심기

Next.js에서 GA를 사용하는 [공식 예시](https://github.com/vercel/next.js/tree/canary/examples/with-google-analytics)가 있어 그대로 참고하면 됩니다.  
하지만 js로 작성되어 있어 ts에 호환되도록 추가 작업이 진행되어야 합니다.

```shell
yarn add -D @types/gtag.js
```

<br />

`types.d.ts`

```ts
/// <reference types="gtag.js" />

declare module 'gtag.js';
```

eslint typescript에서 에러를 던질 수 있는데 `.eslintignore`에 `*.d.ts`를 추가하여 무시해주도록 합니다.

<br />

이제 3 파일을 수정하면 됩니다.

```ts:libs/gtags.ts
import { useRouter } from 'next/router';
import { useEffect } from 'react';

export const GA_TRACKING_ID = '<어짜피 HTML에 노출된다>';

// https://developers.google.com/analytics/devguides/collection/gtagjs/pages
export const pageview = (url: URL) => {
  window.gtag('config', GA_TRACKING_ID, {
    page_path: url,
  });
};

// https://developers.google.com/analytics/devguides/collection/gtagjs/events
export const event = (
  action: Gtag.EventNames,
  { event_category, event_label, value }: Gtag.EventParams,
) => {
  window.gtag('event', action, {
    event_category,
    event_label,
    value,
  });
};

// route가 변경될 때 gtag에서
export const useGtag = () => {
  const router = useRouter();

  useEffect(() => {
    if (process.env.NODE_ENV === 'development') return;

    const handleRouteChange = (url: URL) => {
      pageview(url);
    };

    router.events.on('routeChangeComplete', handleRouteChange);
    router.events.on('hashChangeComplete', handleRouteChange);
    return () => {
      router.events.off('routeChangeComplete', handleRouteChange);
      router.events.off('hashChangeComplete', handleRouteChange);
    };
  }, [router.events]);
};
```

```tsx:_app.tsx
// ...
import * as gtag from '~/libs/gtag';

export default function App() {
  gtag.useGtag();

  return (
    <>
      {/* ... */}
      {process.env.NODE_ENV !== 'development' && (
        <>
          {/* Global Site Tag (gtag.js) - Google Analytics */}
          <Script
            strategy="afterInteractive"
            src={`https://www.googletagmanager.com/gtag/js?id=${gtag.GA_TRACKING_ID}`}
          />
          <Script
            id="gtag-init"
            strategy="afterInteractive"
            dangerouslySetInnerHTML={{
              __html: `
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', '${gtag.GA_TRACKING_ID}', {
                  page_path: window.location.pathname,
                });
              `,
            }}
          />
        </>
      )}
    <>
  );
}

```

```tsx:_document.tsx
import { Head, Html, Main, NextScript } from 'next/document';

export default function MyDocument() {
  return (
    <Html lang="ko">
      {/* ... */}
      <body>
        <Main />
        <NextScript />

        {/* Global Site Tag (gtag.js) - Google Analytics */}
        {process.env.NODE_ENV !== 'development' && (
          <script
            dangerouslySetInnerHTML={{
              __html: `
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
              `,
            }}
          />
        )}
      </body>
    </Html>
  );
}
```

배포 이후 태그가 잘 추가되었는지 확인 해봅시다!  
html에서 `gtag-init`를 검색해보면 쉽게 찾을 수 있습니다.

![221116-134704](/images/posts/5-google-analytics/221116-134704.png)

이제 48시간 내에 해당 태그가 수집되어 GA가 사용자의 행동을 추적하게 됩니다.
우리에게 필요한 것은 인내심 뿐입니다.

---

## Google Search Console 연동

GA와 Search Console를 연동할 수도 있습니다.
좀 더 다채로운 통계 데이터를 볼 수 있게 되는 것 같습니다. ~~구체적인 것은 저도 아직은 잘...~~

**관리 > Search Console 링크 > 연결**

![221116-140526](/images/posts/5-google-analytics/221116-140526.png)

그럼 **Search Console Insights**를 볼 수 있는데 다양한 형태로 요약된 사이트 유입 데이터를 볼 수 있습니다.

![230107-171130](/images/posts/5-google-analytics/230107-171130.png)

![230107-171656](/images/posts/5-google-analytics/230107-171656.png)

---

**참고 자료**

- https://andrew-simpson-ross.medium.com/strongly-typed-google-analytics-v4-with-next-js-aad6c6a5e383
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="typescript"/>
        <category label="GA"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 댓글 기능 추가하기 (feat. giscus)]]></title>
        <id>/blog/nextjs-blog/6-comments</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/6-comments"/>
        <updated>2022-11-13T22:21:24.000Z</updated>
        <summary type="html"><![CDATA[💎 Giscus를 활용하여 Next.js 블로그에 댓글, 대댓글, 리액션을 달 수 있도록 해주자!]]></summary>
        <content type="html"><![CDATA[
## giscus

[utterances](https://utteranc.es/)의 영감을 받아 만들어진 오픈소스입니다.  
기존 Github Issue가 아닌 Github Discussion을 활용하여 댓글을 작성하는 것이 특징입니다.

utterances의 장점(광고없음, 가벼움, github 연동, 깔끔한 UI...)들이 너무나 완벽했지만,  
개인적으로 하나 아쉬웠던 것이 `대댓글이 직관적이지 않다`는 것입니다.

giscus는 기존 장점을 그대로 가져가면서 아래 추가적인 기능을 제공합니다!

- 대댓글 작성
- 댓글 시간순 정렬
- 댓글 인기순 정렬
- 페이지에 리액션 달기
- 귀여운 로딩 UI 제공
- 강력한 [config](https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#advanced-usage) 제공
- (덤으로) github에서 전체 댓글들을 더 직관적으로 쉽게 관리
- (덤으로) 잘 번역된 한글 공식문서 ✨

💎 https://giscus.app/ko

---

## giscus 연동

Github Discussion을 연동하기 위해 사전 세팅을 해야합니다.

1. 레포는 `Public`이여야 합니다.
   - 만약 `private`을 유지하고 싶다면 별도의 `public` 레포(ex. `myusername/comment`)를 생성하면 됩니다.
2. Github 계정에 [giscus](https://github.com/apps/giscus) 앱을 설치합니다.
3. Settings에서 [discussions](<(https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository).>) 기능을 활성화 합니다.

<br />

[공식문서 가이드](https://giscus.app/ko) 따라 `script config`를 생성합니다.

1. 레포 이름 `myusername/myrepo` 입력
2. Discussion 카테고리 선택
   - 일반적으로 General 선택하면 됩니다.
3. 원하는 입맛대로 기능 설정
   - 가이드 문서의 친절한 설명을 참고해보세요!
4. 생성된 script config 확인
   - 위 과정에서 `repo-id` `category-id`를 자동으로 탐지해줍니다!

---

## 코드 작성

생성된 script config 바탕으로 Next.js에서 활용할 수 있는 컴포넌트를 구현합니다.  
Next.js 테마에 따라 자동으로 반응하도록 구현했습니다.

```tsx
import { useTheme } from 'next-themes';
import { useEffect, useRef } from 'react';

export default function Giscus() {
  const ref = useRef<HTMLDivElement>(null);
  const { resolvedTheme } = useTheme();

  // https://github.com/giscus/giscus/tree/main/styles/themes
  const theme = resolvedTheme === 'dark' ? 'dark' : 'light';

  useEffect(() => {
    if (!ref.current || ref.current.hasChildNodes()) return;

    const scriptElem = document.createElement('script');
    scriptElem.src = 'https://giscus.app/client.js';
    scriptElem.async = true;
    scriptElem.crossOrigin = 'anonymous';

    scriptElem.setAttribute('data-repo', 'myusername/myrepo');
    scriptElem.setAttribute('data-repo-id', '[자동]');
    scriptElem.setAttribute('data-category', 'General');
    scriptElem.setAttribute('data-category-id', '[자동]');
    scriptElem.setAttribute('data-mapping', 'pathname');
    scriptElem.setAttribute('data-strict', '0');
    scriptElem.setAttribute('data-reactions-enabled', '1');
    scriptElem.setAttribute('data-emit-metadata', '0');
    scriptElem.setAttribute('data-input-position', 'bottom');
    scriptElem.setAttribute('data-theme', theme);
    scriptElem.setAttribute('data-lang', 'en');

    ref.current.appendChild(scriptElem);
  }, []);

  // https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#isetconfigmessage
  useEffect(() => {
    const iframe = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
    iframe?.contentWindow?.postMessage({ giscus: { setConfig: { theme } } }, 'https://giscus.app');
  }, [theme]);

  return <section ref={ref} />;
}
```

- `theme`을 [직접 제작](https://github.com/giscus/giscus/blob/main/CONTRIBUTING.md#creating-new-themes)할 수도 있습니다.
- `id` 값들은 어짜피 공개 접근이 가능하기 때문에 따로 `env`로 숨기지 않았습니다.
- `data-lang`가 `ko`도 지원해주지만 ~~영어가 더 간지나기 때문에~~ 저는 `en`을 선택했습니다.
- 만약 utterances를 사용하고 싶다면 [여기 코드](https://github.com/bepyan/bepyan.github.io/blob/main/src/components/Utterances.tsx)를 참고하시면 됩니다.
- 참고
  - https://github.com/utterance/utterances/issues/161#issuecomment-820722906
  - https://github.com/utterance/utterances/issues/549#issuecomment-913070158

---

### 페이지 이동시 자동 변경

SPA에서 페이지가 이동했지만 댓글창이 갱신이 안되는 현상이 있다.

`iframe`에 동적으로 `term` 설정을 갱신해주면 된다고 한다.
https://github.com/giscus/giscus/issues/357#issuecomment-1015964573

```ts
useEffect(() => {
  const iframe = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
  iframe?.contentWindow?.postMessage(
    { giscus: { setConfig: { term: router.asPath } } },
    'https://giscus.app',
  );
}, [router.asPath]);
```

---

## Trouble Shooting

### 💥 github 로그인시 home으로 리다이랙팅되는 문제

giscus는 utterances 처럼 canonical link를 활용하여 로그인 리다이랙팅을 진행합니다.

따라서 SEO에서 canonical link를 **현재 글 주소**로 잘 설정해주면 됩니다.

https://github.com/utterance/utterances/issues/474#issuecomment-774887936
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="giscus"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 Image Optimization]]></title>
        <id>/blog/nextjs-blog/6-image-optimization</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/6-image-optimization"/>
        <updated>2022-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Next.js static html에서 이미지를 기똥차게 사용해보자!]]></summary>
        <content type="html"><![CDATA[
기본적으로 next/image를 활용하면 이미지를 최적화시킬 수 있습니다.  
하지만 [static-html-export](https://nextjs.org/docs/advanced-features/static-html-export#unsupported-features) 환경에서는 이를 제공해주지 않는다고 합니다.

[Custom Loader](https://nextjs.org/docs/basic-features/image-optimization#loaders)를 활용해야한다고 하는데 ~~갈 길이 보이지 않습니다~~...  
라이브러리의 도움을 받아 보도록 합시다!

✨ [**next-export-optimize-images**](https://github.com/dc7290/next-export-optimize-images)

github star가 100개 정도인 조금은 빈약한 오픈소스 라이브러리입니다.  
하지만 기존 `next/image`의 option에 100% 호환할 만큼 강력하고 적용하는 방법 또한 간편하기에 이를 사용해보기로 했습니다.

아래 기능들을 제공해준다고 합니다.

- Optimize images at build time.
- All options for `next/image` available
- Convert formats (png → webp, etc.)
- Download external images locally.
- Using `sharp`, so it's fast.
- Cache prevents repeating the same optimization
- Support TypeScript
- Support `next/future/image`

---

## 환경 세팅하기

[공식문서](https://next-export-optimize-images.vercel.app/docs/getting-started) 참고하면 되는데 아래 설정파일 하나면 끝입니다 🫢

`next.config.js`

```js
const withExportImages = require('next-export-optimize-images');

/** @type {import('next').NextConfig} */
const nextConfig = withExportImages({
  //...
});

module.exports = nextConfig;
```

`next export` 이후에 따로 최적화 빌드를 실행해줘야 합니다.

```json
{
  "scripts": {
    "build": "next build && next export && next-export-optimize-images"
  }
}
```

---

## 실험 해보기

[공식문서](https://next-export-optimize-images.vercel.app/docs/examples#set-the-placeholder)대로 placeholder 속성을 지정해보겠습니다.

```tsx
import Image from 'next/image';

//...

<Image
  src="/forest.jpg"
  alt="forest"
  width={324}
  height={486}
  placeholder="blur"
  className="h-auto"
/>;
```

dev 환경에서의 변환 결과

```html
<img
  alt="forest"
  srcset="/forest.jpg?width=384 1x, /forest.jpg?width=750 2x"
  src="/forest.jpg?width=750"
  width="324"
  height="486"
  decoding="async"
  data-nimg="1"
  class="h-auto"
  loading="lazy"
  style="color: transparent;"
/>
```

build 환경에서의 변환 결과

```html
<img
  alt="forest"
  srcset="
    /_next/static/chunks/images/forest_384_75.jpg 1x,
    /_next/static/chunks/images/forest_750_75.jpg 2x
  "
  src="/_next/static/chunks/images/forest_750_75.jpg"
  width="324"
  height="486"
  decoding="async"
  data-nimg="1"
  class="h-auto"
  loading="lazy"
  style="color: transparent;"
/>
```

dev 환경에서는 사진 원본을 사용하며 build를 거친 후 3000px 이상의 image가 700px대로 잘 최적화되었습니다!

```javascript
// 로딩 중
style = "color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' viewBox='0 0 324 486'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage preserveAspectRatio='none' filter='url(%23b)' x='0' y='0' height='100%25' width='100%25' href='/_next/static/chunks/images/forest_8_10.jpg'/%3E%3C/svg%3E")";

// 로딩 완료
style = 'color: transparent;';
```

이미지가 로딩되기 전에 `background-image`로 placeholder를 표시합니다.  
하지만 blur된 이미지는 잘 표시되는진 않는 것 같습니다...

![230107-164837](/images/posts/6-image-optimization/230107-164837.png)

언젠가는 새로 손을 봐야할 것 같군요...
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="image"/>
        <category label="optimization"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 mdx에서 이미지 복붙하기 (feat. Paste Image)]]></title>
        <id>/blog/nextjs-blog/6-images-use-in-vscode</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/6-images-use-in-vscode"/>
        <updated>2022-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vscode markdown 파일에서 이미지를 기똥차게 사용해보자!]]></summary>
        <content type="html"><![CDATA[
notion, velog로 글을 작성하다가 vscode로 작성하려다보니 이미지를 추가하는 것이 꽤나 번거롭습니다. 🥲
일일이 링크를 찾거나 생성해서 수작업으로 넣어줘야 했지요.
앞으로 글을 그대로 수작업으로 작성해야한다고 생각하면 너무 아찔합니다!

다행히 우리를 구원해줄 vscode 플러그인이 있습니다!  
mdx에서 이미지를 복사하면 로컬환경에 정적 이미지 리소스를 생성해줍니다.

✨ [**Paste Image**](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)  
다만 gif는 지원되지 않습니다.

---

## 환경 세팅하기

`.vscode/settings.json` 파일을 생성합니다.  
레포 단위의 개발환경을 세팅하기 위함입니다.

```json
{
  "pasteImage.defaultName": "YYMMDD-HHmmss",
  "pasteImage.basePath": "${projectRoot}/public",
  "pasteImage.path": "${projectRoot}/public/posts/${currentFileNameWithoutExt}",
  "pasteImage.forceUnixStyleSeparator": true,
  "pasteImage.insertPattern": "![${imageFileNameWithoutExt}](${imageFilePath})",
  "pasteImage.prefix": "/"
}
```

경로를 mdx 파일 단위로 이미지가 저장되도록 했습니다.

`/posts/nextjs-blog/2-images.mdx`  
-> `/public/posts/2-images/[YYMMDD-HHmmss].png`

posts와 1:1 매칭하고 싶지만 중간 경로를 추출할 수 있는 방법이 없는 것 같습니다 🥲

---

## 단축키 설정

저는 간편하게 복붙하기 위해서 단축키도 같이 수정을 해줬습니다.

`.vscode/keybindings.json`

```json
[
  {
    "key": "shift+cmd+v",
    "command": "-notebook.cell.pasteAbove",
    "when": "notebookEditorFocused && !inputFocus"
  },
  {
    "key": "shift+cmd+v",
    "command": "-markdown.showPreview",
    "when": "!notebookEditorFocused && editorLangId == 'markdown'"
  },
  {
    "key": "shift+cmd+v",
    "command": "-markdown.extension.closePreview",
    "when": "markdownPreviewFocus"
  },
  {
    "key": "shift+cmd+v",
    "command": "extension.pasteImage",
    "when": "editorTextFocus"
  }
]
```

이제 이미지를 복사하고 `shift + cmd + v` 입력하면 이미지가 짜잔 생성됩니다.  
딜레이가 ~~거의~~ 없다는 사실!

![copy-paste](/images/posts/6-images-use-in-vscode/copy-paste.gif)

![221115-012522](/images/posts/6-images-use-in-vscode/221115-012522.png)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="markdown"/>
        <category label="Paste Image"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그 TOC 배너 만들기]]></title>
        <id>/blog/nextjs-blog/6-toc</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/6-toc"/>
        <updated>2022-11-19T16:33:14.000Z</updated>
        <summary type="html"><![CDATA[목차를 만들자.]]></summary>
        <content type="html"><![CDATA[
1. 배너 위치 산정하기
   - absolute로 위치를 잡아주고 fixed로 스크롤에 고정되도록 한다.
2. Content에서 Toc 추출하기
3. slug 만들기
   - tailwind에서는 https://github.com/sindresorhus/slugify 라이브러리를 사용하고 있었다.
   - 한글도 파싱되기 위해선 https://gist.github.com/codeguy/6684588 참고하여 직접 투박하게 작업했다.
   - 유니코드가 해석이 안되는 문제가 있다. 추후게 https://github.com/simov/slugify/blob/master/slugify.js 참고해서 작업해보자.
4. 마크업 구성하기
   - `<a href="#..."/>`를 활용해서 링크를 연동한다.
   - slug # 개수에 따라 깊이를 부여하고 [tailwind docs](https://tailwindcss.com/docs/typography-plugin)처럼 스타일를 부여해보자.
5. 스타일 조정하기
   - scroll-margin-top을 element margin-top에 맞추면 보기 좋게
6. 스크롤에 따라 현재 headings에 하이라이트한다.

배너 만드는 방법

1. `absolute`속성에 `left-full`로 레이아웃 잡기

```tsx
<div className="absolute left-full">
  <div className="fixed top-12 bottom-0 ml-8 h-full w-80 overflow-y-auto p-8">
    <TocBanner tableOfContents={tableOfContents} />
    <div className="">
      <ThemeSwitch />
    </div>
  </div>
</div>
```

2. `right` 속성으로 동적으로 레이아웃 잡기

```tsx
<div className="fixed top-[3.8125rem] bottom-0 right-[max(0px,calc(50%-45rem))] z-20 hidden w-[19.5rem] overflow-y-auto py-10 xl:block">
  <div className="">
    <TocBanner tableOfContents={tableOfContents} />
    <div className="">
      <ThemeSwitch />
    </div>
  </div>
</div>
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <category label="Toc"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그에 RSS, JSON Feed 추가하기]]></title>
        <id>/blog/nextjs-blog/7-rss</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/7-rss"/>
        <updated>2023-03-17T17:37:20.000Z</updated>
        <content type="html"><![CDATA[
`RSS`와 `JSON Feed`는 **웹사이트의 콘텐츠를 손쉽게 구독**할 수 있게 해주는 기술이다.
모두 웹사이트의 업데이트를 손쉽게 확인하고, 원하는 콘텐츠를 효율적으로 모아볼 수 있는 기능을 제공한다.

---

## RSS (Really Simple Syndication)

`RSS`는 `XML` 기반으로 웹 콘텐츠를 제공해준다.
사용자는 [RSS 리더](https://rssviewer.app/)를 통해 여러 사이트의 RSS를 통해 피드들을 한 눈에 볼 수 있다.

추가로 `Atom`이라는 `XML` 기반의 표준도 있다.
`RSS`보다 더 확장성이 있고 더욱 상세한 정보를 기입할 수 있다.

---

## JSON Feed

`JSON Feed`는 이름대로 `JSON` 기반으로 웹 콘텐츠를 구독한다.
`JSON`이기 때문에 파싱이 쉽고, 가독성이 좋고, 가볍고... `XML`보다 이점을 많이 갖고 있다.

---

## 블로그에 적용하기

`JSON Feed`가 성능상 이점이 있지만 오랫동안 사용되어 온 `RSS`를 내려놓기 어렵다.
하지만 꼭 하나만 선택할 필요는 없다. `RSS`, `JSON Feed` 모두 제공해주면 된다.

[**`feed`**](https://github.com/jpmonette/feed)를 활용해서 구현해보자.
`typescript` 기반으로 구현된 라이브러리이며 `RSS` `Atom` `JSON Feed`를 모두 생성할 수 있다.

```shell
yarn add feed
```

### 데이터 생성하기

해당 블로그에서 적용한 방법이다.
빌드시 `rss.xml` `feed.json` 정적 파일을 생성하여 `github pages`에 배포하는 방식이다.

```ts:scripts/generate-rss.ts
import { Feed } from 'feed';
import { writeFileSync } from 'fs';

import PostJson from '../.contentlayer/generated/Post/_index.json';
import { siteConfig } from '../src/config';

const master = {
  name: siteConfig.author.name,
  email: siteConfig.author.contacts.email,
  link: siteConfig.url,
};

const feed = new Feed({
  title: siteConfig.title,
  description: siteConfig.description,
  id: siteConfig.url,
  link: siteConfig.url,
  language: 'ko',
  image: `${siteConfig.url}/images/base.jpg`,
  favicon: `${siteConfig.url}/favicon.ico`,
  copyright: `All rights reserved since ${siteConfig.since}, ${master.name}`,
  generator: 'generate-rss',
  feedLinks: {
    json: `${siteConfig.url}/json`,
    atom: `${siteConfig.url}/atom`,
  },
  author: master,
});

PostJson.forEach((post) => {
  feed.addItem({
    title: post.title,
    id: post.slug,
    link: `${siteConfig.url}${post.slug}`,
    description: post.description,
    content: post.body.raw,
    author: [master],
    contributor: [master],
    date: new Date(post.date),
    image: post.image,
    category: post.tags.map((tag) => ({ name: tag })),
  });
});

feed.addCategory('Technologies');

// Output: RSS 2.0
writeFileSync('out/rss.xml', feed.rss2(), 'utf-8');
// Output: Atom 1.0
writeFileSync('out/rss-atom.xml', feed.atom1(), 'utf-8');
// Output: JSON Feed 1.0
writeFileSync('out/feed.json', feed.json1(), 'utf-8');
```

속성들은 직관적이기 때문에 어렵지 않게 자신 환경에 맞춰 작성할 수 있을 것이다.
만들어진 데이터를 `writeFileSync` 통해 파일로 생성하면 된다.

사실 꼭 정적인 파일을 생성할 필요는 없다. `api`를 통해서 응답을 받게 해도 된다.

```ts:pages/api/rss.ts
import { Feed } from 'rss';
// ... (생성한 feed 코드 삽입)

export default async (req, res) => {
  res.setHeader('Content-Type', 'application/rss+xml');
  res.write(feed.rss2());
  res.end();
};
```

### 배포하기

빌드시 최종적으로

```json:package.json
{
  //...
  "homepage": "https://bepyan.github.io/",
  "scripts": {
    //...
    "build": "next build && next export && yarn rss",
    "rss": "ts-node --project tsconfig.node.json ./scripts/generate-rss.ts",
  },
}
```

```json:tsconfig.node.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
  }
}
```

### 웹사이트에 링크 추가하기

```html:_document.tsx
<Head>
  <link rel="alternate" type="application/rss+xml" href="/rss.xml" title="RSS" />
  <link rel="alternate" type="application/atom+xml" href="/rss-atom.xml" title="RSS Atom" />
  <link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed" />
</Head>
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="rss"/>
        <category label="json feed"/>
        <category label="atom"/>
        <category label="xml"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js로 블로그 만들기]]></title>
        <id>/blog/nextjs-blog</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog"/>
        <updated>2022-11-11T19:31:17.000Z</updated>
        <summary type="html"><![CDATA[100% 취향 반영, 내 손으로 직접 블로그를 만들어 보자!!]]></summary>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[기술 블로그를 만들 땐 무엇을 고려해야 하는가?]]></title>
        <id>/blog/nextjs-blog/why</id>
        <link href="https://bepyan.github.io/blog/nextjs-blog/why"/>
        <updated>2022-11-11T22:04:39.000Z</updated>
        <summary type="html"><![CDATA[블로그를 만들 때 어떤 것들을 고려해야 할까? 🤔]]></summary>
        <content type="html"><![CDATA[
## 왜 블로그를 만들고 싶은가?

> **글을 쓰는 목적이 무엇인가?**

블로그를 시작하기 전에 반드시 이 질문에 스스로 명확한 답을 할 수 있어야 합니다.
목적에 따라 사용되는 도구가 달라지기 때문이죠.

단순히 `나를 위해 지식을 기록`할 땐 [**notion**](https://www.notion.so/), [**tana**](https://tana.inc/) 같이 기록이 간편한 도구를 사용하는 것이 좋습니다.
나의 기록 내용을 공유할 땐 또 간편하게 웹 링크를 건네주기만 하면 되죠.
블로그 플랫폼은 이 도구들에 비해 상대적으로 불편하고 관리에 시간을 많이 쏟아야 합니다.
목적에 맞지 않는 도구는 결국 손해를 감수해야 합니다.

좋습니다. 만약 `나 같이 삽질한 사람에게도 도움을 주고 싶을` 마음이 생긴다면 블로그는 너무 좋은 도구입니다.
플랫폼 브랜드를 통해 검색엔진에 쉽게 노출될 수 있고 글을 작성하기도 좋습니다.
플랫폼 별로 장단점을 아래와 같이 정리할 수 있습니다. 목적에 맞게 여러 플랫폼을 쓸 수도 있겠죠!

| 플랫폼                                  | 장점                                                                                               | 단점                                                                                   |
| --------------------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| [**tistory**](https://www.tistory.com/) | 개발자라면 입맛에 맞게 쉽게 커스터마이징(+ 광고)할 수 있다.                                        | 자유로운만큼 블로그 운영에 꽤나 손이 간다.                                             |
| [**velog**](https://velog.io/)          | 유동 인구가 많아서 글을 잘 쓰면 많은 사람이 쉽게 접할 수 있다.                                     | 개인이 운영을 하기에 기능 확장에 느리고 장애에 크리틱컬할 수 있다.                     |
| [**brunch**](https://brunch.co.kr/)     | 브런치북을 통해서 '책'을 출판하는 감성이 있다.                                                     | 코드 하이라이팅을 지원하지 않기에 github gist 같은 외부 툴을 활용해야 한다.            |
| [**medium**](https://medium.com/)       | 글로벌 플랫폼답게 전체적으로 완성도가 높다. ~~영어로 작성한다면 글로벌 인싸가 될 수도 있다는 점.~~ | 브런치처럼 출판물에 초점이 맞춰져 있어 ~~취소선~~처럼 개발 글을 쓰기 불편할 수도 있다. |
| [**github**](https://github.com/)       | 오픈소스 공식문서같이 포멀한 느낌을 줄 수 있다.                                                    | UI가 고지식하고 markdown 기반으로 글을 써야 하는게 불편할 수 있다.                     |

여기서 tistory의 커스터마이징으로도 성이 안찬다면 **오픈소스 블로그 템플릿**이라는 선택지도 있습니다.
하지만 엄청난 **고난을 감수할 각오**를 갖고서 시작해야 합니다.
템플릿은 틀만 제공해줄 뿐 결국 직접 SEO 최적화를 해야하고 장인정신을 갖고 한땀 한땀 유지보수해가야 합니다.
괜히 수 많은 블로그들이 이사 가는 것이 아닙니다...

그저 깃헙 잔디 때문에 블로그 레포를 운영하려 한다면 정말 말리고 싶습니다.. ~~사실 아무도 너의 잔디에 관심을 갖지 않아..~~

저의 경우는 **개인 브랜드**를 만들고 싶었습니다.
FrontEnd 개발자로써 자신을 가장 잘 표현할 수 있는 수단은 블로그라고 생각했습니다.
그래야 블로그에 애정을 갖고 꾸준히 혼을 갈아 넣을 수 있겠죠?

어떻게 보면 저의 블로그를 제작하기 위한 과정이네요.
notion -> 개인 블로그 실패 -> velog -> 다시 개인 블로그

---

## 기술 스택 채택하기

서론이 길었습니다.

- NextJS
- Typescript
- tailwindCSS
- next-mdx-remote

---

## 글 작성 규칙 정하기

하루키 규칙

> 한번에 많은 글을 찍어내려 하지않길 바랍니다. 번아웃의 지름길이고
> 꾸준히

일관성이 있는 글

---

## 맺으면서

이제 막 블로그를 시작하려는 초짜
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="blog"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[5개월간 스타트업에서 굴렀다. 그리고 얻었다.]]></title>
        <id>/blog/retrospect/2021-in-startup</id>
        <link href="https://bepyan.github.io/blog/retrospect/2021-in-startup"/>
        <updated>2021-12-14T15:10:31.000Z</updated>
        <summary type="html"><![CDATA[2021.07.05 ~ 2021.11.26]]></summary>
        <content type="html"><![CDATA[
> 2021.07.05 ~ 2021.11.26

<br />

바야흐로 올해 여름,  
지원한 인턴 모두 떨어지고 앞 길의 갈피를 잡지 못하고 있는 상황,  
인스타그램 광고로 스타트업의 Recruit을 접하게 되었다.

탄소 배출을 줄이고자하는, [샐러드 구독 플랫폼](http://saladweeks.co.kr/)을 운영하는 스타트업이다.
React, React-Native 개발자를 모집하고 있었고 나의 기술스택과 딱 맞아 들었다.
서류 - 1차 면접 - 2차 면접, **입사 프로세스가 1주일안에 마무리 되었던 엄청난(?) 속도**를 보여줬다. 1차는 기술면접으로 비대면, 2차는 인성면접으로 대면으로 진행했다. 서비스를 어디까지 구축할 수 있는지, 현 팀원들과 원활한 협업 가능할지가 중요 포인트였던 것 같다.

직원이 6명이고 법인이 창립된지 얼마 안된 초창기 스타트업이였기에 이런 **사수가 없는 환경에서 내가 잘 성장할 수 있을까** 고민이 되었다. 하지만 이런 초창기 스타트업은 지금 아니면 절대로 경험할 수 없을 것 같았다. 좋은 가치를 추구하는 서비스라고 생각했고 회사의 성장지표도 괜찮아 보여서 도전을 이어나가기로 했다. 다시 학교 들어가 의미없는(?) 이론 수업 보다는 현업에서 부딪치고 싶었고 돈을 벌고 싶었다.

<p align="center">
  <img src="https://c.tenor.com/VCcGldHmbwQAAAAC/moved-clapping.gif" />
  <span>돈 받고 코딩이라니... ( 감격 )</span>
</p>

<br />

입사후,
**사실 충격의 연속이었다.** 제대로 개발되어 있는 것이 하나도 없었다. 나름 괜찮아 보였던 기존 사이트가 WIX라는 쇼핑몰 사이트 솔루션을 통해 만들어 졌고 사장님용 안드로이드 앱도 학부생 수준 미만의 퀄리티로 사용되고 있었다. 듣기로는 이전에 비전공자 팀원이 만든 것들이라 했다. 열악한 환경속에서도 서비스를 잘 운영해낸 팀원분들이 진심 대단했다..

백엔드가 없다..? WIX에서 제공해주는 DB를 사용하고 있었고 이를 Firebase에 주마다 동기화하여 앱에서 사용하고 있었다. 그래서 한동안(1달) 개발자가 맞나 싶을 정도로 데이터 동기화하는 단순 CS업무도 병행을 했었다. 빨리 이 시스템을 바꿔야지 이 악물며 했던 것 같다.

내가 들어간 시점에서 새로운 통합 시스템을 만들고 있었다. 개발자는 웹 1명, 백엔드 1명이 있었고 나는 React Native으로 사장님앱을 만들게 되었고 사내 관리자페이지까지 구축하게 되었다. 실무 경험이 없던 내가 들어오자마자 시스템 전체를 구축해야 했던 것이다. 시행착오가 있었지만 덕분에 내가 크게 성장할 수 있었던 것 같다.

그렇게 정신없이 5달을 달려왔고 그만두고서야 제대로 회고를 하게 되었다.

---

## 💪🏻 내가 얻어 간 것

> 기획, 설계, 배포 모든 단계에 직접적으로 참여한 경험.
> 이슈, 업무 프로세스를 관리하는 방법.
> 기술력, 검색능력, ~~그리고 재력.~~

**Notion & Slack**

- 공유 사무실, 재택, 코로나 환경으로 인해 Slack을 활용해서 많이 커뮤니케이션을 해야했다. Notion의 데이터베이스, 템플릿, Slack의 리마인드, 채널 등을 제대로 활용하게 되면서 업무 메신저 툴의 대한 이해도가 높아졌다.

- 입사한지 1달 반만에 앱 기획부터 배포까지 강행군하며 스스로 **작업 프로세스 관리하는 법을 알게 되었다.** 노션의 칸반보드을 활용하여 내가 무엇을 우선적으로 작업 해야하는지 리스트업했고 어떤 작업이 남아 있는지 쉽게 파악할 수 있었다. 이번주 내가 작업할 수 있는 범위를 더 구체적으로 예측을 할 수도 있었다.

<br />

**사장님 앱**

- **play store와 app store에 직접 앱을 배포했다**. 앱 특성상 앱 스토어를 통해서 앱을 전달하고 업데이트를 해야한다. 따라서 play store와 app store + xcode 에 대한 진입장벽이 꽤나 부담스럽다. 특히 지옥의 apple 심사.. (4번 reject을 당했다.. 3번의 권한 사용 요청 문구 수정, 1번은 해외에서 테스트할 수 있는 핸드폰 인증로직 관련) 그 모든 절차를 경험한 것은 정말 값진 것 같다.
  m1으로 XCode 앱 빌드하는데 계속 에러가 발생하여 고생했던 것이 기억에 남는다.
  play console의 에러 모니터링 기능을 통해서 배포한 앱에서 비정상 종료 이슈에 관해서 추적할 수 있었다. 덕분에 카메라 모듈을 교체하여 카메라 동작 이슈를 해결하기도 했다.

- 학교 프로젝트하면서 아쉬웠던 부분을 풀어 낼 수 있었는데 그 중 하나가 **Atomic Degisn System**이다. 초기부터 아토믹한 컴포넌트를 추구했다. `emotion`을 활용해서 다른 UI 라이브러리 도움 없이 앱에 맞는 체계적인 UI Kit을 구축할 수 있었다.
- 추가적으로 `React Navigation`을 활용한 Custom Modal 구현, `Channel.IO` 연동, 푸시알림 환경 구축, QR 코드 스캔, 앱 자동업데이트, `Typescript Generic` 등을 많은 경험할 수 있었다.

<br />

**관리자 페이지**

- 어떤 UI Kit을 사용할지 고민하다가 IBM의 [Carborn Desgin System](https://www.carbondesignsystem.com/)을 선택했다. 날카롭고 세련된 UI가 관리자와 잘 맞을 것 같았다.
- Storybook를 보면서 개발을 진행했는데 생각보다 레퍼런스가 부족하고 공식문서는 영문으로 되어 있어 학습에 끙끙댔다. 나중에 [Guideline](https://www.carbondesignsystem.com/guidelines/color/overview/)과 [Pattern](https://www.carbondesignsystem.com/patterns/empty-states-pattern/)에 대해서 알게 되어 참고하다 보니 **UI Layout에 대한 통찰력이 조금은 생긴 것 같다.** 처음에는 무지성으로 그냥 최대한 테이블내에서, 어떻게든 row를 expanded해서 동작을 수행하려 했다. 하지만 Dashboard 기반의 UI 가이드라인과 예시를 보고 내가 잘못하고 있음을 크게 깨닫고 객체 기반으로 대시보드 UI로 리팩토링하게 되었다.
  Data Table에 대한 레퍼런스가 너무 부족하여 해당 컴포넌트를 활용하는데 꽤나 오랜 시간이 소요되었다. `props`로 넘겨준 데이터가 컴포넌트 내부적으로 memorized되고 변형된 형태로 사용되었다. 이것을 이해하고 나서야 제대로 테이블 컴포넌트를 활용할 수 있게 되었다. 나중에 `react-table` 라이브러리를 접하는데 큰 도움이 되었다.

- 추가적으로 `Github Action`를 통한 AWS S3 CI/CD 자동화, `jwt`를 이용한 인증 구현, `xlsx`를 통한 데이터 엑셀 변환, `html-to-image`를 통해 html 이미지 변환, `Custom Hook` 제작(axios, debounce, 필터링, 테이블 관리 ...), `recoil`을 통한 전역 상태관리 등을 경험할 수 있었다.

<p align="center">
  <img
    src="https://c.tenor.com/OhQaaoHRM0kAAAAC/%EB%AC%BC%EC%9D%8C%ED%91%9C-%ED%8F%AC%EC%A6%88.gif"
    width="300"
  />
  <span> 이젠 나도 어엿한 현업 개발자..? 라는 근자감이 생기게 되었다. </span>
</p>

---

## 🍒 좋았던 점

목걸이?!  
출입증을 목에 걸고 밥먹으로 갈 때 너무나 뿌듯했다. 나도 직장인..? ㅎ헿

<p align="center">
  <img src="https://a4-images.myspacecdn.com/images04/12/42b055063c4944cc9d703ec36d287870/full.gif" />
</p>

<br />

**수평적이고 자유롭게 소통하는 팀문화.**

- 서로 닉네임을 불렀고 정말 자유롭게 의견을 주고 받았다.
- **애자일하게 업무 프로세스를 개선할 수 있었다.**
  ex. 개발팀에서 매일 스크럼, 주1회 스프린트를 진행했는데 매번 미팅마다 각자 이슈를 정리해야했다. 개선할 수 없을까하는 피드백이 나왔고 우리의 업무를 하나의 노션 데이터베이스로 합치기로 했다. 이후 따로 자료를 정리할 필요없이 노션의 필터링만 걸면 회의를 진행할 수 있었다. 추가적으로 템플릿을 활용하여 스프린트 회의록도 작성하기 굉장히 간편해졌다!

열정적인 팀원들.

- 더 나은 사회를 위한 따뜻한 마음을 가진 팀원들.
- **서로를 신뢰할 수 있었다.**

자유로운 출퇴근.

- 코어 근무제 (11:00 ~ 16:00는 일하고 자율적으로 근무시간표를 조정) 였기 때문에 출근에 대한 압박이 없었다.
- 월화수는 오피스 출근하고 나머지는 선택적 재택할 수 있었다.

팀 전체가 개발자의 목소리를 정말 경청해주었다. ~~그럼에도 살인적인 배포일정이...~~

---

## 🥥 아쉬웠던 점

열악한 개발환경인 만큼 아쉽고 부족했던 점이 많을 수 밖에 없었던 것 같다.

기획의 부실

- 기획자가 대표 1명이었다. 물론 서비스 요구사항에 대해 가장 잘 알지만 바빠서 기획에 전념을 할 수 없었다. 게다가 앱과 웹 둘다 기획을 해야하고 디자이너도 따로 없었다. 디테일한 기능요구사항, UI 마크업이 부실할 수밖에 없었다. 사장님들이 샐픽커 검색, 지난 픽업에 대한 처리 등 불편함을 호소하여 UI와 기능을 갈아 엎기도 했다.

**백엔드의 부실공사**

- 지나치게 빡센 배포일정이 예정 되었다(투자를 받기 위해서). 1달 반안에 기획부터 배포까지 해야하는데 시간이 절대적으로 부족했고 다들 경험도 부족했다.
- **백엔드 API가 RESTful하지 못하게 되었다.** 리소스 중심으로 route가 구성되지 못했고 네이밍 컨벤션도 잘 지켜지지 않았다. 잘못된 문서 명세로 인해 불필요한 커뮤니케이션도 발생했다. 나만 Typescript를 썼기에 응답 컨벤션에 고통을 받았다. 같은 모델이지만 2-4개의 타입을 응답에 맞춰 작성을 해야했다.
- 관리자 페이지가 없는 상태에서 서비스를 운영해야하다 보니 DB를 직접 접근을 해야하는 경우가 비일비재했다. 관리자페이지를 고려하여 API 설계가 되지 않아서 admin용 route가 부실했고 알림톡, 인프라 등 많은 일을 감당해야하는 백엔드이기에 앱, 웹 기능 구현이 계속 지연되었다.
- 설상가상 ❄️ 중간에 백엔드분이 예정대로 그만두시고 새로운 백엔드 개발자가 오시면서 개발일정을 전면 개편하게 되었다. 기존 서버를 리팩토링하게 되었는데 부실했던 API를 RESTful하게, JWT를 제대로 활용하고, HTTPS도 적용한... 1달의 대공사를 치르게 되었다.

나홀로 생존기

- **좀 멀리보지 못 했다.** 개발방향을 가이드해주는 경험이 많은 개발자가 주위에 없어서 구글 검색에 절대적으로 의존했다. 문제가 발생하고나서야 잘못을 깨닫고 리팩토링을 하게 된 경우가 많았다. 그만두는 순간까지도 내가 잘못 설계한 코드가 많이 보였다.

iOS 앱이 너무 늦게 배포되었다.

- iOS 개발자 계정이 있어야 제대로 빌드 테스트해서 실제 배포를 할 수 있다. 하지만 기업용 계발자 계정이 지나치게 늦게 나오는 바람에 앱 출시 일정이 거의 1.5 달 늦춰지게 되었다. andriod는 8월달에 배포 된거 보면 사실 3개월이나 늦춰진 것이다...
- iOS가 늦게 나오는 바람에 iPhone을 쓰시는 사장님들이 android를 구비해야해서 불편하실 수 밖에 없고 회사측에서는 이를 케어하기 위해 픽업 명단 캡처 등 수고스러움을 감수해야 했다.

---

## 💉 백신

백신을 맞으면 이 열악한 정글에서 더 강하게(?) 성장해 갈 수 있지 않을까하는 포인트를 정리해보았다.
~~넌 강해졌다 돌격해!~~

<p align="center">
  <img
    src="https://images.velog.io/images/bepyan/post/87aa1520-f028-4ac8-af29-f16734255080/image.png"
    width="500"
  />
</p>

#### 실제 needs가 무엇인지를 집중하자.

- 결국 개발의 핵심은 서비스 기능을 제공해 주는 것이다.
- 시/공간복잡도, 깨끗함, 수준 높은 코드를 사람들이 많이 알아 주진 않는다. 사람들이 알아주는건 기능이 잘 동작하고 편리한 것이고 직관적인 것이다.
- 시스템을 설계 할 때도 데이터가 중점이 아닌 기능을 중점으로 진행해야 한다. 어떤 변수를 사용할지가 아닌 메시지(메소드)를 어떻게 주고받으면서 기능을 구현할지를 고민하자. ~~이것이 객체지향이라고 하더라~~

<br />

#### 완벽함을 좀 내려놓아도 괜찮다.

- 처음부터 완벽한 코드를 작성할 수 없다. 일단 기능을 구현하고 리팩토링하자!
- 코드는 작성한 순간 레거시가 된다.
- 완벽함을 위해 머릿속으로 많이 고민할 수 있는데 글로 이슈를 트래킹을 하자. 점심시간 활용해서 동료들과 이에 대해 잡담해보는 것도 좋다. 나중에 면접에서 큰 도움이 될 것이다.
- 좀 번외긴 하기만,, 출퇴근간 [클린코드 핸드북](https://738.github.io/clean-code-typescript/)을 보면서 내 코드의 청결상태를 점검해보자. ~~은근히 더럽더라..~~

<br />

#### 코드에 감정이입하지 말자.

- 우린 이제 현업이고 프로이다. 적어도 10년은 코딩으로 밥먹고 살아야한다.
- 비즈니스 요구사항에 따라 기존 코드를 갈아 엎을 수 있다. ~~당연한 거다 ㅎㅎ~~
- 버그가 발생하는 것은 내가 못나서 그런게 아니다. 불가항력이다. 버그를 수습하는게 개발자의 일이다.

<br />

#### ‘나중에 제대로 정리해야지’ 미루지 말자.

- 되도록 지금 깔끔히 마무리 하자. 나중에 다시 집중해서 리팩토링하기 힘들다. ~~아니, 할 시간이 없다.~~
- 미루는 것은 새로운 일을 만들어 낼 뿐이다.

<br />

#### 취뽀는 목적지가 아니다.

- '난 뭘 하고 싶지?' 계속 스스로 물어봐야 한다.
- 직장인의 시계는 5배로 빨리 간다. ~~주 5일을 일하기 때문..~~
- 한 번뿐인 청춘, 하고 싶은 것을 이루기 위해 불태우자. 직장은 그저 수단일 뿐이다.

---

## 맺으면서

내가 한 일을 타임라인으로 다시 정리해본다면

| 시간  | 내용                                      |
| ----- | ----------------------------------------- |
| 7-8월 | 사장님 앱 기획, 설계, 배포                |
| 9월   | 관리자 페이지 기획, 설계, 배포            |
| 10월  | 사장님 앱, 관리자 페이지 유지보수         |
| 11월  | 사장님 앱, 관리자페이지 API V1 업그레이드 |

입사전, 내가 생각했던 것보다 스타트업을 통해서 정말 많이 성장할 수 있었다.
좋은 팀원들을 만날 수 있었고, 회사와 팀원들이 모두 계속 성장해갔으면 좋겠다.

<p align="center">
  <img src="https://c.tenor.com/bQCHJwgCNuMAAAAC/kitten-cat.gif" width="300" />
</p>

바빴지만 즐거웠고 힘들었지만 재밌었다.
도전을 계속 이어가자 😘
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="회고"/>
        <category label="커리어"/>
        <category label="신입 개발자"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022 카카오 블라인드 공채 합격 후기]]></title>
        <id>/blog/retrospect/2021-pass-kakao</id>
        <link href="https://bepyan.github.io/blog/retrospect/2021-pass-kakao"/>
        <updated>2021-12-20T15:11:47.000Z</updated>
        <summary type="html"><![CDATA[2022 카카오 블라인드 공채 ✨ 카카오 본사 합격 후기 ✨]]></summary>
        <content type="html"><![CDATA[
## 들어가면서

글을 재밋게 적어보려고 제가 친구 한명 데려와봤습니다. ⚡️ 스압 주의.

🙋🏻 **`안녕하세요 코린이 에드에요`**

<br />

🙋🏻 **`우왓 ㅊㅋㅊㅋ 소감이 어때?`**

참 힘들고... 긴 시간이었어... 스타트업을 다니면서 9월부터 11월까지 3개월 프로세스가 진행되었는데. 완전 고3 시절로 돌아간 느낌이야.. 다신 못할거 같애 .. 🥲

내가 합격할 수 있었던 것은 **스터디를 진행했기 때문이야**. 대학동기 한명, 군대동기 한명이랑 같이 진행했는데 친구들에게 정말 고맙다고 박수를 주고 싶어 👏🏻👏🏻 군대동기랑 오랫만에 만나서 얘기를 하다가 뜻과 목표가 맞아서 `🦅 그럼 같이 스터디를 해볼래?`하면서 시작하게 되었어. 나중에 대학동기도 합류하게 되었고. 멋진 친구들과 함께하니까 포기를 안할 수 있었던거 같아!

우린 100% 비대면으로 스터디를 진행했는데 큰 동기부여와 결속력을 갖기 위해서 엄청난 과금제를 도입했어. 현재 벌금이 10만원 넘게 모였고 곧 회식 때 쓰기로 했어. 지금 모두 취뽀했지만 스터디는 계속 진행하려고 하고 있어.

<br />
<br />

---

## 1차 코딩테스트

🙋🏻 **`카카오 코딩테스트 어렵다는데 어땠어?`**

갈수록 어려워지는 느낌이었는데 작년 코테보다 좀 쉽게 나온 것 같아.

7문제 중 ~~5.5 솔~~ 5솔했어. ( 모든 테스트케이스를 통과해야지 점수가 카운팅이 된다 )

어려운 그래프 알고리즘은 안나왔고 Dict 자료형, BFS, DFS를 잘 다루면 충분히 합격할 수 있는 수준이었던거 같아. 난 Javascript로 준비를 했다보니 우선순위큐, 순열 코드를 미리 준비했는데 다행이? 문제에 안쓰였어.

<br />

🙋🏻 **`고맙워 센세, 코테는 어떻게 준비했어?`**

나는 [프로그래머스의 카카오 lv2-3 문제](https://programmers.co.kr/learn/challenges)를 모두 풀었고 백준에서는 내가 취약하다고 생각되는 분야의 골드 2-5 문제를 풀었어. 백준 문제는 [여기 문제집](https://github.com/tony9402/baekjoon)을 참고했어. 백준에서 javascript를 쓰기 좀 번거로웠는데 좀 정리해봤어. 필요하면 [여기 코드](https://github.com/Egolper/beginners-tech-interview/blob/main/algorithm/baekjoon_nodejs.js)를 참고하면 될거 같아.

스터디에서는 같이 공부방향을 정하고 풀이법을 공유했어. 안 풀어오면 벌금을 때리고 ^^

<br />
<br />

---

## 2차 코딩테스트

🙋🏻 **`카카오는 코테 2번하던데? 뭐가 달라?`**

평소에 생각한 코딩테스트와 완전 달라. REST API 통신을 통해서 높은 점수를 획득해야해! 뭔가 인공지능 모델을 학습시키는 느낌과 뭔가 비슷한거 같아.

반드시 [**프로그래머스의 기출문제**](https://programmers.co.kr/skill_check_assignments/67)를 풀어 보고 [**문제해설**](https://tech.kakao.com/2021/02/16/2021-kakao-recruitment-round-2/)도 참고하길 바래. 문제가 실제 상황과 비슷하게 주어지는데 어뷰징이라는 상황도 있어. 정답이 있는 것이 아닌 높은 점수를 획득하는 것이 목표이기에 **문제의 제약상황을 잘 캐치해야되.**

자유롭게 IDE를 사용할 수 있어서 미리 사용할 통신모듈을 고르고 코드를 작성해두길 바래. 나도 스터디를 통해서 이런 정보를 알게되었고 코테 때서야 통신모듈을 끄적여야하는 불상사가 발생하지 않았어.

5시간 동안이었나 코딩해야하는데 시간이 빨리 가더라. 랭킹보드를 실시간으로 조회할 수 있는데 종료 30분 전에 마감이 되었던거 같아. 난 4번 정도? 나의 위치를 확인했는데 300등이었나.. 고수분들이 참 많드라 허허..

아 그리고 2차 코딩테스트에서 CS문제도 풀게 되!
🙋🏻 **`Computer Science 문제?`**
맞아, 객관식 8문제 주관식(단답식) 2문제가 나왔어. 알고리즘 전에 풀었는가 후에 풀었는가 기억은 잘 안나는데 검색은 허용이 안돼.

자료구조 문제가 좀더 많이 나온거 같고 CS를 어떻게 응용을 할까에 대한 문제야. 뭔가 수능 지문이랑 비슷했던거 같아. 제대로 알고 있지않는 한 찍어야 했고 그래서 나는 3-4문제 맞춘 것 같아 ㅎㅎ... 문제가 생각보다 어려워서 당시 멘탈이 탈탈 날라갔어.

<br />

🙋🏻 **`높은 점수를 얻는 꿀팁이 있어?`**

난 고득점을 한게 아니라 뭐라 말해주긴 그런데.. 문제 특성상 값을 튜닝해서 정답과 가장 근사하게 계산해내야 해. 그래서 나는 여러개 터미널를 켜서 다양한 값을 통신해서 점수를 최적화했어.

지문이 상당히? 길기에 차분하고 꼼꼼하게 읽어 보길바래. **사소한 제약사항을 놓치면 끔찍한 삽질을 반복할 수 있어.** 난 서버에 저장되는 값의 제한 범위를 놓여서 고생했어. 이렇게 저렇게 코드를 짜보는데 왜 점수가 그대로일까? 했는데 알고보니 내가 제출한 값이 제한 범위를 초과해서 서버에 적용이 안된 것이었어. 내 친구 중에서도 이와 같이 마음아픈 사연이 있었어 🥲

<br />
<br />

---

## 1차 인터뷰 ( feat. 직무역량 )

🙋🏻 **`와우 이제 1차 면접인가?!`**

맞아 그렇게 1지망으로 적었던 카카오 프로그래밍(본사)에 합격했어. CS문제 때문에 많이 쫄렸는데 다행이었어 🥲

여기부터 각 계열사에 따라서 진행 절차가 달라져. 나 같은 경우 서류를 별도로 제출해야했고 1시간 비대면 면접이 예정되었어. `미리만나는 카카오(미만카)` 세션도 준비 되어 있어서 어떠한 직무가 어떤 일을 하는지 들어볼 수 있어.

당시 미만카에서 내가 기록한 정보로는 아래와 같아.

```
프로그래밍 언어보다는 프로그래밍 공통적인 부분에 대해서 인터뷰가 진행될 예정이다.
일하는 방법 O  직무 경험 X
```

<br />

🙋🏻 **`어떻게 준비를 했어?!`**

스터디의 빛이 바래는 순간이야! ✨ **모의면접**을 진짜 많이 진행했어.
2-3일 텀으로 개인적으로 공부하고 받을 만한 질문을 스터디 깃허브 레포지토리에 정리했어. 이후 화상으로 2 대 1 면접을 진행하는데 30분 가량 질문을 하고 이에 피드벡을 했어. 막상 설명하려하니 말이 잘 안나오는 부분이 많았는데 사실 이는 제대로 이해하지 못했다는 증거인거 같애. 덕분에 나의 부족함을 좀 더 알고 대비할 수 있었던거 같아. 확실히 처음 때보다 실력이 많이 늘은게 체감이 되더라!

**스스로 공부하다 보면 우물의 개구리**가 될 수 있는데 ~~여전히 그렇지만~~ 혼자서는 접하기 힘들었던 지식를 스터디를 통해서 얻을 수 있었던거 같아 ( 물론 좀 TMI 지식일 수 있긴한데... 예를 들면 HTTP3, 샤딩, 함수형 프로그래밍의 Functor, Monad... ) 그리고 참고하면 좋을 링크를 주고 받았던게 학습에 도움이 되었던거 같아.

**면접관의 관점으로 면접을 바라볼 수 있어서 좋았어.** 장황하게 설명하는게 진짜 별로라고 생각이 들었거든. 에매하게 아는건 깔끔하게 모른다고 하고 아는건 핵심을 잘 전달해주는게 좋은거 같아. 그려면서 면접 전략도 세우게 되었는데, 바로 `키워드` 바탕으로 대답을 준비하는거야. 설명이 조금 부실하더라도 핵심 키워드가 면접관 귀에 들어가면 적어도 평타이상의 답변이 될거 같다고 생각했어.

우리가 스터디를 진행하면서 나름대로 정리해둔 [**📚면접준비 핸드북**](https://github.com/Egolper/beginners-tech-interview)가 있어! (아직 퀄리티가 높진 않아.. 계속 정리해보고 있어). 면접 준비하는데 도움이 되었으면 좋겠어. 우리가 참고한 다른 스터디 링크도 있어서 참고하길 바래!

뭔가 공부하면 할수록 공부해야할게 늘어나는 느낌이야... 스스로 결단을 해야할거 같아. 나는 딱 여기까지만 설명을 할거다 하는 마인드.

그렇게 2주의 시간이 흐르고 면접을 보게 되었어.

<br />

🙋🏻 **`오 드디어 면접! 내가 제일 궁금했던 거야! 면접 때 뭐 물어봤어?`**

정확히 어떤 질문을 했는진 말해줄 순 없고 어떻게 진행되었는지 말해줄게.

난 무난해보이는? 갈색 후리스 자켓을 입고 면접을 진행했어 ( 츄리닝 바지 입은건 안비밀 ). 면접관은 2분이셨고 긴장하지 말라고 잡담 몇마디 주고 받고 시작했어. 주로 큰 주제의 질문을 던져주고 **`🎅🏻 아는대로 말해보세요우!`** 하는 느낌이었어. 그 이후로부터 지옥의 꼬리 질문🔥이 이어가는 형식이야.

내가 생각해봤을 때 면접관이 원하는 사람은 단순히 지식을 아는 것이 아니라 공학적인 사고를 할 수 있는 사람인 것 같아. 그래서 **이 개념이 어떻게 다른 개념들과 연관이 되고 어떤 trade-off 관계가 있는지** 알아야해.
모든 지식을 아는 것을 기대하기 보단 기술을 제대로 이해하고 응용할 수 있음을 기대하는거 같아. 그래서 **애매하게 아는 것에 대해서 아는척 포장하지 말고, 잘 모른다고 인정하고 내가 잘 아는 것을 설명해가는 흐름**으로 면접을 유도하는게 좋을거 같아. 계속 내가 잘 모르는 것을 물어본다면 어쩔 수 없지 ㅠㅠ 더 공부해서 다음 기회에 도전하는 걸로.. 나도 2-3 질문에 어떻게든 대답하려하기보단 그냥 잘 모르겠습니다 대답하고 넘어간 것 같아. 기술면접준비가 참 어려운거 같아 🥲

**2차 코테에서 작성한 코드**에 대해서도 질의가 진행되었어. 다행이 난 스터디를 통해서 서로 코드에 대해서 질의를 했어서 당황하지 않고 대답할 수 있었어. 본인이 작성했는지, 어떤 흐름을 가지고 코드를 작성했는지 확인하는 느낌이야. 코드 제출전에 어느정도 리팩토링을 하면 좋을 것 같아.

나중에 알게되었는데 **면접진행방식은 면접관에 따라 천차만별이야.** 어떤분은 종이에 알고리즘을 작성했고 어떤분은 오로지 기술질문만 받았고 어떤 분은 자기소개 없이 면접이 진행되고 어떤 분은 프로그래밍 언어에 대해서도 물어보셨다고 해. 나는 라이브코딩을 한게 특징? 이라고 할 수 있어. ~~오히려 좋아~~

아 그리고 끝날 때 보통 2개 정도 질문을 받아. 그거는 날를 평가하기 보단 정말 나에게 도움을 주기 위한 세션이라고 느꼈어. 그래서 나를 어필할 질문을 하는게 아니라 내가 고민을 하는 것, 궁금한 것 편하게 물어봐도 될거 같아.

<br />

🙋🏻 **`난 전공자가 아닌데 괜찮을까?`**

난 전공자임에도 불구하고 처음부터 준비해야했어. 원래 학교 공부는 종강하는 순간 사라지는거잔어 ㅎㅎ.. 물론 면접준비하면서 학창시절 공부했던 것들이 조금씩 생각 나더라. 아 그분에게서 그걸 배웠었지... `🙋🏻 너 아직 학생이잔아..` ~~학교 가면 쥬라기 화석 취급 받아..~~ 암튼 못할게 없다고 생각해! 앞에 인형에게 혹은 거울앞에서 설명할 수 있으면 합격할 수 있을거야!

<br />
<br />

---

## 2차 인터뷰 ( feat. 조직적합도와 잠재력 )

🙋🏻 **`이제야 마지막 관문.. 산넘어 산이네.. 2차 면접은 어땟어??`**

비대면으로 40분 봤고 2분 면접관이 있어. 면접관들이 임원이여서 그런지 1차 면접관분들보다 나이가 있으셨고 질문을 던질 때 포스가 장난아니였던거 같아.. ~~짬에서 나오는 바이브 🎶~~

자기소개하고 기본적으로 서류에 작성한 내용에서 면접관들이 갖는 의문들에 대해서 질문을 해.
**면접관들은 자신이 납득이 될 때까지 (의문이 해소가 될 때까지) 꼬리질문이 들어오는 거 같아.** 뭔가 압박면접인 느낌이 들기도 했어. 구체적인 상황을 주어주면서 면접자의 생각, 행동, 선택을 유도하는 것 같아. 어설프게 답변을 포장하기보단 역시 솔직하게 내가 느끼고 판단하는 것을 대답하는게 정말 최선인거 같아..

단골로 물어보는게 본인의 장단점, 왜 개발을 하게되었는지, 맞닿았던 어려움에서 어떤 노력을 해서 해결을 했는지 그런 것들이 있는데 말그대로 묻기 보다는 면접 상황에서 유연하게, 더 구체적인 질문이 들어왔던거 같아. 내가 그동안 어떻게 협업을 했는지, 개발자로서 어떤 매력이 있는지 꼭 고민하길 바래.

면접 때 좀 풀만한 썰들이 있는데 ..,.^& () !@%

<br />

🙋🏻 **`와 내가 면접을 보는거 같네 ㅋㅋㅋ 혹시 준비하는 꿀팁이 있을까?`**

내가 개발을 시작한 본질을 파악하면 좋아! 너무 어려운 말인데 정말 솔직하게 내가 왜 개발을 시작했고 뭘 하고 싶은지 정리해야 할거 같아.

**Resume를 작성해보는 것**이 도움이 될거 같아. 이력서를 당장 내는 것은 아니지만 내가 뭘 했고 어떤 것을 경험했는지 사색을 할 수 있는 것 같아. [유투브](https://youtu.be/fv5pIa_l7ns)에서 듣기로 주기를 갖고 이력서를 관리하는 것이 좋다고 하더라구?
스터디 친구들과 함께 작성을 해봤는데 [이분의 이력서](https://wonny.space/writing/work/engineer-resume)를 참고하면 정말 도움이 될거야!

**답변을 외우는 연습말고 설명하는 연습을 하자.** 쇼미에서 참가자들이 괜히 가사를 절는게 아니야. 진짜 머릿속이 새하얗게 된다. [레전드 면접썰.](https://redtea.kr/fun/52391?id=fun&no=52391) 인성면접에는 면접관을 설득하는 세션인 느낌이 든다. ~~저를 꼽으셔야 하옵니다 ㅠ(간절)ㅠ~~ 거울을 보고 자신감 있게, 홈쇼핑에서 나를 판매하듯이. 면접전에 혼자서 Meets를 틀어서 이렇게 저렇게 설명하는 연습을 했다. 정말 도움이 되었던거 같아.

공채 특성상 본인이 관심별로 없는 직무, 팀을 배정 받을 가능성이 있어. 그래서 어떤 일을 하게 되도 정말 열심히 구를 수 있다, 팀에 기여하는 것에 큰 동기를 얻는다, 해당 회사에 입사하는 것이 간절하다... 그런 마인드셋을 가지고 면접을 가는게 좋을거 같아. 근데 어디까지나 본인 생각을 솔직하게 말하는게 최고야.

그리고 지원하는 회사가 원하는 인재상을 꼭 분석해보길 바래! [카카오의 문화](https://careers.kakao.com/kakaolife)

<br />
<br />

---

## 그리고, 합격 😭

![](https://images.velog.io/images/bepyan/post/ea72dea1-26bf-47e4-981e-231bc9089112/image.png)

🙋🏻 **`가슴이 웅장해지는 구나..`**

1-2일 정도 지연되었는데 그동안 정말 마음 쪼리고 기다렸던거 같아..
집에서 밥먹다가 메일 알림이 와서 바로 노트북앞으로 뛰처 갔어 ㅎㅎ 그리고 축제가 열렸지 🎉

확실히 네임드가 네임드인지,, 주변으로부터 정말 많이 축하 받았어 🥰
회사 이름만 들어도 자동반사 축하~!

아 근데 참고로 제일 많이 들은 말이

🧔🏻‍♂️ **`오 축하해~ 카카오 주식 싸게 살 수 없어?`**

🙋🏻 **`나도 주식 정보 좀...`**

🙋 **`...`**

고마워, 마지막으로 한마디를 할게.

![](https://images.velog.io/images/bepyan/post/e22b8f12-e25d-4490-a9ff-5790910d27d2/KakaoTalk_Photo_2021-12-20-01-37-48.jpeg)

![](https://images.velog.io/images/bepyan/post/c518285d-a8d0-42e1-bbea-297e5a539c99/KakaoTalk_Photo_2021-12-20-01-37-55.jpeg)

춘식이는 귀여워 💜
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="회고"/>
        <category label="커리어"/>
        <category label="신입 개발자"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022 카카오 신입 개발자의 1년 회고록]]></title>
        <id>/blog/retrospect/2022-in-kakao</id>
        <link href="https://bepyan.github.io/blog/retrospect/2022-in-kakao"/>
        <updated>2022-12-31T00:37:13.000Z</updated>
        <summary type="html"><![CDATA[이렇게 물경력이 쌓이는 것인가,,, 하지만 돌아보면 정말 많은 것을 수확했다.]]></summary>
        <content type="html"><![CDATA[
> ⚠️ 극히 개인적으로 느낀 것들 입니다. 가볍게 지나가 주세요. (\_ \_)

[**감격스로운 카카오 공채 합격**](/blog/retrospect/2021-pass-kakao)이 엊그제 같은데 벌써 1년이 지나 있다.
"와,, 이렇게 물경력이 쌓이는 것인가,,," 생각이 들기도 했지만 돌아보면 정말 많은 것들이 있었다.
조금은 진부하지만 그간의 경험과 생각을 조금이나마 기록해보고자 한다.

![고민](https://media.tenor.com/HHbDUjAOYE0AAAAC/worried-kermit.gif)

---

## 나의 타임라인

무엇을 했는지 정리하려면 역시 타임라인만한 것이 없다.
모든 것을 담아내기 어렵지만 그래도 큼지막하게 정리해보았다.

| 연도             | 이벤트                                     |
| ---------------- | ------------------------------------------ |
| 21.11.29 ~ 22.02 | 카카오 입사 ✨ 온보딩 진행                 |
| 22.03 ~          | 브런치 서비스 합류                         |
| 22.04 ~ 05       | grunt -> webpack 전환, 테스트 코드 도입    |
| 22.06 ~ 07       | 모니터링 시스템 고도화, 개발 컨벤션 재구축 |
| 22.08            | 제 10회 브런치북 출판 프로젝트, MVI        |
| 22.09            | if kakao 촬영 "브런치 심폐소생술"          |
| 22.10            | 🏢🔥                                       |
| 22.11 ~ 12       | 경로 리소스 대청소                         |

---

### 카카오 온보딩

공통 온보딩, 직무 온보딩, 기술 온보딩 과정으로 3달 가까이 교육이 진행되었고
[**CodeSquad**](https://codesquad.kr/)의 크롱이 1달 동안 기술 온보딩(FE 교육)을 맡아주셨다.

사실 다른 것은 거의 기억이 안나고 기술 온보딩 때 열심히 삽질한 경험이 남게 되었던 것 같았다.
좋았던 것은 그저 숙제에 대해 점검하는 것이 아닌 **과제의 큰 틀만 주고 스스로 탐구하고픈 영역을 설정하고 이를 점검해주는 형태로 교육이 진행**되었다는 것이다.
그러면서 평소 접하기 힘들었을 BEM, Glassmorphism, VAC 패턴, stitches 등을 사용해볼 수 있게 되었다.

- **w1**
  - https://github.com/bepyan/fe-w1-kakaopage
  - HTML 마크업
  - vanillaJS
- **w2,3**
  - https://github.com/bepyan/fe-w23-shoppinghow
  - vanillaJS (+ throttle)
  - babel, webpack
  - BEM styles rules
- **w4**
  - https://github.com/bepyan/fe-w4-vending-machine
  - React
  - Glassmorphism
- **w4,5**
  - https://github.com/bepyan/fe-w4-issue-tracker
  - express (JWT, OAuth)
  - React (+ VAC 패턴)
  - stitches

교육이 진행되면서 기술공유해주는 세션이 있는데 css-in-js 라이브러리를 조사한 것을 정리해서 발표를 했고 [velog 글](https://velog.io/@bepyan/CSS-in-JS-라이브러리에-대한-고찰)로도 정리를 했었다. 생각보다 정리한 글이 여러 사람에게 도움이 된 것 같아 많이 뿌듯했다.
돈을 받고 편하게 공부를 한다니,, 개인적으로 이 때가 가장 걱정없이 편하게 시간을 보냈던 것 같다. ~~물론 그 당시엔 학습에 찌들렸던...~~

---

### 브런치 레거시 개선

올해는 브런치 레거시 환경과 내내 싸웠다고 봐도 무방한 것 같다. 이게 [**if kakao 발표**](https://if.kakao.com/2022/session/76)까지 가게될지도 몰랐다..
대충 한마디로 요약하자면 **webpack을 도입하여 es6 기반의 코드를 쉽게 작성할 수 있게 되었다**.

발표에 대해서도 좀 할말이 많다만..
지금 다시 생각을 정리해보면 발표 때와 생각이 많이 바꿨다. 조금 옛날스러운 javascript의 구현 방식은 사실 큰 문제가 아니였다. 브런치가 관리하기 어렵게된 것은 결국 **Java와 Javascript 진영간의 괴리이다.**

브런치는 기본적으로 SSR로 서비스를 제공한다.
서버 사이드의 데이터를 템플릿 엔진([**velocity**](https://velocity.apache.org/))을 통해 마크업을 다루거나 js 단으로 데이터를 넘긴다.
js 단에서는 또 뷰 엔진([**handlebars**](https://handlebarsjs.com/))를 활용하여 마크업을 다룬다.

이 과정을 제대로 이해하기 못한 상황에서 이슈를 대응하려하니 머리가 터지게 되는 것이다.
문제를 해결하려면 탐색해야하는 파일들이 무척이나 많고 4개의 문법을 넘나들고 개발 편법까지 이해해가야 했다.
사실 이들(velocity, handlebars)는 요즘것들에 비해 **문법이 유연하지 못하고 intellisense가 부실**해 개발자가 실수하기 무척 쉽다. ~~실제로 관련해서 크게 손대다가 4번의 prod hotfix를 진행한 경험이 있다..~~
javascript 내에서의 로직은 이에 비해 사소했던 것 같다. 어짜피 비즈니스 로직이 복잡해지면 ES6든, ES3이든 다루기 어려운 코드가 된다. 해법은 프레임워크, 라이브러리의 도움을 받는것...

이 괴리를 줄이기 위해서 초기에는 패턴을 도입해서 js 중심으로 리팩토링을 하려했으나, 이젠 **velocity에서의 Java를 잘 사용하기, svelte 도입**하는 방향으로 나아가려하고 있다.

그리고 테스트 코드에 대해서도 솔직한 한마디를 메모하자면, **TDD를 하지 않으면 테스트 코드는 실질적인 도움이 되진 않는다.** ~~다만 명분이 좋아 다른 사람들에게 이를 쉽게 내세울 수 있다.~~

---

### 사내 스터디, 행사

카카오답게 자유롭게 스터디, 행사에 참여할 수 있었다.

- 리팩토링 2판 독서 스터디
- 헤드 퍼스트 디자인 패턴 독서 스터디
- phaser3로 javascript 게임 만들기 스터디
- 북마크(기술 블로그 글) 공유 스터디
- if kakao 세션 발표
- K24 해커톤
- 함께 자라기 (DND 마스터 시리즈, 블로그 제작기)
- 6 nimmt! 보드게임 알고리즘 행사
- 단체티 제작 TF
- 팀 정기 발표

하나 하나 느낀 점들이 있지만 글로 정리하기엔 끝도 없을 것 같다.. 이래서 분기별로 글을 정리해야 하나..
이 역시 한마디 메모하자면 **남한테서 얻어내려하기 보단 스스로 탐구해 가려 할 때 더 많은 수확이 있었던 것 같다.**

---

## 나의 깨닳음

생각을 정리하면서 맺혀지는 깨닳음이 있었다.

![암튼 수련임](https://media.tenor.com/B37J0OvzgVoAAAAC/kermit-the-frog-kermit.gif)

---

### 성장이란 무엇인가?

신입 개발자로서 '성장'은 정말 중요한 키워드인 것 같다.
회사를 선택할 때 고려되는 가장 중요한 것 중에 하나이다.
그렇다면 과연 성장이란 무엇이고 난 카카오에서 1년간 얼마나 성장했을까?

성장에 대해 정말 다양한 정의를 내릴 수 있지만 개인적으로 soso님의 정의가 가장 마음에 와닿았다.

> **"나만의 관점이 많아지는 것"** > https://so-so.dev/essay/no-silver-bullet/

크게 두 가지 의미를 내포하는 것 같다.

<br />

첫번째는 **지식과 경험은 우리로 하여금 `관점`을 갖게 한다**는 점이다.

우리는 늘상 새로운 지식을 습득하고 경험이 축적된다. 그리고 지식과 경험은 우리로 하여금 관점을 갖게 한다.
지식이 없으면 그 어떠한 판단을 내릴 수 없고 경험이 없으면 결과에 대해 예측하기 어려운 이유이기도 하다.
아래와 같은 간단한 예시를 들 수 있을 것 같다.

> webpack는 번들링과 컴파일에 있어 상당히 유연한 설정을 갖추고 있다.
> : webpack으로 파편화된 번들, 빌드 과정을 통합시켜 목표하는 코드 베이스를 쉽게 구축할 수 있다.

> ==가 ===로만 바꿔도 사이드 이펙트가 발생될 수 있다.
> : 무턱 레거시 코드에 eslint auto fix를 돌리면 사고가 일어날 수 있다.

이런 작은 지식, 작은 경험이 하나 하나 축척되어 큰 관점을 갖게 되기도 한다.
이를 테면 '좋은 코드란 무엇인가?', '리팩토링을 어떻게 해가는게 좋을까?'와 같은 무거운 질문에 대한 관점이다.

**관점을 갖춘 개발자는 매력적이다.** 정답이 없는 상황을 명확한 기준으로 헤쳐가기 때문이다.
[공채면접](https://bepyan.github.io/blog/retrospect/2021-pass-kakao#1%EC%B0%A8-%EC%9D%B8%ED%84%B0%EB%B7%B0--feat-%EC%A7%81%EB%AC%B4%EC%97%AD%EB%9F%89-)에서도 이를 느낄 수 있었다. 기업은 단순히 전문 지식을 많이 갖춘 지원자가 아닌 기술적인 연관관계, trade-off를 잘 설명할 수 있는 지원자를 원한다. 우린 종종 '남의 지식을 나의 것으로 만들어야 한다.'의 말을 듣곤 하는데 이와 같은 맥락이지않을까 생각한다.

<br />

두번째론 **성장은 `나`를 기준으로 상대적**이라는 것이다.

물론 나의 관점이 잘못되었을 수도 있고 그 깊이가 엷을 수도 있다.
하지만 어제의 나보다 더 나은, 더 풍부한 관점을 갖춘 것 자체가 성장이다.
따라서 내 옆에 있는 누구와 비교할 필요 없이 나만의 관점이 생긴 것 자체로 의미가 있고 칭찬할 일이다.

내가 새롭게 갖게된 관점을 정리하다보면 나의 성장이 눈에 띄게 나타나는 것 같다.

<br />

나의 성장을 소소하게 나눠보자면, 나는 **레거시 시스템을 어떻게 다뤄야하는지**에 대해 막연한 관점이 생긴 것 같다.
**그 당시 '최선'이었을 코딩 방식을 이해하고 최대한 그대로 이어서 유지보수하는 것**이다. 어떻게든 최신 세련된 코딩 방식을 도입하려는 건 오히려 시스템을 더 더럽게 만드는 것 같다. 만약 도저히 손을 댈 수 없다면 시스템 통째로 가라엎는 것이 더 빠를 수도 있다. 그리고 부족한 코딩 컨벤션 채워가고, 테스트할 수 있는, 모니터링되는 환경을 구축하는 것이다.

---

### 어떤 사람이 꼰대인가?

꼰대에 대한 정의를 내리라고 한다면 2가지 포인트가 생각이 나는 것 같다.

- **나의 관념을 상대방에게 강요하거나 주입하는 사람.**
- **상대방에게 관심을 갖지 않고 그저 내가 하고 싶은 얘기를 던지는 사람.**

나는 종종 상대방을 꼰대로 평가했었다.
할아버지와 대화를 나누면 참 답답한 구석이 있었다. **'그게 왜 그런가면...'** 논리가 꼬리를 물고 1시간 내내 반복되는 것이다.
할아버지 인생의 지혜를 무시하는 것이 아니지만 나는 그 순간 할아버지가 너무 꼰대스럽다고 생각했다.

> '왜 상대방이 관심 없을 얘기를 저렇게 늘어뜨리지?'
> '왜 자기 경험과 생각을 풀지 못해 안달일까?'

하지만 언젠가 돌아보니 내가 그런 사람이 되어 있는 것 같았다.
제대로 의견을 충돌시키지 않고 그저 나의 생각, 나의 의견에 굳혀져 있던 것이다.
구체적인 예시를 꼽긴 힘들지만 이는 계속 자신을 자각해야 문제임은 확실하다.

좋은 조직장, 상사가에 대해 생각을 하게 되었을 때도 이와 일맥상통한 부분이 있다.
대화를 나눌 때 비록 평소에 친분이 없음에도 '아 정말 나에게 관심이 있는구나!'라고 느낄 때 상대방에 대한 호감도가 수직상승했던 것 같다.
상대방에게 포커스를 두고, 상대방이 관심을 가질 만한, 도움이 될 만한 포인트를 가지고 대화를 이어가는 것이다.

그저 뻔한 소리이기는 하지만 중요한 것은 결국 **상대방에 대한 관심**인 것 같다.

---

### 좋은 문화는 나의 행동으로 맺어진다.

카카오는 정~~말 [좋은 문화](https://www.kakaocorp.com/page/kakao/kakaoCulture)를 갖고 있다.
그러나 아쉽다고 생각되는게 이는 **용두사미**(龍頭蛇尾)하다는 것이다.

100:0 원칙이 있다면 뭐하나, 사내 정책을 공유되자마자 언론에 노출이 되고 심지어 언론을 통해서 먼저 알게 되기도 한다.
'신충헌'이 있으면 뭐하나, 거세게 충돌하고 헌신할 생각이 없이 자기 주장을 그저 밀고 들어 간다.
...

너무나 멋진 문화이지만 정작 조직 내에서 이를 행하는 사람이 잘 보이지 않는 것 같다.
**내가 행동하지 않기 때문이다.**

문화라는 것은 한 사람에게서 이뤄지는 것이 아니다. 사람들의 상호작용이 이뤄졌을 때 문화가 탄생된다.
내가 그 상호작용에 참여하지 않고 있는데 어떻게 그 문화를 경험할 수 있는가?

의견을 나누는 자리에서 기껏 자신의 생각을 충돌해보고, 상대방이 옮을 수 있다는 믿음을 갖고 질문하고 경청해보고..
관망하는 것이 아닌 행하였을 때 비로소 팀의 문화를 알 수 있다.

회의감을 가지고 불평하기 보단 **나의 행동으로 좋은 문화를 맺어보자!**

---

## 나의 NEXT

![2023 last dance](https://media.tenor.com/QUCs1atnbWQAAAAM/muppets-muppet-show.gif)

**브런치 리팩토링 ongoing**
솔직히 브런치 서비스에 오래 발을 담고 싶지는 않다. 돈을 버는 서비스가 아니고 활발하게 발전하지도 못한다.
그래도 1년 정도는 더 주도적으로 부딪혀서 값진 경험을 할 수 있을 것 같다.
svelte의 고도화가 기대된다.

**다양한 취미를 누비기**
코로나가 있기도 했지만 올 한해는 개발에 많은 포커스를 맞춰왔던 것 같다.
전문성을 키워가는건 좋지만 그것에 올인하는 것은 삶이 장기적으로 건강하진 못할 것 같다.
예전 취미 많던 시절 돌아가 풍성한 삶은 좀 이어가보면 어떨까? ~~그럼 연애부터...~~
겨울에 스키 타기, 화방(그림 그리기) 다니기, 비트 메이깅 해보기, 음료 제작 입문하기, 헬스 관련 첼린지 도전하기...

**코드 리뷰어로 활동해보기**
촌놈이 시내 구경하는 느낌이랄까? 암튼 재밋을 것 같다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="회고"/>
        <category label="커리어"/>
        <category label="주니어 개발자"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[이번 물경력일까 불경력일까?]]></title>
        <id>/blog/retrospect/2022-water-career</id>
        <link href="https://bepyan.github.io/blog/retrospect/2022-water-career"/>
        <updated>2023-01-27T22:06:43.000Z</updated>
        <summary type="html"><![CDATA[감격스로운 카카오 공채 합격 1년 후, 나는 물경력을 쌓은 것일까 🥹]]></summary>
        <content type="html"><![CDATA[
![](https://velog.velcdn.com/images/bepyan/post/3048dbfd-0d2b-4aa5-9649-f853f23a7a36/image.gif)

[**감격스로운 카카오 공채 합격**](/blog/retrospect/2021-pass-kakao)이 엊그제 같은데 벌써 1년이 지나있다.
이제 신입 공채분들이 온보딩 교육을 받으면서 나의 신입 버프도 끝이 보인다.

그래서 나의 1년은 물경력이 된 것일까 🥹
너무나 맴찢할 주제이지만 이에 대해 파고들 수밖에 없었다.

> 극히 개인적인 경험과 생각이 담긴 글입니다. 저런 사람도 있구나 가볍게 지나쳐 주세요.

<br />

---

## 물경력이란?

정의를 제대로 알아야지 판가름을 내릴 수 있을 것 같다.
안타깝게도 '**물경력**'은 사전에 없는 단어이다..~~(충격)~~.. 그래서 사람마다 다른 정의를 내릴 수 있다.

나의 뇌피셜로는 [물수능](https://namu.wiki/w/%EB%AC%BC%EC%88%98%EB%8A%A5), 불수능이라는 단어에서 나오지 않았을까 싶다.
쉬운 수능 → 물렁물렁한 수능 → 입시 변별력이 떨어지는 수능

따라서 물경력이란 **직무에 대해 변별력이 없는 경력**이라 볼 수 있다.
의미를 좀 더 풀어서 설명하면 아래 요소들이 있을 것 같다.

- 이직할 때 인정을 받지 못할 경력
- 누구나 할 수 있는 사무보조, 잡무 등의 반복으로 내세울 만한 것이 없는 경력
- 성과가 없는 경력
- 성장이 정체된 경력

어떻게 물렁물렁한지에 대해서는 두 가지 상태로 생각해볼 수 있을 것 같다.

- 어디서나 인정받지 못할 경력
- 내가 인정받고 싶은 부분과 관련이 없는 경력

어디서나 인정받기 어려운, **철저하게 물렁한 경력**이 있고
내가 하고 싶은 일과는 관련이 없는, **상대적으로 물렁한 경력**이 있다.

철저하게 물렁한 경력이라면, 프로젝트성 경험이 없는 경력이라 할 수 있다.
프론트엔드 개발자로서 1년을 일했지만, 단순히 기획요청에 따라 화면의 글자를 바꾸고 버그 제보에 대응하기 위해 `if-else`만 잔뜩 쌓는 경우가 있을 수 있다. 성과가 없고 성장이 정체되고 잡무가 반복되는 상황이다. ~~써놓고 보니 너무나 맴찢이다 ㅠㅠ~~ 


상대적으로 물렁한 경력의 예를 들자면, 나는 백엔드 개발자로서 역량을 키워가고 싶은데 자꾸만 프론트엔드 관련 프로젝트 경험이 쌓는 경우가 있다. 물론 백엔드 개발자로서 어느 정도는 마크업을 다룰 줄 알아야 하지만 3년 차가 되었는데 기초적인 API, DB 다루는 경험만 있고 프론트엔드 관련 프로젝트 경험이 많다면 백엔드 개발자보단 풀 스텍 개발자로서 더 경력을 인정받게 될 것이다. ~~오히려 좋은 건가...~~ 결국 벡인드 개발자로선 물렁한 경력이 쌓였다고 볼 수 있다.

<br />
<br />

---

## 내 경력은?

그렇다면 이제 내 경력의 상태를 살펴보도록 하자.
참고로 나는 22년 3월에 브런치 서비스에 FE로 합류했고 아래와 같이 경력을 정리할 수 있다. 
(자세한 나의 1년 회고는 [여기 참고](https://bepyan.github.io/blog/retrospect/2022-in-kakao)) 

- 번들러 교체 (grunt → webpack)
- 모니터링 시스템 고도화, 테스트 환경 구축 (jest, jest snapshot, cypress)
- 개발환경 컨벤션 구축 (eslint, 개발 정책 문서화)
- 운영 이슈 대응 (부분적으로 기능, 페이지 리팩토링)
- [제10회 브런치북 출판 프로젝트](https://brunch.co.kr/brunchbookproject/10) 관련 페이지 제작 (spring, jQuery, css)
- 2번 사내 세미나 발표, [if-kakao](https://if.kakao.com/2022/session/76) 발표 참여
- 5개 사내 스터디 참여

먼저 스스로 총평하자면 **물렁한 경력**인 것 같다.
개인적으로는 신규 서비스가 자리를 잘 잡을 수 있도록 리딩하는 멋진 FE 개발자가 되고 싶다. ~~꿈이 큰 코린이..~~
무난하게 업무 경험을 쌓인 것 같지만 두루두루 인정받긴 어려운 것 같다.

[카카오](https://careers.kakao.com/jobs?skilset=Web_front&part=TECHNOLOGY&keyword=&page=1), [네이버](https://recruit.navercorp.com/rcrt/list.do?srchClassCd=1000000), [라인](https://careers.linecorp.com/ko/jobs?ca=All&ci=Seoul,Bundang&co=East%20Asia), [배민](https://career.woowahan.com/#recruit-list), [토스](https://toss.im/career/jobs?company=%EC%A0%84%EC%B2%B4&category=engineering-platform), [당근](https://team.daangn.com/jobs/engineering-frontend/#_filter) 등 인싸 기업들이 요구하는 경력 역량을 찾아보면 아래와 같은 공통점이 있다.
- HTML, CSS, JavaScript(ES6+)에 대한 이해가 깊은 분
- React, Vue, Angular 등 SPA 프레임워크 사용에 능숙한 분
- Vite, Webpack 등 다양한 번들러에 대한 이해가 깊으신 분
- TypeScript와 같은 JS 정적 타이핑 툴 경험
- 웹사이트 성능 측정 및 최적화 경험 (런타임과 빌드타임 퍼포먼스를 개선한 경험)
- 웹 표준을 준수하며 제품을 만들었던 경험
- 서버 사이드 렌더링(SSR) 및 모바일 앱 내 웹앱 개발 경험
- Redux, Zustand, Recoil 등 다양한 상태관리 패턴을 사용한 경험
- 기존 소스 코드를 새로운 코드 베이스로 점진적으로 이관한 경험
- Git 등의 형상 관리 도구 및 CI 도구 이용에 능숙한 분
- 단순히 주어진 개발을 해내는 것보다, 주도적으로 문제를 발견하고 분석해 솔루션을 제안할 수 있는 분
- 디자인, 기획, 개발 간의 협업을 진행해보신 분

내가 부족한 부분이 너무나도 많다.. 무엇 하나 자신 있게 내세울 수 없는 것 같다..

잠깐 신세 한탄하고 넘어가야 할 것 같다..

![](https://velog.velcdn.com/images/bepyan/post/b3b2243f-95a4-4568-9c7f-c7e21f1755aa/image.gif)

7년이 넘는 시간이 쌓인 서비스가 1년간 개발자 공백이 발생하었고 여기에 나를 포함한 FE 2명이 투입되었다. 제대로 된 인수인계는 기대하기 어려웠고 찾아볼 수 있는 코드 히스토리는 너무나 빈약했다. 당시 기술 스택인 Spring, velocity, jQuery, handlebars, grunt, ES3 이건 뭐 다 처음 접했던 거라 어떻게 서로 얽혀 있는지도 모르고 어디서부터 손을 대야 할지 감도 안 잡혔다.

잦은 경영진 교체로 기획되었던 여러 프로젝트가 무산되어 타 직무와 활발하게 협업할 기회가 사라지고 시스템을 크게 뜯어고칠 기회도 사라졌다. 프레임워크, Typescript는 꿈도 못 꾸고 ES6 기반으로 이래저래 리팩토링을 해봤지만, 맛만 본 정도지 제대로 된 수확은 없었다. 에디터에서 종종 원인을 알 수 없는 버그가 나타나는 것을 알게 되었지만, 감히 그 심오한 에디터 코드를 건들지도 못했다. 테스트 코드도 드디어 경험해보았지만, 요구사항이 자주 변경되는지라 TDD를 하지 못해 그의 효능에 대한 아쉬움이 크다. 사내 스터디를 정말 재밌게 참여했지만, 실무에 직접적으로 도움이 되진 못했고 발표에서 어떻게 내용을 잘 전달할 수 있는지 아직은 잘 모르겠다.

현업에서 저런 경험을 할 수는 있는 것입니까 ㅠㅠㅠㅠ

그래도.. 올해는 고무적이다!
이제야 시스템이 좀 이해돼서 어떤 방식을 레거시 코드를 다루고 개선해가야 할지 감이 왔다. 신규 프로젝트들이 다시 시동이 걸렸고 svelte, vite, typescript, 성능개선 등 흥미로운 것들을 파고 들어갈 수 있을 것 같다. 회사 이미지는 박살나고 있지만 아직은 워라벨도 만족하고 내 곁에는 좋은 동료들이 있다!
~~기다려랴 불경력(?)~~

<br />
<br />

---

## 대.. 대안은? 

물경력이 쌓이는 것 같을 때 어떻게 하면 좋을까?
경험치 쪼랩이지만 지렁이도 밟으면 꿈틀거린다고 내가 취해볼 수 있는 대안을 쥐어 짜봤다

**일을 물어오자.**
보통은 top-down 방식으로 일을 주고 내가 하고 싶은 일을 못 할 때가 많다.
그렇다면 내가 하고 싶은 일을 물어올 순 없을까?
가장 중요한 것은 **팀원의 공감대를 점진적으로 형성**하는 것 같다.
- 자신이 아무리 확신이 있다고 해도 팀원들이 공감하지 못한다면 일이 진행되기 어렵다. 
- 팀원들이 모두 동일한 눈높이를 가진 것이 아니기에 작업에 대한 지식, trade-off가 팀원들에게 공유되어야 이에 대한 토론을 진행할 수 있다.
- 설득하기보단 상대 의견에 포커스하여 생각의 격차를 좁혀가는 것이 좋다. 내가 고려하지 못한 부분이 있을 수 있고 상대방이 더 옳을 수 있기 때문이다. 
- 티타임 때 기술적 잡담을 시도해볼 수 있고, 팀미팅 때 세미나를 제안해볼 수 있을 것 같다. 
- 리소스 문제, 일정 문제로 바로 시행되긴 어렵지만 이렇게 공감대가 어느 정도 형성되어 있다면 팀에서 여유가 생길 때 쉽게 작업을 착수할 수 있을 것이다.
- ~~죄송합니다.. 행복회로 풀로 돌렸습니다...~~

이것이야말로 주도적으로 문제를 발견하고 분석해 솔루션을 제안하는 경험 아닐까 싶다.

<br />

**사이드 프로젝트, 토이 프로젝트 진행.**
솔직히 업무로만은 다양한 개발 경험을 쌓긴 어려운 것 같다.
공부해보고 싶은 것을 혼자서 시작해봐도 좋고, IT 커뮤니티에 참여하여 열정 넘치는 분들과 함께해도 좋은 것 같다.
일상에 무리가 안 될 정도로 꾸준히 진행하는 것이 중요한 것 같다.


<br />

**간접 경험 늘리기.**
비슷한 작업을 진행한 사람과 잡담해보는 것이다. 개발에는 정답이 없는 만큼 비슷한 작업을 여러 방법으로 진행할 수 있다. 내가 직접 해보진 않았지만 이 간접 경험으로 새로운 관점이 생길 수도 있다. ~~이거 뭐 완전 경험치 2배 쿠폰인 것 아닌가?~~

<br />

**~~탈출은 지능순...~~**
현재 환경에서 더 이상 변별력 있는 경험을 할 수 없다면 새로운 환경에서 도전을 이어가 봐야지 않을까?

<br />
<br />

---

## 맺으면서

글을 다 쓰고 보니, 운 좋게 좋은 회사에 들어가서 안 짤리면 다행이지 이건 무슨 배부른 고민이지 싶긴 하다. 앞으로 10년(?)은 개발할텐데 성급하게 판단할 필요도 없다. 오히려 장기적으로 봐서 건강한 삶에 대해 더 고민해봐야지 않을까 싶다. ~~망할 거북목...~~ 아, 요즘 아침마다 레모나 하나씩 먹고 있는데 강력히 추천하는 바이다. 피로가 싹 풀린다!

긴 글 읽어주셔서 감사합니다, 주니어 개발자 분들 모두 화이팅입니다 💚

<br />
<br />

참고해보면 좋은 글
- https://www.jobplanet.co.kr/contents/news-3477
- https://brunch.co.kr/@sunnysohn/49
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="회고"/>
        <category label="커리어"/>
        <category label="주니어 개발자"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[回顧錄 (회고록)]]></title>
        <id>/blog/retrospect</id>
        <link href="https://bepyan.github.io/blog/retrospect"/>
        <updated>2021-11-29T15:13:40.000Z</updated>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="회고"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(gsap) Card Hover]]></title>
        <id>/snippets/animation/card-hover-gsap</id>
        <link href="https://bepyan.github.io/snippets/animation/card-hover-gsap"/>
        <updated>2022-12-20T23:32:05.000Z</updated>
        <content type="html"><![CDATA[
```shell
yarn add gsap
```

```tsx
import { gsap } from 'gsap';
import { useCallback, useState } from 'react';

export default function Test() {
  const [cardElement, setCardElement] = useState<HTMLDivElement | null>(null);

  const setTransformVariable: React.MouseEventHandler<HTMLDivElement> = useCallback(
    (e) => {
      if (cardElement != null) {
        const bounds = cardElement.getBoundingClientRect();

        const mouseX = e.clientX;
        const mouseY = e.clientY;
        const leftX = mouseX - bounds.x;
        const topY = mouseY - bounds.y;

        const cardX = leftX - bounds.width / 2;
        const cardY = topY - bounds.height / 2;

        const cardRotateX = cardY / 100;
        const cardRotateY = (-1 * cardX) / 100;

        gsap.to(cardElement, {
          scale: 1.07,
          rotateX: cardRotateX * 5,
          rotateY: cardRotateY * 5,
        });
      }
    },
    [cardElement],
  );

  const clearTransformVariable = useCallback(() => {
    if (cardElement != null) {
      gsap.to(cardElement, {
        scale: 1,
        rotateX: 0,
        rotateY: 0,
      });
    }
  }, [cardElement]);

  return (
    <div>
      <div
        className="card-root"
        onMouseMove={setTransformVariable}
        onMouseLeave={clearTransformVariable}
      >
        <div className="card" ref={setCardElement}></div>
      </div>

      <style jsx>{`
        .card-root {
          display: flex;
          justify-content: center;
          align-items: center;
          perspective: 800px;
          padding: 50px;
        }

        .card {
          display: flex;
          flex-direction: column;

          width: 320px;
          height: 490px;
          box-shadow: 0px 24px 72px rgba(36, 42, 48, 0.3), inset 0px 0px 0px 1px rgba(0, 0, 0, 0.08);
          border-radius: 16px;

          transition: all 300ms ease-out;
        }
      `}</style>
    </div>
  );
}
```

---

**참고 자료**

- https://uing.gatsbyjs.io/dynamic-card/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <category label="css"/>
        <category label="gasp"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) backdrop]]></title>
        <id>/snippets/css/backdrop</id>
        <link href="https://bepyan.github.io/snippets/css/backdrop"/>
        <updated>2023-01-31T23:22:03.000Z</updated>
        <content type="html"><![CDATA[
현재 블로그에서 `command + k`를 눌렀을 때 보이는 `backdrop` 스타일입니다 😉

```html
<div
  className="pointer-events-none fixed inset-0 h-full w-full bg-white/50 backdrop-blur dark:bg-black/50"
/>
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <category label="tailwindcss"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) font-face 적용]]></title>
        <id>/snippets/css/font-face</id>
        <link href="https://bepyan.github.io/snippets/css/font-face"/>
        <updated>2022-12-06T21:24:10.000Z</updated>
        <content type="html"><![CDATA[
stitches에서 font-face를 적용하려하는데 계속 실패를했다...

[시키는 대로](https://stitches.dev/docs/styling#font-face-rules) 했는데 말이다 🥲

webpack 관련 문제일까... 결국 css파일로 문제를 해결했다!

[webpack](https://webpack.js.org/guides/asset-management/)에서 말하는 폰트를 가져오는 법

```jsx
module: {
  rules: [
    {
      test: /\.css$/i,
      use: ['style-loader', 'css-loader'],
    },
		{
      test: /\.(woff|woff2|eot|ttf|otf)$/i,
      type: 'asset/resource',
    },
  ],
},
```

css

```jsx
@font-face {
  font-family: 'Noto Sans KR';
  src: local('Noto Sans KR'), url('../assets/fonts/NotoSansKR-Regular.otf');
}
```

`local`

로컬 컴퓨터에서 해당 폰트가 있으면 그것을 사용

`url`

링크할 url 경로

**폰트의 weight을 적용시키는 법**

---

```css
@font-face {
  font-family: 'Noto Sans KR';
  src: local('Noto Sans KR'), url('../assets/fonts/NotoSansKR-Regular.otf');
  font-weight: 400;
}

@font-face {
  font-family: 'Noto Sans KR';
  src: url('../assets/fonts/NotoSansKR-Medium.otf');
  font-weight: 500;
}

@font-face {
  font-family: 'Noto Sans KR';
  src: url('../assets/fonts/NotoSansKR-Bold.otf');
  font-weight: 700;
}
```

글씨 폰트를 하나의 font-family에 묶을 수 있다.

---

**참고 자료**

- https://developer.mozilla.org/ko/docs/Web/CSS/@font-face
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) input focus시 border 제거]]></title>
        <id>/snippets/css/input-focus</id>
        <link href="https://bepyan.github.io/snippets/css/input-focus"/>
        <updated>2022-12-17T18:29:43.000Z</updated>
        <content type="html"><![CDATA[
`input`이 포커스 될 시 스타일은 [`outline`](https://developer.mozilla.org/ko/docs/Web/CSS/outline) 속성이 활용된다.

```css
input:focus {
  outline: none;
}
```

<br />

`tailwind`

```html
<input className="focus:outline-none" />
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) svg 넣기]]></title>
        <id>/snippets/css/insert-svg</id>
        <link href="https://bepyan.github.io/snippets/css/insert-svg"/>
        <updated>2022-11-25T21:22:31.000Z</updated>
        <content type="html"><![CDATA[
기본적으로 `content` 속성에 url로 svg 이미지를 넣을 수 있다.

https://stackoverflow.com/questions/19255296/is-there-a-way-to-use-svg-as-content-in-a-pseudo-element-before-or-after

```tsx
#test::before {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='100' cy='50' r='40' stroke='black' stroke-width='2' fill='red'/%3E%3Cpolyline points='20,20 40,25 60,40 80,120 120,140 200,180' style='fill:none;stroke:black;stroke-width:3'/%3E%3C/svg%3E ");
  width: 200px;
  height: 200px;
}
```

기존 svg를 url형태로 파싱을 해야하는데 아래 사이트에서 도움을 받을 수 있다.

https://yoksel.github.io/url-encoder/

하지만 만약 색상을 동적으로 변경을 해야한다면?

`mask-image`을 활용한다.

https://codepen.io/noahblon/post/coloring-svgs-in-css-background-images

```tsx
.icon {
    background-color: red;
    -webkit-mask-image: url(icon.svg);
    mask-image: url(icon.svg);
}
```

https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image#browser_compatibility

브라우저 호환성이 조..금 빡세다.

위치를 조정하고 싶다면?

`mask-position` 을 활용하자.

https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Backgrounds_and_Borders/Resizing_background_images

```tsx
.prose .anchor:after {
  content: ' ';
  mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' aria-hidden='true'%3E%3Cpath d='M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10' stroke='currentColor' strokeWidth='1.5' strokeLinecap='round' /%3E%3C/svg%3E");
  mask-repeat: no-repeat;
  mask-position: center;

  @apply h-4 w-4 bg-gray-700 dark:bg-gray-300;
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) 특정 영역만 상위 클래스 영향 안 받기]]></title>
        <id>/snippets/css/no-dark</id>
        <link href="https://bepyan.github.io/snippets/css/no-dark"/>
        <updated>2023-01-10T19:30:18.000Z</updated>
        <content type="html"><![CDATA[
다크모드에서 특정 영역만 다크모드 스타일이 적용되지 않길 바랄 때가 있다.

---

## 해결 방법

[`:not`](https://developer.mozilla.org/ko/docs/Web/CSS/:not) [`:where`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where) [`attribute selector`](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) 3가지 문법을 조합하면 쉽게 적용할 수 있다.

```css
:not(:where([class~="className"] *))
```

부모 중 클래스 속성이 `className`이 아닌 경우에만 css 적용한다.

---

## 예시

```css {5}
.txt {
  color: red;
}

.dark .txt:not(:where([class~='no-dark'] *)) {
  color: blue;
}
```

```html
<body class="dark">
  <div>
    <span class="txt">dynamic text</span>
  </div>
  <div class="no-dark">
    <span class="txt">red text</span>
  </div>
</body>
```

---

**tailwindcss** [`.not-prose`](https://tailwindcss.com/docs/typography-plugin#undoing-typography-styles)에서 사용하는 방법이다.
https://github.com/tailwindlabs/tailwindcss-typography/pull/205/files
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <category label="darkmode"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(css) 노치 영역 대응]]></title>
        <id>/snippets/css/notch</id>
        <link href="https://bepyan.github.io/snippets/css/notch"/>
        <updated>2023-03-09T21:12:38.000Z</updated>
        <content type="html"><![CDATA[
아이폰 X부터 `노치(notch)`라는 영역이 생겼다.
그리고 **가로모드**가 우릴 미치게 만든다.

![230309-213220](/images/posts/notch/230309-213220.png)

https://webkit.org/blog/7929/designing-websites-for-iphone-x/

하지만 두려워 마라! 이를 쉽게 대응할 수 있다.

---

## 1. viewport-fit=cover

```html
<meta name="viewport" content="... viewport-fit=cover" />
```

take care of any padding necessary to prevent text from going right up to the edge of the display, or be obscured by the notch.

---

## 2. env()

css의 [`env()`](https://developer.mozilla.org/en-US/docs/Web/CSS/env) 문법을 통해서 `Safe Areas` 영역을 보장 받을 수 있다.
브라우저의 `userAgent`으로부터 기기 환경 변수를 얻는다고 한다.

![230309-225807](/images/posts/notch/230309-225807.png)

```css
.post {
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}
```

노치가 없을 때, 엘리먼트 `padding`이 `0`으로 덮여지지 않도록 유의해야 한다.

```css
.post {
  padding-left: env(safe-area-inset-left, 12px);
  padding-left: max(12px, env(safe-area-inset-left));
}
```

가로모드일 때만 따로 관리하는 방법도 있다.
`clac()`도 활용하여 상황에 맞게 레이아웃을 잘 지켜내자.

```css
@media only screen and (orientation: landscape) {
  .post {
    padding-left: calc(12px + env(safe-area-inset-left));
    padding-right: calc(12px + env(safe-area-inset-right));
  }
}
```

---

![230309-213927](/images/posts/notch/230309-213927.png)

편안 ✨
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <category label="notch"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) Notion Style Scrollbar]]></title>
        <id>/snippets/css/notion-scrollbar</id>
        <link href="https://bepyan.github.io/snippets/css/notion-scrollbar"/>
        <updated>2023-01-27T02:29:04.000Z</updated>
        <content type="html"><![CDATA[
Notion의 scrollbar 스타일 코드를 빼돌려보자!

---

## 라이트 모드

```css
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
::-webkit-scrollbar {
  background: transparent;
}
::-webkit-scrollbar-track {
  background: #edece9;
}
::-webkit-scrollbar-thumb {
  background: #d3d1cb;
}
::-webkit-scrollbar-thumb:hover {
  background: #aeaca6;
}
```

---

## 다크모드

```css
.dark ::-webkit-scrollbar-track {
  background: rgba(202, 204, 206, 0.04);
}
.dark ::-webkit-scrollbar-thumb {
  background: #474c50;
}
.dark ::-webkit-scrollbar-thumb:hover {
  background: rgba(202, 204, 206, 0.3);
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) scroll bar 제거]]></title>
        <id>/snippets/css/remove-scrollbar</id>
        <link href="https://bepyan.github.io/snippets/css/remove-scrollbar"/>
        <updated>2022-12-17T21:46:47.000Z</updated>
        <content type="html"><![CDATA[
스크롤은 동작하지만 스크롤바를 숨기고 싶을 때가 있다.

```css
* {
  -ms-overflow-style: none; /* IE, Edge */
  scrollbar-width: none; /* Firefox */
}
::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera*/
}
```

특정 엘리먼트의 스크롤바를 숨기고 싶다면 `body` 대신 클래스명을 입력하면 된다.

```css
.no-scrollbar {
  -ms-overflow-style: none; /* IE, Edge */
  scrollbar-width: none; /* Firefox */
}
.no-scrollbar::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera*/
}
```

추가로 tailwind의 클래스로 적용하고 싶다면?

```js:tailwind.config.js
plugins: [
  ({ addUtilities }) => {
    addUtilities({
      '.no-scrollbar': {
        /* IE, Edge */
        '-ms-overflow-style': 'none',
        /* Firefox */
        'scrollbar-width': 'none',
        /* Chrome, Safari, Opera*/
        '&::-webkit-scrollbar': {
          display: 'none',
        },
      },
    }, ['responsive'])
  },
],
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CSS) safari에서 drop-shadow가 짤리는 현상]]></title>
        <id>/snippets/css/safari-drop-shadow</id>
        <link href="https://bepyan.github.io/snippets/css/safari-drop-shadow"/>
        <updated>2022-10-10T16:20:26.000Z</updated>
        <content type="html"><![CDATA[
## 현상

style로 `drop-shadow`를 주입해줬지만 safari에서는 shadow가 짤린다.

```css
filter = 'drop-shadow(16px 16px 16px gray)';
```

## 해결 방법

브라우저가 fileter가 변경될 수 있음을 css로 알려주면 해결 가능하다.

```css
will-change: filter;
```

---

**참고 자료**

- https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <category label="troubleshooting"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(css) text ellipsis]]></title>
        <id>/snippets/css/text-ellipsis</id>
        <link href="https://bepyan.github.io/snippets/css/text-ellipsis"/>
        <updated>2023-03-09T19:44:19.000Z</updated>
        <content type="html"><![CDATA[
## 텍스트 말줄임 처리

```css
.ellipsis {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-break: break-all;
}
```

`word-break: break-all;` 문자 단위로 끊어서 줄바꿈
`word-break: keep-all;` 문단 단위로 끊어서 줄바꿈

### 여러 줄 허용하고 말줄임 처리

[`line-clamp`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-line-clamp)을 활용하면 된다.
[`webkit` 기반 브라우저](https://caniuse.com/mdn-css_properties_-webkit-line-clamp)에서 동작한다. ~~아쉽지만 IE는 지원하지 안한다.~~

```css
.ellipsis-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
```

---

## `tailwind`에서의 적용 법

자주 활용되는 기능인 만큼 [`truncate`](https://tailwindcss.com/docs/text-overflow)라는 클래스를 제공해준다.

```html
// overflow-hidden text-ellipsis whitespace-nowrap
<div className="truncate break-words" />
```

여러 줄을 줄일은 [`@tailwindcss/line-clamp`](https://github.com/tailwindlabs/tailwindcss-line-clamp)을 활용해야 한다.

```shell
yarn add -D @tailwindcss/line-clamp
```

```js:tailwind.config.js
module.exports = {
  theme: {
    // ...
  },
  plugins: [
    require('@tailwindcss/line-clamp'),
    // ...
  ],
}
```

```html
<p class="line-clamp-2">
  Et molestiae hic earum repellat aliquid est doloribus delectus. Enim illum odio porro ut omnis
  dolor debitis natus. Voluptas possimus deserunt sit delectus est saepe nihil. Qui voluptate
  possimus et quia. Eligendi voluptas voluptas dolor cum. Rerum est quos quos id ut molestiae fugit.
</p>
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="css"/>
        <category label="tailwindcss"/>
        <category label="ellipsis"/>
        <category label="line clamp"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAC에서 내 IP 확인하기]]></title>
        <id>/snippets/infra/my-ip</id>
        <link href="https://bepyan.github.io/snippets/infra/my-ip"/>
        <updated>2023-03-15T17:20:20.000Z</updated>
        <content type="html"><![CDATA[
## 방법 1

리눅스 네트워크 관리에 필요한 `ifconfig`를 활용해서 알아낼 수 있습니다.

```shell
ifconfig | grep netmask
```

![230315-172311](/images/posts/my-ip/230315-172311.png)

`inet` 이란?
네트워크 인터페이스에 할당된 IP 주소를 추출한다.

`vpn`이 적용 현황까지 알 수 있다.

---

## 방법 2

[DAUM에서 내 IP 주소 확인](https://search.daum.net/search?w=tot&m=&q=%EB%82%B4%20ip%EC%A3%BC%EC%86%8C%20%ED%99%95%EC%9D%B8&nzq=%EB%82%B4%20ip&DA=NSJ)

![230315-172424](/images/posts/my-ip/230315-172424.png)

---

## 번외

### 내 WIFI IP를 알고 싶다면?

Wi-Fi 설정 > 연결된 Wi-Fi > 세부사항

![230315-172803](/images/posts/my-ip/230315-172803.png)

![230315-172711](/images/posts/my-ip/230315-172711.png)
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="infra"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) 클립보드 복사하기]]></title>
        <id>/snippets/javascript/clipboard</id>
        <link href="https://bepyan.github.io/snippets/javascript/clipboard"/>
        <updated>2022-09-19T20:15:23.000Z</updated>
        <content type="html"><![CDATA[
```tsx
export const copyClipboard = async (url = window.document.location.href) => {
  try {
    await navigator.clipboard.writeText(url);
    alert('링크가 복사되었습니다.');
  } catch (e) {
    console.error(e);
    alert('클립보드 복사에 실패했습니다.');
  }
};
```

https://web.dev/i18n/ko/async-clipboard/

---

레거시 방법

```tsx
export const copyURL = () => {
  let currentUrl = window.document.location.href;
  let t = document.createElement('textarea');
  document.body.appendChild(t);
  t.value = currentUrl;
  t.select();
  document.execCommand('copy');
  document.body.removeChild(t);

  alert('링크가 복사되었습니다.');
};
```

https://sezzled.tistory.com/138
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <category label="clipboard"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) console.log 추가 기능]]></title>
        <id>/snippets/javascript/console</id>
        <link href="https://bepyan.github.io/snippets/javascript/console"/>
        <updated>2022-09-23T20:09:57.000Z</updated>
        <content type="html"><![CDATA[
### CSS style

```jsx
console.log('%cfatfish', 'color: red;');
```

```jsx
const getLogStyle = (code) => {
  const style = 'padding: 4px 8px;';

  if (code >= 200 && code < 300) {
    return `${style} background: #C2E0C6; color: #000000;`;
  }

  if (code >= 400 && code < 600) {
    return `${style} background: #FEF0F0; color: #FF0000;`;
  }

  return `${style} background: #FEF2C0; color: #000000;`;
};

console.log(`%c${message}`, getLogStyle(code));
```

### `console.time() & console.timeEnd()`

```jsx
let count = 0;

console.time();
for (let i = 0; i < 1000000000; i++) {
  count++;
}
console.timeEnd();
```

### `console.table()`

array 로그를 찍어 볼 때 유용한 것 같다!

### `groupCollapsed`

```jsx
console.groupCollapsed(`%c${groupTitle}`, getLogStyle(data.code));
console.log('>>> response', response);
params && console.log('>>> params', params);

if (data.code !== 200) {
  console.log('>>> data', data);
} else {
  console.log('>>> data', data.data);
}

console.groupEnd();
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) FormData로 submit 다루기]]></title>
        <id>/snippets/javascript/form-data</id>
        <link href="https://bepyan.github.io/snippets/javascript/form-data"/>
        <updated>2022-12-06T20:00:26.000Z</updated>
        <summary type="html"><![CDATA[form event를 쉽게 다룰 수 있습니다.]]></summary>
        <content type="html"><![CDATA[
기본적인 활용법

```js
const submitHandle = (e) => {
  e.preventDefault();
  const formData = new FormData(e.target);
  const formDataObj = Object.fromEntries(myFormData.entries());

  console.log(formDataObj);
};
```

`checkbox` 같이 여러 값이 있는 경우가 있습니다.
그럴 경우 [`FormData.getAll()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/getAll)를 활용하여 값을 덮어씌워줘야 합니다.

```js
const submitHandle = (e) => {
  e.preventDefault();
  const formData = new FormData(e.target);
  const formDataObj = Object.fromEntries(myFormData.entries());
  formDataObj.checkboxList = formData.getAll('checkboxList');

  console.log(formDataObj);
};
```

---

폐기된 함수들...

```js
const submitHandle = (e) => {
  e.preventDefault();
  const formData = new FormData(e.target);
  const formDataObj = Array.from(formData.keys()).reduce((ac, key) => {
    const dataList = formData.getAll(key);
    ac[key] = dataList.length > 1 ? dataList : dataList[0];
    return { ...ac };
  }, {});

  console.log(formDataObj);
};
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) input 클릭시 focus 안되도록]]></title>
        <id>/snippets/javascript/prevent-input-focus-on-click</id>
        <link href="https://bepyan.github.io/snippets/javascript/prevent-input-focus-on-click"/>
        <updated>2023-01-16T13:27:17.000Z</updated>
        <content type="html"><![CDATA[
input element를 클릭시 input에 focus가 안되고 동작을 커스터마이징하고 싶을 때가 있다.

`event.preventDefault()`로 input 클릭시 디폴트로 이어지는 동작을 제어할 수 있다.
주의할 것은 `click`이 아닌 `mousedown` 이벤트에 걸어야 한다.

> The focus will be set on a HTML element when the mouse down is successful.

```js
$('#div').on('mousedown', function (e) {
  e.preventDefault();
});
```

---

**참고 자료**

- https://stackoverflow.com/questions/8735764/prevent-firing-focus-event-when-clicking-on-div
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <category label="DOM"/>
        <category label="preventDefault"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) .txt File 만들기]]></title>
        <id>/snippets/javascript/txt-file</id>
        <link href="https://bepyan.github.io/snippets/javascript/txt-file"/>
        <updated>2022-09-03T19:14:23.000Z</updated>
        <content type="html"><![CDATA[
blob을 활용

```tsx
const blob = new Blob([JSON.stringify(data)], { type: 'text/plain' });
const textFile = window.URL.createObjectURL(blob);

window.open(textFile, '_blank');
```

File

```tsx
const fileName = `${moment(new Date()).format('YYYY-MM-DD HH:mm:ss')}.txt`;
const file = new File([JSON.stringify(data)], fileName, {
  type: 'text/plain;charset=UTF-8',
});
```

하지만 한글이 깨지는 문제가 있다.

https://www.thecodehubs.com/generate-text-file-using-plain-javascript/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(JS) regex로 버전 추출하기]]></title>
        <id>/snippets/javascript/version-regex</id>
        <link href="https://bepyan.github.io/snippets/javascript/version-regex"/>
        <updated>2022-06-30T20:12:44.000Z</updated>
        <content type="html"><![CDATA[
```jsx
const REGEX = /\d+(\.\d+)+/gi;
console.log(''.match(REGEX));
```

https://stackoverflow.com/questions/8955657/regex-pattern-to-extract-version-number-from-string)

네이버 userAgent에서 네이버 버전 추출하기

```jsx
const NAVER_USERAGENT_REGEX = /\d+(\.\d+)+/gi;
const agent =
  'Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/605.1 NAVER(inapp; search; 1010; 11.12.7; 12MINI)';
const version = agent.match(NAVER_USERAGENT_REGEX);

console.log(version);
```

정규식 문법
[https://heropy.blog/2018/10/28/regexp/](https://heropy.blog/2018/10/28/regexp/)

`^naver` 문자열이 naver로 시작해야 한다.

`$naver` 문자열이 naver로 끝나야 한다.

`\d{5}` 숫자 5개가 있어야 한다. ⇒ `\d\d\d\d\d`

`\d{3,5}` 숫자가 3~5개 있어야 한다.

`\d+` 1개 이상이 있어야 한다. ⇒ `\d{1,}`

`\d*` 0개 이상 있어야 한다. ⇒ `\d{0, }`

`\d?` 0, 1개 있어야 한다. ⇒ `\d{0,1}`

`\d$` 줄 끝에서 일치 한다.

`.` 임의의 한 문자와 일치

`[ab]` a 혹은 b와 일치여부 ⇒ `a | b`

테스트 공간
[https://regexr.com/](https://regexr.com/)

**`match()`**
메서드는 문자열이 정규식과 매치되는 부분을 검색합니다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="javascript"/>
        <category label="regex"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(ESLint) sort import]]></title>
        <id>/snippets/lint/eslint-sort-import</id>
        <link href="https://bepyan.github.io/snippets/lint/eslint-sort-import"/>
        <updated>2023-01-11T18:57:07.000Z</updated>
        <content type="html"><![CDATA[
[**eslint sort-imports**](https://eslint.org/docs/latest/rules/sort-imports) 설정은 `autofix`를 제공해주지 않는다.

크게 2가지 방법으로 해결할 수 있다.

---

## simple-import-sort

plugin을 통해서 설정이 간편하다.
https://github.com/lydell/eslint-plugin-simple-import-sort

```shell
yarn add -D eslint-plugin-simple-import-sort
```

```js:.eslintrc.js
module.exports = {
    //...
    "plugins": ["simple-import-sort"],
    "rules": {
        "simple-import-sort/imports": "error",
        "simple-import-sort/exports": "error"
    }
}
```

`import` 순서 커스텀화

```js
{
    'simple-import-sort/imports': [
        'error',
        {
        groups: [['^\\u0000'], ['^@?\\w'], ['^~/', '^\\.']],
        },
    ],
}
```

---

## eslint-plugin-import

타 plugin과 충돌될 경우 이를 사용하면 좋다. (예를 들어 [eslint-plugin-svelte](https://github.com/ota-meshi/eslint-plugin-svelte))
https://github.com/import-js/eslint-plugin-import

```shell
yarn add -D eslint-plugin-import
```

```js:.eslintrc.js
module.exports = {
    //...
    settings: {
        'import/resolver': {
            alias: {
                map: [
                    ['~', './src'],
                ],
                extensions: ['.js', '.jsx', '.ts', '.tsx', '.svelte'],
            },
        },
    },
    rules: {
        // https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md
        'import/order': [
            'error',
            {
                groups: ['builtin', 'external', 'internal', ['parent', 'sibling', 'index']],
                alphabetize: {
                    order: 'asc',
                    caseInsensitive: true,
                },
                'newlines-between': 'always',
            },
        ],
        'import/first': 'error',
        'import/newline-after-import': 'error',
        'import/prefer-default-export': 'off',
        'import/no-useless-path-segments': ['error', { noUselessIndex: true }],
    }
}
```

`import/order`가 절대경로를 `internal script`로 인식하기 위해선 `settings."import/resolver"` 설정을 해줘야 한다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="eslint"/>
        <category label="import"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[dayjs]]></title>
        <id>/snippets/next.js/dayjs</id>
        <link href="https://bepyan.github.io/snippets/next.js/dayjs"/>
        <updated>2023-02-03T12:25:11.000Z</updated>
        <content type="html"><![CDATA[
https://github.com/iamkun/dayjs/

`moment`보다 **가볍고** 쉽게 날짜를 다룰 수 있습니다.
MINIFIED + GZIPPED 기준으로 [2.9KB(dayjs)](https://bundlephobia.com/package/dayjs@1.11.7) vs [72KB(moment)](https://bundlephobia.com/package/moment@2.29.4) 이면 차이가 어마무시합니다.

- `chaining` 방식으로 날짜 다루기 편함
- 쉬운 커스터마이징, 확장
- 한글 및 KST 지원
- `immutable` 모든 것이 순수함수
- `typescript` 완벽 호환

단순하게 날짜를 다루거나 표기할 경우는 [`date-fns`](https://github.com/date-fns/date-fns)를 고려해보세요!

---

## 기본 사용법

```shell
yarn add dayjs
```

`typescript`을 위해서 별도의 설정이 필요 없습니다!

```js
import dayjs from 'dayjs';

dayjs().format('yyyy-dd-mm'); // 2023-02-03
dayjs().add(1, 'day').format('yyyy-dd-mm'); // 2023-02-04
```

기존 `Date` 클래스를 `dayjs.Dayjs` 클래스로 래핑하여서 사용하게 됩니다.
따라서 `dayjs.Dayjs` 클래스에서 제공하는 다양한 기능을 체이닝해서 사용할 수 있고 모든 과정이 순수합니다!

---

### 한글 세팅

`2023년 1월 1일 일요일`, `1년 전` 같이 한글 날짜에 대한 포멧팅도 쉽게 지원이 됩니다.
`Next.js`에서 아래와 같이 쉽게 세팅할 수 있습니다.

```tsx:_app.tsx
import 'dayjs/locale/ko';
import dayjs from 'dayjs';

dayjs.locale('ko');

export default function App({...}) {
  // ...
}
```

혹은 `re-export`해서 사용해도 좋습니다.

```ts:libs/dayjs.ts
import 'dayjs/locale/ko'

import dayjs from 'dayjs'
import duration from 'dayjs/plugin/duration'
import localeData from 'dayjs/plugin/localeData'

dayjs.locale('ko')
dayjs.extend(localeData)
dayjs.extend(duration)

export default dayjs
```

---

## 여러 활용 꿀팁

제가 실제로 사용하게된 것들을 계속 기록해보겠습니다 🙂

```ts
dayjs().localeData().monthsShort(dayjs()); // 2월
dayjs().localeData().monthsShort(dayjs().month(2)); // 3월
```

```ts
dayjs.localeData().weekdaysShort(); // ['월', '화', '수', '목', '금', '토', '일']
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="date"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(Next.js) document fonts]]></title>
        <id>/snippets/next.js/document-fonts</id>
        <link href="https://bepyan.github.io/snippets/next.js/document-fonts"/>
        <updated>2022-12-19T22:06:32.000Z</updated>
        <content type="html"><![CDATA[
`Next.js` `_document.tsx`에서 `link`를 통해서 폰트를 적용하는 방법이다.

적절한 폰트를 찾는다.
**https://fonts.google.com/**

<br />

```tsx:_document.tsx
<Head>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
  <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap"
      rel="stylesheet"
  />
</Head>
```

```css:globals.css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

* {
  font-family: 'Inter', sans-serif;
}
```

---

`tailwindcss`

```js:tailwind.config.js
const { fontFamily } = require('tailwindcss/defaultTheme');

/** @type {import('tailwindcss').Config} */
module.exports = {
  //...
  theme: {
    extend: {
      fontFamily: {
        sans: ['inter', ...fontFamily.sans],
      },
      //...
    }
};
```

```tsx:_app.tsx
<div className="font-sans">
  <Component {...pageProps} />
</div>
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="css"/>
        <category label="tailwindcss"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(Next.js) @next/fonts]]></title>
        <id>/snippets/next.js/next-fonts</id>
        <link href="https://bepyan.github.io/snippets/next.js/next-fonts"/>
        <updated>2023-03-07T21:29:20.000Z</updated>
        <content type="html"><![CDATA[
`@next/font`를 지원하는 폰트, 로컬에 있는 폰트를 적용해보자.

---

[`variable fonts`](https://fonts.google.com/variablefonts)를 사용하는 것이 성능상 베스트이지만, 아직 한글 폰트가 없다는 사실...
https://noonnu.cc/ 에서 마음에 드는 폰트를 다운 받아서 사용해보자.

```shell
yarn add @next/font
```

```tsx:components/Fonts.tsx
import { JetBrains_Mono as FontMono } from '@next/font/google';
import localFont from '@next/font/local';

const fontSans = localFont({
  variable: '--font-sans',
  src: [
    {
      path: '../assets/fonts/NotoSansKR-Regular.otf',
      weight: '400',
      style: 'normal',
    },
    {
      path: '../assets/fonts/NotoSansKR-Medium.otf',
      weight: '500',
      style: 'normal',
    },
    {
      path: '../assets/fonts/NotoSansKR-Bold.otf',
      weight: '700',
      style: 'normal',
    },
  ],
});

export const fontMono = FontMono({
  subsets: ['latin'],
  variable: '--font-mono',
  display: 'swap',
});


export default function Fonts() {
  return (
    <style jsx global>{`
      :root {
        --font-sans: ${fontSans.style.fontFamily};
        --font-mono: ${fontMono.style.fontFamily};
      }
    `}</style>
  );
}
```

```ts:tailwind.config.js
const { fontFamily } = require('tailwindcss/defaultTheme');

/** @type {import('tailwindcss').Config} */
module.exports = {
  // ...,
  theme: {
    extend: {
      fontFamily: {
        sans: ['var(--font-sans)', ...fontFamily.sans],
        mono: ['var(--font-mono)', ...fontFamily.mono],
      },
    }
  }
}
```

```tsx:_app.tsx
export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Fonts />
      <div className='font-sans'>
        <Component {...pageProps} />
        <code className="font-mono">
          {...}
        </code>
      </div>
    </>
  )
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="css"/>
        <category label="tailwindcss"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(Next.js) nprogress]]></title>
        <id>/snippets/next.js/nprogress</id>
        <link href="https://bepyan.github.io/snippets/next.js/nprogress"/>
        <updated>2022-12-06T21:28:25.000Z</updated>
        <content type="html"><![CDATA[
✨[**nprogress**](https://github.com/rstacruz/nprogress)를 활용하여 route가 변경될시 로딩 UI를 표시할 수 있습니다.

```bash
yarn add nprogress
yarn add -D @types/nprogress
```

<br />

```tsx:_app.tsx
useEffect(() => {
  const handleStart = (url: string) => {
    NProgress.start();
  };

  const handleStop = () => {
    NProgress.done();
  };

  router.events.on('routeChangeStart', handleStart);
  router.events.on('routeChangeComplete', handleStop);
  router.events.on('routeChangeError', handleStop);

  return () => {
    router.events.off('routeChangeStart', handleStart);
    router.events.off('routeChangeComplete', handleStop);
    router.events.off('routeChangeError', handleStop);
  };
}, [router]);
```

- Next13 기준으로 동작한 코드입니다.
- https://nextjs.org/docs/api-reference/next/router#routerevents
  <br />

```tsx:_document.tsx
<Head>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css"
    />
</Head>
```

<br />

```css:global.css
/* nprogress */
:root {
  --nprogress-color: rgb(168 85 247);
}

#nprogress .bar {
  background: var(--nprogress-color) !important;
  padding: 0 10px !important;
  height: 3px !important;
}

#nprogress .spinner .spinner-icon {
  border-top-color: var(--nprogress-color) !important;
  border-left-color: var(--nprogress-color) !important;
}
```

---

레거시 코드 참고

- https://dev.to/debosthefirst/how-to-show-a-loading-bar-when-changing-routes-in-nextjs-304e
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(Next.js) sitemap.xml]]></title>
        <id>/snippets/next.js/sitemap</id>
        <link href="https://bepyan.github.io/snippets/next.js/sitemap"/>
        <updated>2022-12-27T21:15:46.000Z</updated>
        <summary type="html"><![CDATA[직접 sitemap을 만들어서 배포시키자.]]></summary>
        <content type="html"><![CDATA[
sitemap의 원리는 간단하기에 충분히 직접 만들 수 있다.
검색 엔진에 노출시킬 페이지만 잘 명시해주면 된다.

---

## sitemap.xml 생성하는 script 구현

핵심은 `fs.promises.writeFile`를 통해서 파일을 생성해주는 것이다.
`getStaticPaths`에서 경로를 만드는데 활용한 함수를 활용하면 간단하게 설정을 마칠 수 있다.

```ts:sitemap.config.ts
import fs from 'fs';
import { getAllPosts } from './src/libs/post';

async function createSiteMap() {
  const siteUrl = 'https://bepyan.github.io';
  const posts = getAllPosts();

  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:news="http://www.google.com/schemas/sitemap-news/0.9" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:mobile="http://www.google.com/schemas/sitemap-mobile/1.0" xmlns:image="http://www.google.com/schemas/sitemap-image/1.1" xmlns:video="http://www.google.com/schemas/sitemap-video/1.1">
<url><loc>${siteUrl}</loc><changefreq>daily</changefreq><priority>0.7</priority></url>
${posts
  .map(
    (post) =>
      `<url><loc>${siteUrl}${post.slug}</loc><changefreq>daily</changefreq><priority>0.7</priority></url>`,
  )
  .join('\n')}
</urlset>`;

  await fs.promises.writeFile('public/sitemap.xml', sitemap, {
    encoding: 'utf-8',
  });
}

void createSiteMap();
```

---

## script 실행하기

`ts-node`로 `typescript`을 실행시켜야하기에 관련 패키지를 설치하자.

```shell
yarn add -D ts-node
```

`Node`로 js를 실행해야하기에 `typescript`를 `commonjs`로 컴파일한다.

```json:tsconfig.node.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
  }
}
```

`build` 이전에 사이트맵을 생성해주면 된다. 그럼 `public`에 있는 사이트맵이 자연스럽게 빌드 결과물에 포함하게 된다.

```diff-json:package.json
{
- "build": "next build",
+ "build": "yarn sitemap && next build",
+ "sitemap": "ts-node --project tsconfig.node.json ./sitemap.config.ts",
}
```

마지막으로 컴파일된 사이트맵을 `commit`되지 않도록 해주자.

```:.gitignore
/public/sitemap*.xml
```

---

## 결과물 확인하기

```shell
yarn build
yarn start
```

http://localhost:3000/sitemap.xml

[Google Search Console](https://search.google.com/search-console/sitemaps)에 사이트맵을 제출했을 때 `가져올 수 없음` 상태가 뜨게 되는데 몇일 후 확인하면 된다.
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="sitemap"/>
        <category label="fs"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) Icons]]></title>
        <id>/snippets/react/Icons</id>
        <link href="https://bepyan.github.io/snippets/react/Icons"/>
        <updated>2023-01-30T20:17:03.000Z</updated>
        <content type="html"><![CDATA[
아이콘마다 `import`해오는 건 코드가 더러워지게 된다.
모든 `svg` 아이콘을 `Icons`에 모아서 쓰자!

```tsx
import { Icons } from '~/components/Icons';

<Icons.logo className="mr-2 h-4 w-4" />;
```

[`Lucide`](https://lucide.dev/)을 활용한 예이다.

```tsx:Icons.tsx
import {
  AlertTriangle,
  ArrowRight,
  Check,
  ChevronLeft,
  ChevronRight,
  Circle,
  ClipboardCheck,
  Copy,
  CreditCard,
  File,
  FileText,
  HelpCircle,
  Image,
  Laptop,
  Loader2,
  LucideProps,
  Moon,
  MoreVertical,
  Pizza,
  Plus,
  Settings,
  SunMedium,
  Trash,
  Twitter,
  User,
  X,
  type Icon as LucideIcon,
} from "lucide-react"

export type Icon = LucideIcon

export const Icons = {
  logo: (props: LucideProps) => (
    <svg
      viewBox="0 0 24 24"
      fill="currentColor"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <circle cx="12" cy="12" r="10"></circle>
    </svg>
  ),
  close: X,
  spinner: Loader2,
  chevronLeft: ChevronLeft,
  chevronRight: ChevronRight,
  trash: Trash,
  post: FileText,
  page: File,
  media: Image,
  settings: Settings,
  billing: CreditCard,
  ellipsis: MoreVertical,
  add: Plus,
  warning: AlertTriangle,
  user: User,
  arrowRight: ArrowRight,
  help: HelpCircle,
  pizza: Pizza,
  twitter: Twitter,
  check: Check,
  copy: Copy,
  copyDone: ClipboardCheck,
  sun: SunMedium,
  moon: Moon,
  laptop: Laptop,
  gitHub: (props: LucideProps) => (
    <svg viewBox="0 0 438.549 438.549" {...props}>
      <path
        fill="currentColor"
        d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289 1.525-.859 4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136 6.28 0 11.704-.476 16.274-1.423 4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z"
      ></path>
    </svg>
  ),
  radix: (props: LucideProps) => (
    <svg viewBox="0 0 25 25" fill="none" {...props}>
      <path
        d="M12 25C7.58173 25 4 21.4183 4 17C4 12.5817 7.58173 9 12 9V25Z"
        fill="currentcolor"
      ></path>
      <path d="M12 0H4V8H12V0Z" fill="currentcolor"></path>
      <path
        d="M17 8C19.2091 8 21 6.20914 21 4C21 1.79086 19.2091 0 17 0C14.7909 0 13 1.79086 13 4C13 6.20914 14.7909 8 17 8Z"
        fill="currentcolor"
      ></path>
    </svg>
  ),
  npm: (props: LucideProps) => (
    <svg viewBox="0 0 24 24" {...props}>
      <path d="M1.763 0C.786 0 0 .786 0 1.763v20.474C0 23.214.786 24 1.763 24h20.474c.977 0 1.763-.786 1.763-1.763V1.763C24 .786 23.214 0 22.237 0zM5.13 5.323l13.837.019-.009 13.836h-3.464l.01-10.382h-3.456L12.04 19.17H5.113z" />
    </svg>
  ),
  yarn: (props: LucideProps) => (
    <svg viewBox="0 0 24 24" {...props}>
      <path d="M12 0C5.375 0 0 5.375 0 12s5.375 12 12 12 12-5.375 12-12S18.625 0 12 0zm.768 4.105c.183 0 .363.053.525.157.125.083.287.185.755 1.154.31-.088.468-.042.551-.019.204.056.366.19.463.375.477.917.542 2.553.334 3.605-.241 1.232-.755 2.029-1.131 2.576.324.329.778.899 1.117 1.825.278.774.31 1.478.273 2.015a5.51 5.51 0 0 0 .602-.329c.593-.366 1.487-.917 2.553-.931.714-.009 1.269.445 1.353 1.103a1.23 1.23 0 0 1-.945 1.362c-.649.158-.95.278-1.821.843-1.232.797-2.539 1.242-3.012 1.39a1.686 1.686 0 0 1-.704.343c-.737.181-3.266.315-3.466.315h-.046c-.783 0-1.214-.241-1.45-.491-.658.329-1.51.19-2.122-.134a1.078 1.078 0 0 1-.58-1.153 1.243 1.243 0 0 1-.153-.195c-.162-.25-.528-.936-.454-1.946.056-.723.556-1.367.88-1.71a5.522 5.522 0 0 1 .408-2.256c.306-.727.885-1.348 1.32-1.737-.32-.537-.644-1.367-.329-2.21.227-.602.412-.936.82-1.08h-.005c.199-.074.389-.153.486-.259a3.418 3.418 0 0 1 2.298-1.103c.037-.093.079-.185.125-.283.31-.658.639-1.029 1.024-1.168a.94.94 0 0 1 .328-.06zm.006.7c-.507.016-1.001 1.519-1.001 1.519s-1.27-.204-2.266.871c-.199.218-.468.334-.746.44-.079.028-.176.023-.417.672-.371.991.625 2.094.625 2.094s-1.186.839-1.626 1.881c-.486 1.144-.338 2.261-.338 2.261s-.843.732-.899 1.487c-.051.663.139 1.2.343 1.515.227.343.51.176.51.176s-.561.653-.037.931c.477.25 1.283.394 1.71-.037.31-.31.371-1.001.486-1.283.028-.065.12.111.209.199.097.093.264.195.264.195s-.755.324-.445 1.066c.102.246.468.403 1.066.398.222-.005 2.664-.139 3.313-.296.375-.088.505-.283.505-.283s1.566-.431 2.998-1.357c.917-.598 1.293-.76 2.034-.936.612-.148.57-1.098-.241-1.084-.839.009-1.575.44-2.196.825-1.163.718-1.742.672-1.742.672l-.018-.032c-.079-.13.371-1.293-.134-2.678-.547-1.515-1.413-1.881-1.344-1.997.297-.5 1.038-1.297 1.334-2.78.176-.899.13-2.377-.269-3.151-.074-.144-.732.241-.732.241s-.616-1.371-.788-1.483a.271.271 0 0 0-.157-.046z" />
    </svg>
  ),
  pnpm: (props: LucideProps) => (
    <svg viewBox="0 0 24 24" {...props}>
      <path d="M0 0v7.5h7.5V0zm8.25 0v7.5h7.498V0zm8.25 0v7.5H24V0zM8.25 8.25v7.5h7.498v-7.5zm8.25 0v7.5H24v-7.5zM0 16.5V24h7.5v-7.5zm8.25 0V24h7.498v-7.5zm8.25 0V24H24v-7.5z" />
    </svg>
  ),
  react: (props: LucideProps) => (
    <svg viewBox="0 0 24 24" {...props}>
      <path d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z" />
    </svg>
  ),
  tailwind: (props: LucideProps) => (
    <svg viewBox="0 0 24 24" {...props}>
      <path d="M12.001,4.8c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 C13.666,10.618,15.027,12,18.001,12c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C16.337,6.182,14.976,4.8,12.001,4.8z M6.001,12c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 c1.177,1.194,2.538,2.576,5.512,2.576c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C10.337,13.382,8.976,12,6.001,12z" />
    </svg>
  ),
}
```

처음엔 번거롭지만 나중에 아이콘을 쓸 때는 무척 쾌적하다.

---

**참고 자료**

- https://github.com/shadcn/ui
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <category label="typescript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) useConfettiful]]></title>
        <id>/snippets/react/confettiful</id>
        <link href="https://bepyan.github.io/snippets/react/confettiful"/>
        <updated>2022-12-29T00:39:41.000Z</updated>
        <content type="html"><![CDATA[
`hook` 하나로 모든 것을 해결했다!

```ts:useConfettiful.ts
import { useEffect, useState } from 'react';

/**
 * 초당 생성할 confetti 개수
 */
const confettiFrequency = 10;
/**
 * confetti 색상
 * https://colorhunt.co/palettes
 */
const confettiColors = ['#FAF8F1', '#FAEAB1', '#E5BA73', '#C58940', '#FAF8F1'];
/**
 * 바닥까지 떨어지는 속도
 */
const confettiAnimations = ['slow', 'medium', 'fast'];
const confettiAnimationSpeeds = [4, 3, 2];

const confettiCss = `
@keyframes confetti-slow {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(25px, 105vh, 0) rotateX(360deg) rotateY(180deg);
  }
}

@keyframes confetti-medium {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(100px, 105vh, 0) rotateX(100deg) rotateY(360deg);
  }
}

@keyframes confetti-fast {
  0% {
    transform: translate3d(0, 0, 0) rotateX(0) rotateY(0);
  }

  100% {
    transform: translate3d(-50px, 105vh, 0) rotateX(10deg) rotateY(250deg);
  }
}

.confetti--animation-slow {
  animation: confetti-slow ${confettiAnimationSpeeds[0]}s linear 1 forwards;
}

.confetti--animation-medium {
  animation: confetti-medium ${confettiAnimationSpeeds[1]}s linear 1 forwards;
}

.confetti--animation-fast {
  animation: confetti-fast ${confettiAnimationSpeeds[2]}s linear 1 forwards;
}
`;

function Confettiful() {
  const getRandomItem = (list: string[]) => list[Math.floor(Math.random() * list.length)];

  const el = document.createElement('div');
  el.id = 'confetti';
  el.style.position = 'fixed';
  el.style.pointerEvents = 'none';
  el.style.width = '100%';
  el.style.height = '100%';

  const containerEl = document.createElement('div');
  containerEl.style.position = 'absolute';
  containerEl.style.overflow = 'hidden';
  containerEl.style.top = '0';
  containerEl.style.right = '0';
  containerEl.style.bottom = '0';
  containerEl.style.left = '0';
  el.appendChild(containerEl);

  const confettiInterval = setInterval(() => {
    const confettiEl = document.createElement('div');
    confettiEl.style.position = 'absolute';
    confettiEl.style.zIndex = '99999';
    confettiEl.style.top = '-10px';
    confettiEl.style.borderRadius = '0%';

    const confettiSize = `${Math.floor(Math.random() * 3) + 7}px`;
    const confettiLeft = `${Math.floor(Math.random() * el.offsetWidth)}px`;
    const confettiBackground = getRandomItem(confettiColors);
    const confettiAnimation = getRandomItem(confettiAnimations);

    confettiEl.classList.add('confetti', `confetti--animation-${confettiAnimation}`);
    confettiEl.style.left = confettiLeft;
    confettiEl.style.width = confettiSize;
    confettiEl.style.height = confettiSize;
    confettiEl.style.backgroundColor = confettiBackground;

    setTimeout(function () {
      confettiEl.parentNode?.removeChild(confettiEl);
    }, 3000);

    containerEl.appendChild(confettiEl);
  }, 1000 / confettiFrequency);

  const styleEl = document.createElement('style');
  styleEl.innerHTML = confettiCss;
  document.head.appendChild(styleEl);

  document.body.prepend(el);

  return () => {
    clearInterval(confettiInterval);
    setTimeout(function () {
      el.remove();
      styleEl.remove();
    }, 3000);
  };
}

export default function useConfettiful(initShow = false): [boolean, (show: boolean) => void] {
  let cleanConfetti: () => void | undefined;
  const [show, setShow] = useState(initShow);

  useEffect(() => {
    if (show) {
      cleanConfetti = Confettiful();
    } else {
      cleanConfetti?.();
    }

    return () => {
      cleanConfetti?.();
    };
  }, [show]);

  return [show, setShow];
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <category label="typescript"/>
        <category label="hook"/>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) Lodash Debounce]]></title>
        <id>/snippets/react/lodash-debounce</id>
        <link href="https://bepyan.github.io/snippets/react/lodash-debounce"/>
        <updated>2022-12-13T21:31:23.000Z</updated>
        <content type="html"><![CDATA[
`javascript`

```shell
yarn add lodash.debounce
```

```jsx
const App = () => {
  const [searchValue, setSearchValue] = useState('');

  const searchHandler = useCallback(
    sdebounce((e) => {
      setSearchValue(e.target.value);
    }, 300),
    [],
  );

  return (
    <div>
      <div>{searchValue}</div>
      <input type="text" onChange={searchHandler} />
    </div>
  );
};
```

---

`typescript`

```shell
yarn add -D @types/lodash.debounce
```

```ts:useSearch.ts
import debounce from 'lodash.debounce';
import React, { useCallback, useState } from 'react';

export default function useSearch(callback?: (value: string) => void, wait = 300) {
  const [searchValue, setSearchValue] = useState('');

  const searchHandler = useCallback(
    debounce((e: React.ChangeEvent<HTMLInputElement>) => {
      const value = e.target.value;
      callback?.(value);
      setSearchValue(value);
    }, wait),
    [],
  );

  return { searchValue, searchHandler };
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="debounce"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) Observer Transition]]></title>
        <id>/snippets/react/observer-transition</id>
        <link href="https://bepyan.github.io/snippets/react/observer-transition"/>
        <updated>2022-12-10T18:10:44.000Z</updated>
        <content type="html"><![CDATA[
```tsx
const useObserver = () => {
  const rootRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const $toc = document.querySelector('#table-of-contents');
    if (!$toc) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (!rootRef.current) return;

        const $root = rootRef.current;
        $root.style.display = 'block';

        const $header = $root.querySelector<HTMLElement>('#toc-header');
        const $list = Array.from($root.querySelectorAll<HTMLElement>('#toc-content > li'));
        const $footer = $root.querySelector<HTMLElement>('#toc-footer');
        const elementList = [$root, $header, $footer, ...$list].filter(Boolean) as HTMLElement[];

        if (entry.isIntersecting) {
          elementList.reverse().forEach((element, i) => {
            element.style.opacity = '0';
            element.style.pointerEvents = 'none';
            element.style.transition = '200ms ease-out';
            element.style.transitionDelay = `${i * 15}ms`;
          });
        } else {
          elementList.forEach((element, i) => {
            element.style.opacity = '1';
            element.style.pointerEvents = 'auto';
            element.style.transition = '150ms ease-out';
            element.style.transitionDelay = `${i * 10}ms`;
          });
        }
      },
      { threshold: 0.7 },
    );

    observer.observe($toc);
  }, []);

  return rootRef;
};
```

<br />

```tsx
export default function TocBanner() {
  const rootRef = useObserver();

  return (
    <div ref={rootRef}>
        {...}
    </div>
  )
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[react-hot-toast]]></title>
        <id>/snippets/react/react-hot-toast</id>
        <link href="https://bepyan.github.io/snippets/react/react-hot-toast"/>
        <updated>2023-01-27T21:43:35.000Z</updated>
        <content type="html"><![CDATA[
✨ [**react-hot-toast**](https://github.com/timolins/react-hot-toast)

🔥 Hot by default
🔩 Easily Customizable
⏳ Promise API - Automatic loader from a promise
🕊 Lightweight - less than 5kb including styles
✅ Accessible
🤯 Headless Hooks

---

## 기본 활용법

```shell
yarn add react-hot-toast
```

```tsx:_app.tsx
import { AppProps } from 'next/app';
import { Toaster } from 'react-hot-toast';

export default function App({ Component, pageProps }: AppProps) {
  return (
    <div>
      <Component {...pageProps} />
      <Toaster
        toastOptions={{
          className: 'bg-gray-50 text-gray-700 dark:bg-gray-800 dark:text-gray-300',
          position: 'bottom-right',
        }}
      />
    </div>
  );
}
```

```tsx
toast.success('successful');
toast.error('failed');
```

무척 간편하다!

---

## 커스텀 컴포넌트로 undo 기능 추가

```tsx
toast((action) => (
  <Toast
    title="Dark theme enabled"
    buttonText="Undo"
    action={() => {
      actionImpl.command?.history?.undo();
      toast.dismiss(action.id);

      toast((undoAction) => (
        <Toast
          title="Dark theme undone"
          buttonText="Redo"
          action={() => {
            actionImpl.command?.history?.redo();
            toast.dismiss(undoAction.id);
          }}
        />
      ));
    }}
  />
));
```

```tsx
function Toast({
  title,
  buttonText,
  action,
}: {
  title: string;
  buttonText: string;
  action: () => void;
}) {
  return (
    <div className="flex items-center gap-4 text-sm">
      <span>{title}</span>
      <button
        onClick={action}
        className={$(
          'cursor-pointer rounded py-1 px-2',
          'bg-gray-150 active:bg-gray-200 dark:bg-gray-700 dark:active:bg-gray-600',
        )}
      >
        {buttonText}
      </button>
    </div>
  );
}
```
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) scroll progress bar]]></title>
        <id>/snippets/react/reading-progress-bar</id>
        <link href="https://bepyan.github.io/snippets/react/reading-progress-bar"/>
        <updated>2022-12-17T19:52:10.000Z</updated>
        <content type="html"><![CDATA[
`Next.js` 기준으로 [**Styled JSX**](https://github.com/vercel/styled-jsx)를 활용하여 구현했다.

```tsx
import { useEffect, useState } from 'react';

export default function ReadingProgressBar() {
  const [width, setWidth] = useState(0);

  const scrollHeight = () => {
    const element = document.documentElement;
    const ScrollTop = element.scrollTop || document.body.scrollTop;
    const ScrollHeight = element.scrollHeight || document.body.scrollHeight;
    const percent = (ScrollTop / (ScrollHeight - element.clientHeight)) * 100;

    setWidth(percent);
  };

  useEffect(() => {
    window.addEventListener('scroll', scrollHeight);
    return () => window.removeEventListener('scroll', scrollHeight);
  }, []);

  return (
    <div className="progressBar" style={{ width: `${width}%` }}>
      <style jsx>{`
        .progressBar {
          position: fixed;
          z-index: 50;
          top: 0px;
          left: 0px;
          height: 6px;
          border-radius: 0px 2px 0px 0px;
          background: linear-gradient(90deg, #ffdd00, #fbb034);
        }
      `}</style>
    </div>
  );
}
```

---

**참고 자료**

- https://blog.logrocket.com/creating-reading-progress-bar-react/
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="next.js"/>
        <category label="react"/>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(React) useMediaQuery]]></title>
        <id>/snippets/react/use-media-query</id>
        <link href="https://bepyan.github.io/snippets/react/use-media-query"/>
        <updated>2023-01-14T01:15:43.000Z</updated>
        <content type="html"><![CDATA[
React / Next.js 런타임에서 MediaQuery를 충족시켰는지 여부를 알고 싶다.

```ts:useMediaQuery.ts
import { useCallback, useEffect, useState } from 'react';

export const useMediaQuery = (width: number) => {
  const [targetReached, setTargetReached] = useState(false);

  const updateTarget = useCallback((e: MediaQueryListEvent) => {
    if (e.matches) setTargetReached(true);
    else setTargetReached(false);
  }, []);

  useEffect(() => {
    const media = window.matchMedia(`(max-width: ${width}px)`);
    media.addEventListener('change', updateTarget);

    if (media.matches) setTargetReached(true);

    return () => media.removeEventListener('change', updateTarget);
  }, []);

  return targetReached;
};
```

---

## Usage

```ts
// 600px
const matches = useMediaQuery(600);
```

---

**참고 자료**

- https://stackoverflow.com/questions/72238021/how-to-apply-media-query-in-nextjs
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="react"/>
        <category label="typescript"/>
        <category label="hook"/>
        <category label="css"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(TS) Type에서 Promise 제거하기]]></title>
        <id>/snippets/typescript/remove-promise</id>
        <link href="https://bepyan.github.io/snippets/typescript/remove-promise"/>
        <updated>2022-12-30T23:51:35.000Z</updated>
        <content type="html"><![CDATA[
`Awaited` 문법을 통해서 Promise 타입을 벗겨낼 수 있다.

```tsx
// A = string
type A = Awaited<Promise<string>>;

// B = number
type B = Awaited<Promise<Promise<number>>>;
```

---

**참고 자료**

- https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#awaited-type
- https://stackoverflow.com/questions/48944552/typescript-how-to-unwrap-remove-promise-from-a-type
]]></content>
        <author>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </author>
        <category label="typescript"/>
        <contributor>
            <name>Edward Kim</name>
            <email>bepyan@naver.com</email>
            <uri>https://bepyan.github.io</uri>
        </contributor>
    </entry>
</feed>