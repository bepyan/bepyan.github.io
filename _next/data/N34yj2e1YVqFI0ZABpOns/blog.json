{"pageProps":{"serizes":[{"title":"Next.js로 블로그 만들기","description":"100% 취향 반영, 내 손으로 직접 블로그를 만들어 보자!!","tags":[],"draft":false,"date":"2022-11-11","posts":[{"title":"Next.js 블로그 utterances로 댓글 ","description":"","tags":[],"draft":false,"date":"2022-11-13","content":"\n### 참고\n\nhttps://github.com/utterance/utterances/issues/161#issuecomment-820722906\nhttps://github.com/utterance/utterances/issues/549#issuecomment-913070158\n","slug":"nextjs-blog/5-utterances","readingMinutes":1,"wordCount":6},{"title":"Project Boilerplate 세팅하기","description":"next-mdx-remote 에서 플로그인 쓰는 법","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n블로그의 스택은 아래와 같다.\n\n- NextJS\n- Typescript\n- TailwindCSS\n- next-mdx-remote\n","slug":"nextjs-blog/1-boilerplate","readingMinutes":1,"wordCount":14},{"title":"image optimization","description":"Next.js static html에서 이미지를 최적화해보자 🤔","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n기본적으로 next/image를 활용하면 이미지를 최적화시킬 수 있다.\n\n다만 static-html-export 환경에서는 이를 제공해주지 않는다고 한다.\n\nhttps://nextjs.org/docs/advanced-features/static-html-export#unsupported-features\n\n[Custom Loader](https://nextjs.org/docs/basic-features/image-optimization#loaders)를 활용해야한다고 하는데...\n\n```js\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './my/image/loader.js',\n  },\n}\n```\n\n[next-export-optimize-images](https://github.com/dc7290/next-export-optimize-images)\n\ngithub star가 100개 정도인 조금은 빈약한 오픈소스 라이브러리입니다.\n하지만 기존 `next/image`의 option에 100% 호환할 만큼 강력하고 적용하는 방법 또한 간편하기에 이를 사용하게 되었습니다.\n\n적용하는 방법 공식문서 그대로 따라하면 됩니다.\nhttps://next-export-optimize-images.vercel.app/docs/getting-started\n\n\n","slug":"nextjs-blog/2-image-optimization","readingMinutes":1,"wordCount":65},{"title":"Next.js mdx 디랙토리 기반으로","description":"Next.js 블로그를 제작기 - Next.js static html에서 이미지를 최적화해보자 🤔","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n","slug":"nextjs-blog/3-blog-list","readingMinutes":0,"wordCount":2},{"title":"mdx plugin","description":"next-mdx-remote 에서 플로그인 쓰는 법","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n# 기본 사용법\n\n```ts\nconst mdxSource = await serialize(content, {\n  mdxOptions: {\n    remarkPlugins: [],\n    rehypePlugins: [],\n  },\n  scope: data,\n});\n```\n\n## 필수 플러그인\n\n### remark-toc\n\nhttps://github.com/remarkjs/remark-toc\n\n### rehype-slug\n\nhttps://github.com/rehypejs/rehype-slug\n\nheadings에 id를 심어준다.\n이전에 많이 사용되었던 remark-slug는 deprecated 되었다.\n\n- rehype-autolink-headings\n  https://github.com/rehypejs/rehype-autolink-headings\n\n`span.icon.icon-link`을 활용하여 anchor를 만들 수 있다.\n\n```css\nh2 > a > span.icon.icon-link {\n  width: 18px;\n  height: 18px;\n}\n\nh3 > a > span.icon.icon-link {\n  width: 15px;\n  height: 15px;\n}\n\nh4 > a > span.icon.icon-link {\n  width: 12px;\n  height: 12px;\n}\n\nspan.icon.icon-link {\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n  margin-right: 2px;\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 490 490' style='enable-background:new 0 0 490 490;' xml:space='preserve'%3E%3Cpath d='M64.333 490h58.401l33.878-137.69h122.259L245.39 490h58.401l33.878-137.69h119.92v-48.162h-108.24l29.2-117.324h79.04v-48.162H390.23L424.108 0H365.31l-33.878 138.661H208.79L242.668 0h-58.415l-33.864 138.661H32.411v48.162h106.298l-28.818 117.324h-77.48v48.162h65.8L64.333 490zM197.11 186.824h122.642l-29.2 117.324h-122.26l28.818-117.324z'/%3E%3C/svg%3E\");\n}\n\n.dark span.icon.icon-link {\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 490 490' style='enable-background:new 0 0 490 490; fill:white;' xml:space='preserve'%3E%3Cpath d='M64.333 490h58.401l33.878-137.69h122.259L245.39 490h58.401l33.878-137.69h119.92v-48.162h-108.24l29.2-117.324h79.04v-48.162H390.23L424.108 0H365.31l-33.878 138.661H208.79L242.668 0h-58.415l-33.864 138.661H32.411v48.162h106.298l-28.818 117.324h-77.48v48.162h65.8L64.333 490zM197.11 186.824h122.642l-29.2 117.324h-122.26l28.818-117.324z'/%3E%3C/svg%3E\");\n}\n```\n\n### remark-gfm\n\nhttps://github.com/remarkjs/remark-gfm\n\nsupport GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n\n### @tailwindcss/typography\n\nhttps://tailwindcss.com/docs/typography-plugin\n\ntailwind 기반으로 mdx 스타일링\n\n### code-highlighting\n\nhttps://github.com/rockchalkwushock/rehype-code-titles\n\n## 참고 플로그인\n\n### remark-math\n\nhttps://github.com/remarkjs/remark-math\n\n### reading-time\n\nhttps://github.com/ngryman/reading-time\n\n## 참고\n\nhttps://yceffort.kr/2020/10/migrate-gatsby-from-nextjs\nhttps://colinhemphill.com/blog/fast-static-syntax-highlighting-for-mdx-in-nextjs\n\nProject Level Snippets\nhttps://code.visualstudio.com/updates/v1_28#_project-level-snippets\n","slug":"nextjs-blog/4-mdx-plugin","readingMinutes":2,"wordCount":187}],"readingMinutes":5,"slug":"nextjs-blog"},{"title":"DND 마스터리","description":"Drag and Drop 이벤트를 라이브러리 없이 구현해서 활용해봅니다.","tags":[],"draft":false,"date":"2022-10-01","posts":[{"title":"Drag 이벤트 뽀개기","description":"라이브러리 없이 React에서 element를 커서로 움직이게 하자!!!","tags":["Next.js","React","DOM"],"draft":false,"date":"2022-10-01","content":"\n\ndrag관련해서 좋은 라이브러리들이 있지만 순수하게 구현해보고 싶다.\n더 나아가 관련해서 `drag and drop`, `resize`, `carousel` 등 다양한 기능까지 구현해볼 생각이다.\n아래의 스펙으로 구현을 시작해보자 🏄🏻‍♂️\n- `NextJS` `React`\n- `Typescript`\n- `Tilwind` ~~괜히 진입장벽이 생긴 것 같다... 미얀합니다...~~\n- ~~`라이브러리`~~\n- ~~`onDragStart`~~\n\n> **TL;DR**\n> `mousedown`에서 `mousemove` `mouseup` 이벤트를 등록한다.\n> `mousemove`에서 `event.pageX`와 `mousedown`의 `event.pageX` 차이를 활용해 엘리먼트를 이동시킨다.\n> `mouseup`에서 `mousemove` 이벤트를 해제시킨다.\n\n<br />\n<br />\n\n### 사전 지식 — DOM 이해\n\n마우스의 움직임 바탕으로 element의 위치를 이동시켜야 한다.\n따라서 마우스 관련 이벤트를 잘 이해해야 한다.\n\n`mousedown` — 마우스 클릭 이벤트\n`mousemove` — 마우스 이동 이벤트\n`mouseup` — 마우스 클릭 해제 이벤트\n[https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)\n\n위 DOM 이벤트를 활용하여 마우스의 정보를 받아 올 수 있을 것 같다.\n그렇다면 **MouseEvent**는 어떤 속성을 가지고 있을까?\n비슷 비슷하게 보이는 친구들이 많은데 차이를 비교해보자.\n\n| Properties |   |\n| --- | --- |\n| **x, clientX** | in local (DOM content) coordinates.<br />event가 발생되는 element 기준으로 위치를 산정한다. |\n| **pageX** | relative to the whole document.<br />page document을 기준으로 위치를 산정한다.\n| **screenX** | in global (screen) coordinates.<br />더 나아가 듀얼 모니터의 주 모니터를 기준으로 위치를 산정한다. |\n\n무엇을 사용하던 크게 문제될 것이 없어보여 screenX을 사용해보자.\n\n<br />\n<br />\n<br />\n\n### 기본 원리 — Drag 이벤트 등록\n\n그렇다면 DOM 이벤트를 활용하여 마우스의 움직임을 추적해보자!\n주요 로직은 아래와 같다.\n\n1. 클릭시(`onMouseDown`) document에 `mousemove` `mouseup` 이벤트를 등록한다.\n2. 클릭된 상태에서 마우스를 움직일시 `mousemove`에 등록 된 함수가 계속 호출된다.\n3. `mouseup` 이벤트에서 `mousemove` 이벤트를 제거한다.\n\n```jsx\n<div\n  onMouseDown={() => {\n    // 2️⃣\n    const mouseMoveHandler = (e: MouseEvent) => {\n      console.log(`mouse move x:${e.screenX} y:${e.screenY}`);\n    };\n\n    // 3️⃣\n    const mouseUpHandler = (e: MouseEvent) => {\n      console.warn(`>>>> mouse up x:${e.screenX} y:${e.screenY}`);\n      document.removeEventListener('mousemove', mouseMoveHandler);\n    };\n\n    // 1️⃣\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler, { once: true });\n    // mouseup 이벤트는 한번만 실행되면 되기에 { once: true } 옵션을 추가해준다.\n  }}\n/>\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/40730059-40c1-4a9c-8fc9-c9abfd59c82d/image.gif)\n\n\n<br />\n<br />\n<br />\n\n### 기본 응용 — Drag 위치 이동\n\n마우스의 움직임을 추적하였으니,\n이제 이를 활용하여 element를 drag해서 위치를 움직여보자!\n\n\n1. element의 `position` 상태를 정의한다.\n2. 클릭(`mousedown`) 이벤트 발생시의 커서 위치를 기준으로,\n이동(`mousemove`) 이벤트에서 **상대적으로 이동한 거리(deltaX, deltaY)**를 계산한다.\n3. `position` 상태를 변경하여 element를 움직이게 한다.\n\n```tsx\n// 1️⃣\nconst [{ x, y }, setPosition] = useState({\n\tx: 0,\n\ty: 0,\n});\n\nreturn <div>\n\t<div\n\t\tstyle={{ transform: `translateX(${x}px) translateY(${y}px)` }}\n        onMouseDown={(clickEvent: React.MouseEvent<Element, MouseEvent>) => {\n            const mouseMoveHandler = (moveEvent: MouseEvent) => {\n              // 2️⃣\n              const deltaX = moveEvent.screenX - clickEvent.screenX;\n              const deltaY = moveEvent.screenY - clickEvent.screenY;\n\n              // 3️⃣\n              setPosition({\n                  x: x + deltaX,\n                  y: y + deltaY,\n              });\n            };\n\n            const mouseUpHandler = () => {\n              document.removeEventListener('mousemove', mouseMoveHandler);\n            };\n\n            document.addEventListener('mousemove', mouseMoveHandler);\n            document.addEventListener('mouseup', mouseUpHandler, { once: true });\n      \t}}\n\t/>\n</div>\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/5c38729e-f30e-406f-92e6-de16918f87c0/image.gif)\n\n(TIP)\n에니메니션 인터랙션을 고려할 경우,\n실제 drag할 element(`Box`)를 div로 씌워서 이벤트, style를 등록 것이 좋다.\n\n`transition: transform` 경우 원치않게 에니메이션 효과가 적용될 수 있다.\n\n```jsx\n<div\n\tstyle={...}\n\tonMouseDown={...}\n>\n\t<Box />\n</div>\n```\n\n<br />\n<br />\n<br />\n\n### 심화 응용 — **Drag Boundary**\n\ndrag할 때 특정 영역(boundary)을 벗어나지 않길 원할 수 있다.\n위 2번 과정, `mousemove`이벤트에서 **특정 범위를 벗어나지 않도록 제한**하면 된다.\n\n\n![](https://velog.velcdn.com/images/bepyan/post/ac92e9bf-fce7-48b5-8a83-acc04b183878/image.png)\n\n\n#### 1. boundary, box element의 크기를 얻는다.\n\n[getBoundingClientRect]((https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect))을 활용하여 element의 정보를 얻을 수 있다.\n```tsx\nconst boundary = boundaryRef.current.getBoundingClientRect();\nconst box = boxRef.current.getBoundingClientRect();\n// x, y, width, height\n```\n    \n\n\n#### 2. drag할 수 있는 경계(minx, maxx, miny, maxy)를 계산한다.\nelement를 놓는 기준에 따라 boundary가 달라지는데 상황에 맞게 잘 계산하면 된다.\n\n<br />\n<br />\n\ndrag element이 **중앙 정렬**되었다고 생각해보자.\n기본 box의 위치는 `x:0, y:0`(중앙) 이다.\n\n따라서 element의 제한 범위를 계산해보면\n\n![](https://velog.velcdn.com/images/bepyan/post/26ef16ac-fa25-4c96-b2f7-da4bf5759f0c/image.png)![](https://velog.velcdn.com/images/bepyan/post/332fa024-b6ec-46fe-9b0e-40527d11e101/image.png)\n\n좌측 끝  = `-boundary.width/2` + `box.width/2` + `margin`\n우측 끝  =  `boundary.width/2` - `box.width/2` - `margin`\n\n\n먼저, 범위를 얻는 유틸함수를 만들면 코드가 더 깔끔해질 것 같다.\n```tsx\nconst inrange = (v: number, min: number, max: number) => {\n  if (v < min) return min;\n  if (v > max) return max;\n  return v;\n};\n```\n\n\n코드에 적용하면 아래와 같다.\n```tsx\nconst BOUNDARY_MARGIN = 12;\nconst deltaX = moveEvent.screenX - clickEvent.screenX;\nconst deltaY = moveEvent.screenY - clickEvent.screenY;\n\nsetPosition({\n  x: inrange(\n      x + deltaX,\n      Math.floor(-boundary.width / 2 + box.width / 2 + BOUNDARY_MARGIN),\n\t  Math.floor(boundary.width / 2 - box.width / 2 - BOUNDARY_MARGIN),\n  ),\n  y: inrange(\n      y + deltaY,\n      Math.floor(-boundary.height / 2 + box.height / 2 + BOUNDARY_MARGIN),\n      Math.floor(boundary.height / 2 - box.height / 2 - BOUNDARY_MARGIN),\n  ),\n});\n```\n\n<br />\n<br />\n\n이제 drag element가 **absolute**하다고 생각해보자.\n기본 box의 위치는 boundary의 좌상단(`x:0, y:0`) 이다.\n\n따라서 element의 제한 범위를 계산해보면\n![](https://velog.velcdn.com/images/bepyan/post/1d9d532f-5d0d-45a4-93fc-b2eb12b6ada7/image.png)![](https://velog.velcdn.com/images/bepyan/post/173cb287-673d-478f-a24a-1a3eadf8b8ee/image.png)\n\n좌측 끝 = `margin`\n우측 끝 = `boundary.width` - `box.width` - `margin`\n\n코드에 적용하면 아래와 같다.\n~~코드가 더 깔끔한 느낌은 기분탓인가..~~\n\n```tsx\nconst BOUNDARY_MARGIN = 12;\nconst deltaX = moveEvent.screenX - clickEvent.screenX;\nconst deltaY = moveEvent.screenY - clickEvent.screenY;\n\nsetPosition({\n  x: inrange(\n    x + deltaX,\n    BOUNDARY_MARGIN,\n    boundary.width - box.width - BOUNDARY_MARGIN\n  ),\n  y: inrange(\n    y + deltaY,\n    BOUNDARY_MARGIN\n    boundary.height - box.height - BOUNDARY_MARGIN,\n  ),\n});\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/65b91811-a409-4877-90aa-f589b5768ee8/image.gif)\n\n뭔가 그럴듯한 결과물이 나왔다 ✨✨\n\n<br />\n<br />\n<br />\n\n### 응용 마무리 — 유틸 함수로 만들기\n\n관련된 기능을 유틸 함수로 추출하면 쉽게 element를 적용시킬 수 있을 거 같다.\n\n```tsx\nexport default function registMouseDownDrag(\n  onDragChange: (deltaX: number, deltaY: number) => void,\n  stopPropagation?: boolean,\n) {\n  return {\n    onMouseDown: (clickEvent: React.MouseEvent<Element, MouseEvent>) => {\n      if (stopPropagation) clickEvent.stopPropagation();\n\n      const mouseMoveHandler = (moveEvent: MouseEvent) => {\n        const deltaX = moveEvent.screenX - clickEvent.screenX;\n        const deltaY = moveEvent.screenY - clickEvent.screenY;\n        onDragChange(deltaX, deltaY);\n      };\n\n      const mouseUpHandler = () => {\n        document.removeEventListener('mousemove', mouseMoveHandler);\n      };\n\n      document.addEventListener('mousemove', mouseMoveHandler);\n      document.addEventListener('mouseup', mouseUpHandler, { once: true });\n    },\n  };\n}\n```\n\n`stopPropagation` 경우 click이벤트가 전파되지 않기 위함이다.\n부모 div의 click이벤트가 실행되면 곤란한 경우가 있다...\n\n`onDragChange`를 콜벡으로 받아서 쉽게 커스터마이징을 할 수 있을 것 같다.\n코드에 응용해보자.\n```tsx\nconst [{ x, y }, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n```\n```tsx\n<div\n  style={{ left: x, top: y }}\n  {...registMouseDownDrag((deltaX, deltaY) => {\n    setConfig({\n      x: x + deltaX,\n      y: y + deltaY,\n    });\n  })}\n  >\n```\n\n<br />\n<br />\n<br />\n\n실제 동작은 아래 링크에서 볼 수 있다.\nhttps://dnd-playground.vercel.app/\n\nstyle 정보, 전체 코드는 아래 깃허브에서 살펴보면 될 것 같다.\nhttps://github.com/bepyan/dnd-playground\n","slug":"dnd-master/1-drag-event","readingMinutes":9,"wordCount":979}],"readingMinutes":9,"slug":"dnd-master"}],"posts":[{"title":"Next.js 블로그 utterances로 댓글 ","description":"","tags":[],"draft":false,"date":"2022-11-13","content":"\n### 참고\n\nhttps://github.com/utterance/utterances/issues/161#issuecomment-820722906\nhttps://github.com/utterance/utterances/issues/549#issuecomment-913070158\n","slug":"nextjs-blog/5-utterances","readingMinutes":1,"wordCount":6},{"title":"Example Post","description":"This frontmatter description will appear below the title","tags":["markdown"],"date":"2022-11-11","content":"\n# h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1h1\n\n## h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\n\n### h3\n\n#### h4\n\n##### h5\n\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\nh2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2h2\n\nThis is an example post, with a [link](https://nextjs.org) and a React component:\n\nThe title and description are pulled from the MDX file and processed using `gray-matter`. Additionally, links are rendered using a custom component passed to `next-mdx-remote`.\n\nGo back [home](/).\n","slug":"2022/example","readingMinutes":1,"wordCount":62},{"title":"Project Boilerplate 세팅하기","description":"next-mdx-remote 에서 플로그인 쓰는 법","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n블로그의 스택은 아래와 같다.\n\n- NextJS\n- Typescript\n- TailwindCSS\n- next-mdx-remote\n","slug":"nextjs-blog/1-boilerplate","readingMinutes":1,"wordCount":14},{"title":"image optimization","description":"Next.js static html에서 이미지를 최적화해보자 🤔","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n기본적으로 next/image를 활용하면 이미지를 최적화시킬 수 있다.\n\n다만 static-html-export 환경에서는 이를 제공해주지 않는다고 한다.\n\nhttps://nextjs.org/docs/advanced-features/static-html-export#unsupported-features\n\n[Custom Loader](https://nextjs.org/docs/basic-features/image-optimization#loaders)를 활용해야한다고 하는데...\n\n```js\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './my/image/loader.js',\n  },\n}\n```\n\n[next-export-optimize-images](https://github.com/dc7290/next-export-optimize-images)\n\ngithub star가 100개 정도인 조금은 빈약한 오픈소스 라이브러리입니다.\n하지만 기존 `next/image`의 option에 100% 호환할 만큼 강력하고 적용하는 방법 또한 간편하기에 이를 사용하게 되었습니다.\n\n적용하는 방법 공식문서 그대로 따라하면 됩니다.\nhttps://next-export-optimize-images.vercel.app/docs/getting-started\n\n\n","slug":"nextjs-blog/2-image-optimization","readingMinutes":1,"wordCount":65},{"title":"Next.js mdx 디랙토리 기반으로","description":"Next.js 블로그를 제작기 - Next.js static html에서 이미지를 최적화해보자 🤔","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n","slug":"nextjs-blog/3-blog-list","readingMinutes":0,"wordCount":2},{"title":"mdx plugin","description":"next-mdx-remote 에서 플로그인 쓰는 법","tags":["nextjs","blog"],"date":"2022-11-11","content":"\n# 기본 사용법\n\n```ts\nconst mdxSource = await serialize(content, {\n  mdxOptions: {\n    remarkPlugins: [],\n    rehypePlugins: [],\n  },\n  scope: data,\n});\n```\n\n## 필수 플러그인\n\n### remark-toc\n\nhttps://github.com/remarkjs/remark-toc\n\n### rehype-slug\n\nhttps://github.com/rehypejs/rehype-slug\n\nheadings에 id를 심어준다.\n이전에 많이 사용되었던 remark-slug는 deprecated 되었다.\n\n- rehype-autolink-headings\n  https://github.com/rehypejs/rehype-autolink-headings\n\n`span.icon.icon-link`을 활용하여 anchor를 만들 수 있다.\n\n```css\nh2 > a > span.icon.icon-link {\n  width: 18px;\n  height: 18px;\n}\n\nh3 > a > span.icon.icon-link {\n  width: 15px;\n  height: 15px;\n}\n\nh4 > a > span.icon.icon-link {\n  width: 12px;\n  height: 12px;\n}\n\nspan.icon.icon-link {\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n  margin-right: 2px;\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 490 490' style='enable-background:new 0 0 490 490;' xml:space='preserve'%3E%3Cpath d='M64.333 490h58.401l33.878-137.69h122.259L245.39 490h58.401l33.878-137.69h119.92v-48.162h-108.24l29.2-117.324h79.04v-48.162H390.23L424.108 0H365.31l-33.878 138.661H208.79L242.668 0h-58.415l-33.864 138.661H32.411v48.162h106.298l-28.818 117.324h-77.48v48.162h65.8L64.333 490zM197.11 186.824h122.642l-29.2 117.324h-122.26l28.818-117.324z'/%3E%3C/svg%3E\");\n}\n\n.dark span.icon.icon-link {\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 490 490' style='enable-background:new 0 0 490 490; fill:white;' xml:space='preserve'%3E%3Cpath d='M64.333 490h58.401l33.878-137.69h122.259L245.39 490h58.401l33.878-137.69h119.92v-48.162h-108.24l29.2-117.324h79.04v-48.162H390.23L424.108 0H365.31l-33.878 138.661H208.79L242.668 0h-58.415l-33.864 138.661H32.411v48.162h106.298l-28.818 117.324h-77.48v48.162h65.8L64.333 490zM197.11 186.824h122.642l-29.2 117.324h-122.26l28.818-117.324z'/%3E%3C/svg%3E\");\n}\n```\n\n### remark-gfm\n\nhttps://github.com/remarkjs/remark-gfm\n\nsupport GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n\n### @tailwindcss/typography\n\nhttps://tailwindcss.com/docs/typography-plugin\n\ntailwind 기반으로 mdx 스타일링\n\n### code-highlighting\n\nhttps://github.com/rockchalkwushock/rehype-code-titles\n\n## 참고 플로그인\n\n### remark-math\n\nhttps://github.com/remarkjs/remark-math\n\n### reading-time\n\nhttps://github.com/ngryman/reading-time\n\n## 참고\n\nhttps://yceffort.kr/2020/10/migrate-gatsby-from-nextjs\nhttps://colinhemphill.com/blog/fast-static-syntax-highlighting-for-mdx-in-nextjs\n\nProject Level Snippets\nhttps://code.visualstudio.com/updates/v1_28#_project-level-snippets\n","slug":"nextjs-blog/4-mdx-plugin","readingMinutes":2,"wordCount":187},{"title":"Drag 이벤트 뽀개기","description":"라이브러리 없이 React에서 element를 커서로 움직이게 하자!!!","tags":["Next.js","React","DOM"],"draft":false,"date":"2022-10-01","content":"\n\ndrag관련해서 좋은 라이브러리들이 있지만 순수하게 구현해보고 싶다.\n더 나아가 관련해서 `drag and drop`, `resize`, `carousel` 등 다양한 기능까지 구현해볼 생각이다.\n아래의 스펙으로 구현을 시작해보자 🏄🏻‍♂️\n- `NextJS` `React`\n- `Typescript`\n- `Tilwind` ~~괜히 진입장벽이 생긴 것 같다... 미얀합니다...~~\n- ~~`라이브러리`~~\n- ~~`onDragStart`~~\n\n> **TL;DR**\n> `mousedown`에서 `mousemove` `mouseup` 이벤트를 등록한다.\n> `mousemove`에서 `event.pageX`와 `mousedown`의 `event.pageX` 차이를 활용해 엘리먼트를 이동시킨다.\n> `mouseup`에서 `mousemove` 이벤트를 해제시킨다.\n\n<br />\n<br />\n\n### 사전 지식 — DOM 이해\n\n마우스의 움직임 바탕으로 element의 위치를 이동시켜야 한다.\n따라서 마우스 관련 이벤트를 잘 이해해야 한다.\n\n`mousedown` — 마우스 클릭 이벤트\n`mousemove` — 마우스 이동 이벤트\n`mouseup` — 마우스 클릭 해제 이벤트\n[https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)\n\n위 DOM 이벤트를 활용하여 마우스의 정보를 받아 올 수 있을 것 같다.\n그렇다면 **MouseEvent**는 어떤 속성을 가지고 있을까?\n비슷 비슷하게 보이는 친구들이 많은데 차이를 비교해보자.\n\n| Properties |   |\n| --- | --- |\n| **x, clientX** | in local (DOM content) coordinates.<br />event가 발생되는 element 기준으로 위치를 산정한다. |\n| **pageX** | relative to the whole document.<br />page document을 기준으로 위치를 산정한다.\n| **screenX** | in global (screen) coordinates.<br />더 나아가 듀얼 모니터의 주 모니터를 기준으로 위치를 산정한다. |\n\n무엇을 사용하던 크게 문제될 것이 없어보여 screenX을 사용해보자.\n\n<br />\n<br />\n<br />\n\n### 기본 원리 — Drag 이벤트 등록\n\n그렇다면 DOM 이벤트를 활용하여 마우스의 움직임을 추적해보자!\n주요 로직은 아래와 같다.\n\n1. 클릭시(`onMouseDown`) document에 `mousemove` `mouseup` 이벤트를 등록한다.\n2. 클릭된 상태에서 마우스를 움직일시 `mousemove`에 등록 된 함수가 계속 호출된다.\n3. `mouseup` 이벤트에서 `mousemove` 이벤트를 제거한다.\n\n```jsx\n<div\n  onMouseDown={() => {\n    // 2️⃣\n    const mouseMoveHandler = (e: MouseEvent) => {\n      console.log(`mouse move x:${e.screenX} y:${e.screenY}`);\n    };\n\n    // 3️⃣\n    const mouseUpHandler = (e: MouseEvent) => {\n      console.warn(`>>>> mouse up x:${e.screenX} y:${e.screenY}`);\n      document.removeEventListener('mousemove', mouseMoveHandler);\n    };\n\n    // 1️⃣\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler, { once: true });\n    // mouseup 이벤트는 한번만 실행되면 되기에 { once: true } 옵션을 추가해준다.\n  }}\n/>\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/40730059-40c1-4a9c-8fc9-c9abfd59c82d/image.gif)\n\n\n<br />\n<br />\n<br />\n\n### 기본 응용 — Drag 위치 이동\n\n마우스의 움직임을 추적하였으니,\n이제 이를 활용하여 element를 drag해서 위치를 움직여보자!\n\n\n1. element의 `position` 상태를 정의한다.\n2. 클릭(`mousedown`) 이벤트 발생시의 커서 위치를 기준으로,\n이동(`mousemove`) 이벤트에서 **상대적으로 이동한 거리(deltaX, deltaY)**를 계산한다.\n3. `position` 상태를 변경하여 element를 움직이게 한다.\n\n```tsx\n// 1️⃣\nconst [{ x, y }, setPosition] = useState({\n\tx: 0,\n\ty: 0,\n});\n\nreturn <div>\n\t<div\n\t\tstyle={{ transform: `translateX(${x}px) translateY(${y}px)` }}\n        onMouseDown={(clickEvent: React.MouseEvent<Element, MouseEvent>) => {\n            const mouseMoveHandler = (moveEvent: MouseEvent) => {\n              // 2️⃣\n              const deltaX = moveEvent.screenX - clickEvent.screenX;\n              const deltaY = moveEvent.screenY - clickEvent.screenY;\n\n              // 3️⃣\n              setPosition({\n                  x: x + deltaX,\n                  y: y + deltaY,\n              });\n            };\n\n            const mouseUpHandler = () => {\n              document.removeEventListener('mousemove', mouseMoveHandler);\n            };\n\n            document.addEventListener('mousemove', mouseMoveHandler);\n            document.addEventListener('mouseup', mouseUpHandler, { once: true });\n      \t}}\n\t/>\n</div>\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/5c38729e-f30e-406f-92e6-de16918f87c0/image.gif)\n\n(TIP)\n에니메니션 인터랙션을 고려할 경우,\n실제 drag할 element(`Box`)를 div로 씌워서 이벤트, style를 등록 것이 좋다.\n\n`transition: transform` 경우 원치않게 에니메이션 효과가 적용될 수 있다.\n\n```jsx\n<div\n\tstyle={...}\n\tonMouseDown={...}\n>\n\t<Box />\n</div>\n```\n\n<br />\n<br />\n<br />\n\n### 심화 응용 — **Drag Boundary**\n\ndrag할 때 특정 영역(boundary)을 벗어나지 않길 원할 수 있다.\n위 2번 과정, `mousemove`이벤트에서 **특정 범위를 벗어나지 않도록 제한**하면 된다.\n\n\n![](https://velog.velcdn.com/images/bepyan/post/ac92e9bf-fce7-48b5-8a83-acc04b183878/image.png)\n\n\n#### 1. boundary, box element의 크기를 얻는다.\n\n[getBoundingClientRect]((https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect))을 활용하여 element의 정보를 얻을 수 있다.\n```tsx\nconst boundary = boundaryRef.current.getBoundingClientRect();\nconst box = boxRef.current.getBoundingClientRect();\n// x, y, width, height\n```\n    \n\n\n#### 2. drag할 수 있는 경계(minx, maxx, miny, maxy)를 계산한다.\nelement를 놓는 기준에 따라 boundary가 달라지는데 상황에 맞게 잘 계산하면 된다.\n\n<br />\n<br />\n\ndrag element이 **중앙 정렬**되었다고 생각해보자.\n기본 box의 위치는 `x:0, y:0`(중앙) 이다.\n\n따라서 element의 제한 범위를 계산해보면\n\n![](https://velog.velcdn.com/images/bepyan/post/26ef16ac-fa25-4c96-b2f7-da4bf5759f0c/image.png)![](https://velog.velcdn.com/images/bepyan/post/332fa024-b6ec-46fe-9b0e-40527d11e101/image.png)\n\n좌측 끝  = `-boundary.width/2` + `box.width/2` + `margin`\n우측 끝  =  `boundary.width/2` - `box.width/2` - `margin`\n\n\n먼저, 범위를 얻는 유틸함수를 만들면 코드가 더 깔끔해질 것 같다.\n```tsx\nconst inrange = (v: number, min: number, max: number) => {\n  if (v < min) return min;\n  if (v > max) return max;\n  return v;\n};\n```\n\n\n코드에 적용하면 아래와 같다.\n```tsx\nconst BOUNDARY_MARGIN = 12;\nconst deltaX = moveEvent.screenX - clickEvent.screenX;\nconst deltaY = moveEvent.screenY - clickEvent.screenY;\n\nsetPosition({\n  x: inrange(\n      x + deltaX,\n      Math.floor(-boundary.width / 2 + box.width / 2 + BOUNDARY_MARGIN),\n\t  Math.floor(boundary.width / 2 - box.width / 2 - BOUNDARY_MARGIN),\n  ),\n  y: inrange(\n      y + deltaY,\n      Math.floor(-boundary.height / 2 + box.height / 2 + BOUNDARY_MARGIN),\n      Math.floor(boundary.height / 2 - box.height / 2 - BOUNDARY_MARGIN),\n  ),\n});\n```\n\n<br />\n<br />\n\n이제 drag element가 **absolute**하다고 생각해보자.\n기본 box의 위치는 boundary의 좌상단(`x:0, y:0`) 이다.\n\n따라서 element의 제한 범위를 계산해보면\n![](https://velog.velcdn.com/images/bepyan/post/1d9d532f-5d0d-45a4-93fc-b2eb12b6ada7/image.png)![](https://velog.velcdn.com/images/bepyan/post/173cb287-673d-478f-a24a-1a3eadf8b8ee/image.png)\n\n좌측 끝 = `margin`\n우측 끝 = `boundary.width` - `box.width` - `margin`\n\n코드에 적용하면 아래와 같다.\n~~코드가 더 깔끔한 느낌은 기분탓인가..~~\n\n```tsx\nconst BOUNDARY_MARGIN = 12;\nconst deltaX = moveEvent.screenX - clickEvent.screenX;\nconst deltaY = moveEvent.screenY - clickEvent.screenY;\n\nsetPosition({\n  x: inrange(\n    x + deltaX,\n    BOUNDARY_MARGIN,\n    boundary.width - box.width - BOUNDARY_MARGIN\n  ),\n  y: inrange(\n    y + deltaY,\n    BOUNDARY_MARGIN\n    boundary.height - box.height - BOUNDARY_MARGIN,\n  ),\n});\n```\n\n![](https://velog.velcdn.com/images/bepyan/post/65b91811-a409-4877-90aa-f589b5768ee8/image.gif)\n\n뭔가 그럴듯한 결과물이 나왔다 ✨✨\n\n<br />\n<br />\n<br />\n\n### 응용 마무리 — 유틸 함수로 만들기\n\n관련된 기능을 유틸 함수로 추출하면 쉽게 element를 적용시킬 수 있을 거 같다.\n\n```tsx\nexport default function registMouseDownDrag(\n  onDragChange: (deltaX: number, deltaY: number) => void,\n  stopPropagation?: boolean,\n) {\n  return {\n    onMouseDown: (clickEvent: React.MouseEvent<Element, MouseEvent>) => {\n      if (stopPropagation) clickEvent.stopPropagation();\n\n      const mouseMoveHandler = (moveEvent: MouseEvent) => {\n        const deltaX = moveEvent.screenX - clickEvent.screenX;\n        const deltaY = moveEvent.screenY - clickEvent.screenY;\n        onDragChange(deltaX, deltaY);\n      };\n\n      const mouseUpHandler = () => {\n        document.removeEventListener('mousemove', mouseMoveHandler);\n      };\n\n      document.addEventListener('mousemove', mouseMoveHandler);\n      document.addEventListener('mouseup', mouseUpHandler, { once: true });\n    },\n  };\n}\n```\n\n`stopPropagation` 경우 click이벤트가 전파되지 않기 위함이다.\n부모 div의 click이벤트가 실행되면 곤란한 경우가 있다...\n\n`onDragChange`를 콜벡으로 받아서 쉽게 커스터마이징을 할 수 있을 것 같다.\n코드에 응용해보자.\n```tsx\nconst [{ x, y }, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n```\n```tsx\n<div\n  style={{ left: x, top: y }}\n  {...registMouseDownDrag((deltaX, deltaY) => {\n    setConfig({\n      x: x + deltaX,\n      y: y + deltaY,\n    });\n  })}\n  >\n```\n\n<br />\n<br />\n<br />\n\n실제 동작은 아래 링크에서 볼 수 있다.\nhttps://dnd-playground.vercel.app/\n\nstyle 정보, 전체 코드는 아래 깃허브에서 살펴보면 될 것 같다.\nhttps://github.com/bepyan/dnd-playground\n","slug":"dnd-master/1-drag-event","readingMinutes":9,"wordCount":979}]},"__N_SSG":true}